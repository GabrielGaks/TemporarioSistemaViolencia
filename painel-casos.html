<!DOCTYPE html>
<html lang="pt-BR">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
  <meta http-equiv="Pragma" content="no-cache">
  <meta http-equiv="Expires" content="0">
  <title>Painel de Casos de Violência Escolar</title>

  <!-- Esconde conteúdo IMEDIATAMENTE para evitar flash -->
  <style>
    html:not(.page-ready) {
      opacity: 0 !important;
      visibility: hidden !important;
    }

    html.page-ready {
      opacity: 1 !important;
      visibility: visible !important;
      transition: opacity 0.3s ease, visibility 0.3s ease;
    }
  </style>

  <!-- TailwindCSS via CDN -->
  <script>
    // Suprime o aviso de produção do Tailwind CSS
    (function () {
      const originalWarn = console.warn;
      let tailwindWarningSuppressed = false;

      console.warn = function (...args) {
        const message = args.join(' ');
        // Suprime aviso do Tailwind CSS sobre produção
        if (message.includes('cdn.tailwindcss.com should not be used') ||
          message.includes('To use Tailwind CSS in production') ||
          message.includes('install it as a PostCSS plugin') ||
          message.includes('use the Tailwind CLI')) {
          tailwindWarningSuppressed = true;
          return; // Suprime o aviso
        }
        originalWarn.apply(console, args);
      };

      // Restaura console.warn após alguns segundos (Tailwind já terá carregado)
      setTimeout(() => {
        if (tailwindWarningSuppressed) {
          console.warn = originalWarn;
        }
      }, 5000);
    })();
  </script>
  <script src="https://cdn.tailwindcss.com"></script>

  <!-- Estilos Elegantes Compartilhados -->
  <link rel="stylesheet" href="assets/css/styles-elegant.css">

  <!-- Configuração Centralizada -->
  <script src="config.js"></script>
  <script src="assets/js/utils/config-loader.js"></script>

  <!-- Sistema de Transições entre Páginas -->
  <script src="assets/js/utils/page-transitions.js"></script>

  <!-- Sistema de Loading Indicator Elegante -->
  <script src="assets/js/utils/loading-indicator.js"></script>

  <!-- Sistema de Scroll Reveal - Revelação Progressiva -->
  <script src="assets/js/utils/scroll-reveal.js"></script>

  <!-- Sistema de Cache e Notificações -->
  <link rel="stylesheet" href="assets/css/update-notification.css">
  <script src="assets/js/utils/data-cache.js"></script>
  <script src="assets/js/utils/change-detector.js"></script>
  <script src="assets/js/utils/update-notification.js"></script>

  <!-- Sistema de API e Segurança -->
  <script src="assets/js/utils/security.js"></script>
  <script src="assets/js/utils/api.js"></script>

  <!-- Sistema de Navegação por Perfil -->
  <script src="assets/js/utils/navigation.js"></script>

  <!-- Dashboard e Estatísticas (arquivo separado para evitar HTML muito longo) -->
  <script src="assets/js/modules/dashboard-stats.js"></script>

  <!-- Biblioteca para gráficos -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels@2.0.0"></script>

  <!-- Biblioteca para gerar PDF -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2pdf.js/0.10.1/html2pdf.bundle.min.js"></script>

  <!-- Intro.js CSS -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/intro.js/7.2.0/introjs.min.css">
  <!-- Onboarding CSS -->
  <link rel="stylesheet" href="assets/css/onboarding.css">

  <style>
    /* Scroll behavior suave e relaxado para toda a página */
    html {
      scroll-behavior: smooth;
      scroll-padding-top: 100px;
      /* Adiciona espaço no topo ao scrollar */
    }

    /* Customiza a duração do scroll suave via CSS */
    @media (prefers-reduced-motion: no-preference) {
      html {
        scroll-behavior: smooth;
      }
    }

    .fade-in {
      animation: fadeIn 0.3s ease-in;
    }

    @keyframes fadeIn {
      from {
        opacity: 0;
        transform: translateY(10px);
      }

      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    @keyframes slideUp {
      from {
        opacity: 0;
        transform: translateY(10px);
      }

      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    /* Animação suave para linhas da tabela */
    .record-row {
      animation: slideInRow 0.3s ease-out backwards;
    }

    @keyframes slideInRow {
      from {
        opacity: 0;
        transform: translateX(-10px);
      }

      to {
        opacity: 1;
        transform: translateX(0);
      }
    }

    /* Delay escalonado para cada linha */
    .record-row:nth-child(1) {
      animation-delay: 0.05s;
    }

    .record-row:nth-child(2) {
      animation-delay: 0.1s;
    }

    .record-row:nth-child(3) {
      animation-delay: 0.15s;
    }

    .record-row:nth-child(4) {
      animation-delay: 0.2s;
    }

    .record-row:nth-child(5) {
      animation-delay: 0.25s;
    }

    .record-row:nth-child(6) {
      animation-delay: 0.3s;
    }

    .record-row:nth-child(7) {
      animation-delay: 0.35s;
    }

    .record-row:nth-child(8) {
      animation-delay: 0.4s;
    }

    .record-row:nth-child(9) {
      animation-delay: 0.45s;
    }

    .record-row:nth-child(10) {
      animation-delay: 0.5s;
    }

    /* Checkboxes personalizados elegantes */
    .custom-checkbox {
      appearance: none;
      width: 18px;
      height: 18px;
      border: 2px solid #cbd5e1;
      border-radius: 5px;
      background-color: white;
      cursor: pointer;
      position: relative;
      transition: all 0.25s cubic-bezier(0.4, 0, 0.2, 1);
      flex-shrink: 0;
    }

    .custom-checkbox:hover {
      border-color: #3b82f6;
      box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
    }

    .custom-checkbox:checked {
      background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%);
      border-color: #2563eb;
      box-shadow: 0 2px 5px rgba(37, 99, 235, 0.3);
    }

    .custom-checkbox:checked::after {
      content: '✓';
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%) scale(1);
      color: white;
      font-size: 12px;
      font-weight: bold;
      animation: checkPop 0.3s cubic-bezier(0.68, -0.55, 0.265, 1.55);
    }

    @keyframes checkPop {
      0% {
        transform: translate(-50%, -50%) scale(0);
      }

      50% {
        transform: translate(-50%, -50%) scale(1.2);
      }

      100% {
        transform: translate(-50%, -50%) scale(1);
      }
    }

    /* Animações para notificação de nova notificação */
    @keyframes slideIn {
      from {
        opacity: 0;
        transform: translateX(100%);
      }

      to {
        opacity: 1;
        transform: translateX(0);
      }
    }

    @keyframes slideOut {
      from {
        opacity: 1;
        transform: translateX(0);
      }

      to {
        opacity: 0;
        transform: translateX(100%);
      }
    }

    /* ========================================
       NOTIFICAÇÃO ELEGANTE E COMPACTA
       ======================================== */
    .notificacao-nova-elegante {
      position: fixed;
      top: 20px;
      right: 20px;
      width: 360px;
      max-width: calc(100vw - 40px);
      background: #ffffff;
      border: 1px solid #e2e8f0;
      border-radius: 8px;
      box-shadow:
        0 4px 12px rgba(0, 0, 0, 0.08),
        0 1px 3px rgba(0, 0, 0, 0.05);
      z-index: 10000;
      overflow: hidden;
      opacity: 0;
      transform: translateX(100%) scale(0.95);
      transition: all 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Inter', sans-serif;
    }

    .notificacao-nova-elegante.notificacao-visible {
      animation: notificacaoEntrance 0.4s cubic-bezier(0.34, 1.56, 0.64, 1) forwards;
    }

    .notificacao-nova-elegante.notificacao-exit {
      animation: notificacaoExit 0.4s cubic-bezier(0.34, 1.56, 0.64, 1) forwards;
    }

    @keyframes notificacaoEntrance {
      from {
        opacity: 0;
        transform: translateX(100%) scale(0.95);
      }

      to {
        opacity: 1;
        transform: translateX(0) scale(1);
      }
    }

    @keyframes notificacaoExit {
      from {
        opacity: 1;
        transform: translateX(0) scale(1);
      }

      to {
        opacity: 0;
        transform: translateX(100%) scale(0.95);
      }
    }

    .notificacao-conteudo {
      position: relative;
      padding: 16px;
      display: flex;
      align-items: flex-start;
      gap: 12px;
      background: #ffffff;
    }

    .notificacao-icone-container {
      position: relative;
      flex-shrink: 0;
      width: 40px;
      height: 40px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: #eff6ff;
      border-radius: 8px;
      animation: notificacaoIconContainerPulse 2s ease-in-out infinite;
    }

    @keyframes notificacaoIconContainerPulse {

      0%,
      100% {
        background: #eff6ff;
        transform: scale(1);
      }

      50% {
        background: #dbeafe;
        transform: scale(1.05);
      }
    }

    .notificacao-icone {
      width: 20px;
      height: 20px;
      color: #3b82f6;
      animation: notificacaoIconEntrance 0.5s cubic-bezier(0.34, 1.56, 0.64, 1);
    }

    @keyframes notificacaoIconEntrance {
      0% {
        transform: scale(0) rotate(-180deg);
        opacity: 0;
      }

      60% {
        transform: scale(1.2) rotate(10deg);
      }

      100% {
        transform: scale(1) rotate(0deg);
        opacity: 1;
      }
    }

    .notificacao-texto {
      flex: 1;
      min-width: 0;
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    .notificacao-titulo {
      display: flex;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
    }

    .notificacao-badge {
      display: inline-flex;
      align-items: center;
      padding: 2px 6px;
      background: #3b82f6;
      color: white;
      font-size: 10px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.3px;
      border-radius: 4px;
      flex-shrink: 0;
      animation: notificacaoBadgeEntrance 0.5s cubic-bezier(0.68, -0.55, 0.265, 1.55);
    }

    @keyframes notificacaoBadgeEntrance {
      0% {
        transform: scale(0);
        opacity: 0;
      }

      50% {
        transform: scale(1.15);
      }

      100% {
        transform: scale(1);
        opacity: 1;
      }
    }

    .notificacao-mensagem-principal {
      font-size: 14px;
      font-weight: 600;
      color: #1e293b;
      line-height: 1.4;
      word-wrap: break-word;
      animation: notificacaoTextFadeIn 0.6s ease-out 0.2s both;
    }

    @keyframes notificacaoTextFadeIn {
      from {
        opacity: 0;
        transform: translateY(-5px);
      }

      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    .notificacao-descricao {
      font-size: 12px;
      color: #64748b;
      line-height: 1.5;
      word-wrap: break-word;
      animation: notificacaoTextFadeIn 0.6s ease-out 0.3s both;
    }

    .notificacao-acoes {
      display: flex;
      align-items: center;
      gap: 8px;
      flex-shrink: 0;
      margin-top: 4px;
    }

    .notificacao-btn-atualizar {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 6px 12px;
      background: #3b82f6;
      color: white;
      border: none;
      border-radius: 6px;
      font-size: 12px;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      white-space: nowrap;
      animation: notificacaoButtonEntrance 0.5s ease-out 0.4s both;
    }

    @keyframes notificacaoButtonEntrance {
      from {
        opacity: 0;
        transform: translateX(10px);
      }

      to {
        opacity: 1;
        transform: translateX(0);
      }
    }

    .notificacao-btn-atualizar:hover {
      background: #2563eb;
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
    }

    .notificacao-btn-atualizar:active {
      transform: translateY(0);
    }

    .notificacao-btn-atualizar svg {
      width: 14px;
      height: 14px;
      transition: transform 0.3s ease;
    }

    .notificacao-btn-atualizar:hover svg {
      transform: rotate(180deg);
    }

    .notificacao-btn-fechar {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 28px;
      height: 28px;
      background: transparent;
      color: #94a3b8;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      flex-shrink: 0;
      animation: notificacaoButtonEntrance 0.5s ease-out 0.5s both;
    }

    .notificacao-btn-fechar:hover {
      background: #f1f5f9;
      color: #64748b;
      transform: rotate(90deg) scale(1.1);
    }

    .notificacao-progresso {
      position: absolute;
      bottom: 0;
      left: 0;
      height: 3px;
      background: linear-gradient(90deg, #3b82f6 0%, #60a5fa 50%, #3b82f6 100%);
      background-size: 200% 100%;
      width: 100%;
      transform-origin: left;
      animation: notificacaoProgresso 15s linear forwards, notificacaoProgressoShimmer 2s linear infinite;
    }

    @keyframes notificacaoProgresso {
      from {
        transform: scaleX(1);
      }

      to {
        transform: scaleX(0);
      }
    }

    @keyframes notificacaoProgressoShimmer {
      0% {
        background-position: 0% 50%;
      }

      100% {
        background-position: 200% 50%;
      }
    }

    /* Responsivo */
    @media (max-width: 640px) {
      .notificacao-nova-elegante {
        width: calc(100vw - 32px);
        right: 16px;
        top: 16px;
      }

      .notificacao-conteudo {
        padding: 0;
      }
    }

    .checkbox-label {
      cursor: pointer;
      user-select: none;
      transition: color 0.2s ease;
      font-size: 0.875rem;
    }

    .checkbox-container:hover .checkbox-label {
      color: #1e40af;
    }

    /* Painel avançado colapsável */
    .advanced-panel {
      max-height: 0;
      overflow: hidden;
      transition: max-height 0.4s cubic-bezier(0.4, 0, 0.2, 1), opacity 0.3s ease;
      opacity: 0;
    }

    .advanced-panel.open {
      max-height: 2000px;
      opacity: 1;
      overflow: visible !important;
    }

    .filter-section.show {
      animation: slideDown 0.3s ease-out;
    }

    @keyframes slideDown {
      from {
        opacity: 0;
        transform: translateY(-10px);
      }

      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    .toggle-icon {
      transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }

    .toggle-icon.open {
      transform: rotate(180deg);
    }

    .checkbox-container {
      transition: all 0.2s ease;
    }

    .checkbox-container:hover {
      background-color: #f8fafc;
      transform: translateY(-1px);
    }

    /* Cards de filtros clicáveis */
    .filter-card {
      cursor: pointer;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      position: relative;
      overflow: hidden;
      height: 56px;
      min-height: 56px;
      padding: 0.75rem !important;
      display: flex;
      align-items: center;
    }

    .autocomplete-wrapper {
      position: relative;
    }

    .autocomplete-list {
      position: absolute;
      top: 100%;
      left: 0;
      right: 0;
      background: rgba(255, 255, 255, 0.98);
      border: 1px solid rgba(148, 163, 184, 0.55);
      border-radius: 1rem;
      max-height: 250px;
      overflow-y: auto;
      z-index: 1000;
      box-shadow:
        0 22px 55px rgba(15, 23, 42, 0.18),
        0 10px 22px rgba(15, 23, 42, 0.10);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      display: none;
    }

    .autocomplete-list.show {
      display: block;
    }

    .autocomplete-item {
      padding: 12px 14px;
      cursor: pointer;
      border-bottom: 1px solid #f3f4f6;
      display: flex;
      align-items: flex-start;
      gap: 10px;
      transition: all 0.2s ease;
    }

    .autocomplete-item:first-child {
      border-top-left-radius: 1rem;
      border-top-right-radius: 1rem;
    }

    .autocomplete-item:last-child {
      border-bottom-left-radius: 1rem;
      border-bottom-right-radius: 1rem;
    }

    .autocomplete-item:last-child {
      border-bottom: none;
    }

    .autocomplete-item:hover,
    .autocomplete-item.active {
      background-color: #eff6ff;
    }

    .autocomplete-badge {
      display: inline-block;
      padding: 3px 10px;
      border-radius: 6px;
      font-size: 11px;
      font-weight: 600;
      flex-shrink: 0;
      letter-spacing: 0.5px;
    }

    .autocomplete-badge.cmei {
      background-color: #dbeafe;
      color: #1e40af;
    }

    .autocomplete-badge.emef {
      background-color: #d1fae5;
      color: #065f46;
    }

    .autocomplete-nome {
      font-size: 14px;
      color: #374151;
    }

    .no-results {
      padding: 20px;
      text-align: center;
      color: #6b7280;
      font-size: 14px;
    }

    .autocomplete-list::-webkit-scrollbar {
      width: 6px;
    }

    .autocomplete-list::-webkit-scrollbar-track {
      background: #f3f4f6;
    }

    .autocomplete-list::-webkit-scrollbar-thumb {
      background: #d1d5db;
      border-radius: 3px;
    }

    .autocomplete-list::-webkit-scrollbar-thumb:hover {
      background: #9ca3af;
    }

    #filterEscolaSearch.autocomplete-open {
      border-bottom-left-radius: 0 !important;
      border-bottom-right-radius: 0 !important;
    }

    .selected-tags {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      padding: 10px;
      border: 1px solid #e5e7eb;
      border-radius: 12px;
      background: #f9fafb;
      min-height: 44px;
    }

    .selected-tag {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 6px 10px;
      border-radius: 9999px;
      background: #ffffff;
      border: 1px solid #e5e7eb;
      box-shadow: 0 1px 2px rgba(0, 0, 0, 0.04);
      font-size: 12px;
      color: #374151;
      max-width: 100%;
    }

    .deficiency-tag-badge {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 28px;
      height: 22px;
      border-radius: 8px;
      font-size: 11px;
      font-weight: 800;
      letter-spacing: 0.02em;
      flex-shrink: 0;
      box-shadow: 0 4px 10px rgba(15, 23, 42, 0.12);
    }

    @keyframes deficiencyBadgePop {
      0% {
        transform: scale(0.85) translateY(2px);
        opacity: 0.65;
      }

      55% {
        transform: scale(1.12) translateY(-1px);
        opacity: 1;
      }

      100% {
        transform: scale(1) translateY(0);
        opacity: 1;
      }
    }

    @keyframes deficiencyBadgeOut {
      0% {
        transform: scale(1) translateY(0);
        opacity: 1;
      }

      100% {
        transform: scale(0.78) translateY(2px);
        opacity: 0;
      }
    }

    .deficiency-tag-badge.badge-pop {
      animation: deficiencyBadgePop 220ms cubic-bezier(0.16, 1, 0.3, 1);
      will-change: transform, opacity;
    }

    .deficiency-tag-badge.badge-out {
      animation: deficiencyBadgeOut 180ms ease-in forwards;
      will-change: transform, opacity;
    }

    /* Dropdown do autocomplete por cima + animação */
    .autocomplete-list {
      z-index: 9999;
      will-change: transform, opacity;
      transform-origin: top;
    }

    .autocomplete-list.show {
      display: block;
      animation: autocompleteIn 160ms ease-out;
    }

    .autocomplete-list.hide {
      display: block;
      animation: autocompleteOut 140ms ease-in forwards;
    }

    @keyframes autocompleteIn {
      from {
        opacity: 0;
        transform: translateY(-6px) scale(0.985);
      }

      to {
        opacity: 1;
        transform: translateY(0) scale(1);
      }
    }

    @keyframes autocompleteOut {
      from {
        opacity: 1;
        transform: translateY(0) scale(1);
      }

      to {
        opacity: 0;
        transform: translateY(-6px) scale(0.985);
      }
    }

    .selected-tag-label {
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      max-width: 52ch;
    }

    .selected-tag-remove {
      width: 20px;
      height: 20px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      border-radius: 9999px;
      border: 1px solid #e5e7eb;
      background: #f3f4f6;
      color: #6b7280;
      line-height: 1;
      cursor: pointer;
      flex-shrink: 0;
    }

    .selected-tag-remove:hover {
      background: #e5e7eb;
      color: #374151;
    }

    .filter-card-title {
      display: block;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      max-width: 10.5rem;
      transition: none !important;
      transform: none !important;
      pointer-events: none;
    }

    .filter-card-icon {
      transition: none;
      transform: none !important;
      pointer-events: none;
    }

    .filter-card::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(59, 130, 246, 0.1), transparent);
      transition: left 0.5s ease;
    }

    .filter-card:hover::before {
      left: 100%;
    }

    .filter-card:hover {
      transform: translateY(-2px);
      border-color: #3b82f6;
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(37, 99, 235, 0.2);
    }

    .filter-card-icon {
      transition: none;
      transform: none !important;
      pointer-events: none;
    }

    .filter-card.active {
      border-color: #2563eb;
      background: linear-gradient(135deg, #eff6ff 0%, #dbeafe 100%);
      box-shadow: 0 4px 12px rgba(37, 99, 235, 0.2);
    }

    /* Mesma linguagem visual dos cards aplicada aos novos grupos (<details>) */
    details.filter-group {
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      position: relative;
      border-width: 2px;
      border-style: solid;
      border-color: #e5e7eb;
      overflow: visible;
    }

    details.filter-group>summary {
      position: relative;
      overflow: hidden;
      min-height: 56px;
      border-radius: 0.75rem;
    }

    details.filter-group>summary::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(59, 130, 246, 0.1), transparent);
      transition: left 0.5s ease;
      pointer-events: none;
      border-radius: 0.75rem;
    }

    details.filter-group>summary:hover::before {
      left: 100%;
    }

    details.filter-group:has(> summary:hover) {
      border-color: #3b82f6;
      background: #ffffff;
      box-shadow: 0 4px 12px rgba(37, 99, 235, 0.2), 0 0 0 3px rgba(59, 130, 246, 0.12);
    }

    details.filter-group[data-expanded="true"] {
      border-color: #2563eb;
      background: #ffffff;
      box-shadow: 0 4px 12px rgba(37, 99, 235, 0.2);
    }

    details.filter-group[data-expanded="true"]>summary {
      background: linear-gradient(135deg, #eff6ff 0%, #dbeafe 100%);
    }

    /* Layout dos grupos lado a lado (como os cards do backup) */
    .filters-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(170px, 1fr));
      gap: 1rem;
      align-items: start;
    }

    /* No modo "painel", o conteúdo do group não aparece na faixa (apenas no advancedPanel) */
    details.filter-group[data-mode="panel"]>.filter-group-content {
      display: none;
    }

    /* Indicativo de filtro aberto/ativo (igual card ativo) */
    details.filter-group.is-active {
      border-color: #2563eb;
      background: #ffffff;
      box-shadow: 0 4px 12px rgba(37, 99, 235, 0.2), 0 0 0 3px rgba(37, 99, 235, 0.12);
    }

    /* Painel abaixo (mesma lógica do backup) */
    #advancedPanelContent .filter-group-content {
      display: block;
    }

    /* A faixa de filtros deve ficar sempre clicável por cima do painel */
    .filters-grid {
      position: relative;
      z-index: 20;
    }

    #advancedPanel {
      position: relative;
      z-index: 10;
    }

    /* Conteúdo do painel com transição suave e relaxada */
    #advancedPanelContent {
      transition: opacity 450ms cubic-bezier(0.4, 0, 0.2, 1),
        transform 500ms cubic-bezier(0.4, 0, 0.2, 1);
      opacity: 1;
      transform: translateY(0) scale(1);
    }

    /* Animação RÁPIDA para troca entre filtros */
    #advancedPanelContent.is-leaving {
      opacity: 0;
      transform: translateY(-8px) scale(0.98);
      /* Animação de saída RÁPIDA para troca entre filtros */
      transition: opacity 200ms cubic-bezier(0.4, 0, 1, 1),
        transform 200ms cubic-bezier(0.4, 0, 1, 1);
    }

    /* Animação LENTA para fechamento do menu */
    #advancedPanelContent.is-leaving-slow {
      opacity: 0;
      transform: translateY(-10px) scale(0.97);
      /* Animação de saída LENTA e suave para fechamento */
      transition: opacity 400ms cubic-bezier(0.4, 0, 0.6, 1),
        transform 400ms cubic-bezier(0.4, 0, 0.6, 1);
    }

    #advancedPanelContent.is-entering {
      opacity: 0;
      transform: translateY(10px) scale(0.97);
      /* Animação de entrada rápida para não atrasar */
      transition: opacity 300ms cubic-bezier(0.16, 1, 0.3, 1),
        transform 350ms cubic-bezier(0.16, 1, 0.3, 1);
    }

    /* Remove o chevron (seta) dos cards no modo painel */
    details.filter-group[data-mode="panel"] .filter-group-chevron {
      display: none !important;
    }

    /* Badge como sobreposição no card (canto superior direito) */
    details.filter-group[data-mode="panel"]>summary .filter-card-badge {
      position: absolute !important;
      top: 8px !important;
      right: 10px !important;
      z-index: 50 !important;
      pointer-events: none !important;
      display: none;
      align-items: center;
      justify-content: center;
      height: 18px !important;
      line-height: 18px !important;
      min-width: 18px !important;
      padding: 0 !important;
      border-radius: 9999px !important;
      font-size: 11px !important;
      font-weight: 600 !important;
      background: #2563eb !important;
      color: #ffffff !important;
      margin: 0 !important;
      border: 2px solid #ffffff !important;
      box-shadow: 0 6px 16px rgba(0, 0, 0, 0.12) !important;
      text-align: center;
      white-space: nowrap;
    }

    /* Contraste/organização entre categorias dentro do painel */
    #advancedPanelContent .filter-group-content>.px-4 {
      display: flex;
      flex-direction: column;
      gap: 14px;
    }

    #advancedPanelContent .filter-group-content>.px-4>div {
      padding: 12px 12px;
      border: 1px solid #e5e7eb;
      border-radius: 12px;
      background: #ffffff;
    }

    #advancedPanelContent .filter-group-content>.px-4>div>h4 {
      margin-bottom: 10px !important;
    }

    /* O painel abaixo é quem expande; a faixa de filtros não deve "estourar" o grid */
    details.filter-group[data-expanded="true"] {
      grid-column: auto;
    }

    .badge-count {
      animation: badgePop 0.3s cubic-bezier(0.68, -0.55, 0.265, 1.55);
      margin-left: 0.75rem;
      /* Espaçamento entre o texto e o badge */
    }

    @keyframes badgePop {
      0% {
        transform: scale(0);
      }

      50% {
        transform: scale(1.2);
      }

      100% {
        transform: scale(1);
      }
    }

    /* Grupos de Encaminhamento */
    .encaminhamento-group {
      border: 2px solid #e5e7eb;
      border-radius: 0.75rem;
      overflow: hidden;
      transition: all 0.3s ease;
      background: white;
    }

    .encaminhamento-group:hover {
      border-color: #3b82f6;
      box-shadow: 0 4px 12px rgba(59, 130, 246, 0.15);
    }

    .group-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 0.875rem 1rem;
      background: linear-gradient(135deg, #f8fafc 0%, #f1f5f9 100%);
      cursor: pointer;
      transition: all 0.2s ease;
      border-bottom: 1px solid #e5e7eb;
    }

    .group-header:hover {
      background: linear-gradient(135deg, #eff6ff 0%, #dbeafe 100%);
    }

    .group-header-left {
      display: flex;
      align-items: center;
      gap: 0.75rem;
      flex: 1;
    }

    .group-checkbox-wrapper {
      display: flex;
      align-items: center;
    }

    .group-checkbox-wrapper input[type="checkbox"] {
      width: 18px;
      height: 18px;
      cursor: pointer;
    }

    .group-title {
      font-weight: 600;
      color: #1f2937;
      font-size: 0.9375rem;
    }

    .group-badge {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      min-width: 1.5rem;
      height: 1.5rem;
      padding: 0 0.5rem;
      background: #3b82f6;
      color: white;
      border-radius: 9999px;
      font-size: 0.75rem;
      font-weight: 700;
    }

    .group-badge.hidden {
      display: none;
    }

    .toggle-icon {
      width: 1.25rem;
      height: 1.25rem;
      transition: transform 0.3s ease;
      color: #6b7280;
    }

    .toggle-icon.rotated {
      transform: rotate(180deg);
    }

    .group-body {
      max-height: 0;
      overflow: hidden;
      transition: max-height 0.3s ease;
      background: white;
    }

    .group-body.expanded {
      max-height: 1000px;
    }

    .group-body-content {
      padding: 1rem;
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
      gap: 0.5rem;
    }

    .encaminhamento-group.outros-detectados {
      border-style: dashed;
      border-color: #f59e0b;
      background: #fffbeb;
    }

    .encaminhamento-group.outros-detectados .group-header {
      background: linear-gradient(135deg, #fef3c7 0%, #fde68a 100%);
    }

    /* Menu Hamburguer Responsivo */
    /* Desktop: Mostra menu horizontal, esconde hamburguer */
    .mobile-menu-button {
      display: none !important;
    }

    .desktop-menu {
      display: flex;
    }

    .mobile-menu {
      display: none;
    }

    /* Alerta inline para novas notificações */
    .alerta-novas-notificacoes {
      display: none;
      align-items: center;
      gap: 10px;
      padding: 12px 16px;
      border-radius: 14px;
      border: 1px solid #fecaca;
      background: linear-gradient(90deg, #fff1f2, #ffe4e6);
      color: #b91c1c;
      box-shadow: 0 8px 20px rgba(248, 113, 113, 0.15);
      opacity: 0;
      transform: translateY(-20px);
    }

    .alerta-novas-notificacoes.show {
      display: flex;
      animation: alertaEntrance 0.4s cubic-bezier(0.34, 1.56, 0.64, 1) forwards;
    }

    .alerta-novas-notificacoes.hide {
      animation: alertaExit 0.4s cubic-bezier(0.34, 1.56, 0.64, 1) forwards;
    }

    @keyframes alertaEntrance {
      from {
        opacity: 0;
        transform: translateY(-20px);
      }

      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    @keyframes alertaExit {
      from {
        opacity: 1;
        transform: translateY(0);
      }

      to {
        opacity: 0;
        transform: translateY(-20px);
      }
    }

    /* Animação de shake para o contador quando é incrementado */
    @keyframes shakeCounter {

      0%,
      100% {
        transform: translateX(0);
      }

      10%,
      30%,
      50%,
      70%,
      90% {
        transform: translateX(-4px);
      }

      20%,
      40%,
      60%,
      80% {
        transform: translateX(4px);
      }
    }

    .alerta-novas-notificacoes .contador-shake {
      animation: shakeCounter 0.5s ease-in-out;
      display: inline-block;
    }

    /* Esconder botão CTA */
    .alerta-novas-notificacoes .cta {
      display: none;
    }

    .alerta-novas-notificacoes .cta:hover {
      display: none;
    }

    /* Animação de pulsar unificada (reutilizável) */
    @keyframes pulse {
      0% {
        transform: scale(1);
        box-shadow: 0 0 0 0 rgba(37, 99, 235, 0.7);
      }

      50% {
        transform: scale(1.02);
        box-shadow: 0 0 0 10px rgba(37, 99, 235, 0);
      }

      100% {
        transform: scale(1);
        box-shadow: 0 0 0 0 rgba(37, 99, 235, 0);
      }
    }

    @keyframes spin {
      from {
        transform: rotate(0deg);
      }

      to {
        transform: rotate(360deg);
      }
    }

    /* Classe genérica para pulsar (sem ID específico) */
    .btn-pulse-active {
      animation: pulse 2s infinite !important;
      transition: none !important;
    }

    .alerta-novas-notificacoes .close-btn {
      background: transparent;
      color: #b91c1c;
      padding: 6px;
      border-radius: 8px;
      transition: background 0.15s ease;
    }

    .alerta-novas-notificacoes .close-btn:hover {
      background: rgba(185, 28, 28, 0.08);
    }

    /* Bloqueio quando toast está ativo */
    .alerta-novas-notificacoes.toast-blocking {
      pointer-events: none;
      opacity: 0.5;
    }

    /* Apenas Celulares e Tablets: Esconde menu horizontal, mostra hamburguer */

    @media (max-width: 768px) {
      .mobile-menu-button {
        display: flex !important;
      }

      .desktop-menu {
        display: none !important;
      }

      .mobile-menu {
        display: block !important;
        max-height: 0;
        overflow: hidden;
        transition: max-height 0.3s ease-in-out;
      }

      .mobile-menu.show {
        max-height: 500px;
      }
    }

    /* Melhorias de toque para mobile */
    @media (hover: none) and (pointer: coarse) {

      button,
      a {
        min-height: 44px;
      }
    }

    /* ========================================
       DRAWER DE DETALHES
       ======================================== */
    /* ========================================
       MODAL DE DETALHES - SIMPLES
       ======================================== */
    .modal-detalhes {
      display: none;
      position: fixed;
      z-index: 10000;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0);
      backdrop-filter: blur(0px);
      transition: all 0.3s ease;
      overflow-y: auto;
    }

    .modal-detalhes.visible {
      display: flex !important;
      align-items: center !important;
      justify-content: center !important;
      padding: 20px !important;
      background-color: rgba(0, 0, 0, 0.6);
      backdrop-filter: blur(4px);
    }

    .modal-detalhes-conteudo {
      background: rgba(255, 255, 255, 0.95);
      backdrop-filter: blur(12px);
      padding: 0;
      border-radius: 16px;
      box-shadow: 0 25px 50px rgba(0, 0, 0, 0.3);
      width: 100%;
      max-width: 1152px;
      max-height: 95vh;
      margin: auto;
      overflow: hidden;
      display: flex;
      flex-direction: column;
      animation: modalFadeIn 0.3s ease;
      position: relative;
      border: 1px solid rgba(255, 255, 255, 0.6);
    }

    @keyframes modalFadeIn {
      from {
        opacity: 0;
        transform: scale(0.95);
      }

      to {
        opacity: 1;
        transform: scale(1);
      }
    }

    .modal-detalhes-header {
      flex-shrink: 0;
    }

    .modal-detalhes-titulo {
      margin: 0;
    }

    .modal-detalhes-subtitulo {
      margin: 0;
    }

    .modal-detalhes-close {
      cursor: pointer;
    }

    .modal-detalhes-body {
      flex: 1;
      overflow-y: auto;
      padding: 0;
      background: transparent;
    }

    .modal-detalhes-body::-webkit-scrollbar {
      width: 8px;
    }

    .modal-detalhes-body::-webkit-scrollbar-track {
      background: #f1f1f1;
    }

    .modal-detalhes-body::-webkit-scrollbar-thumb {
      background: linear-gradient(180deg, #8b5cf6 0%, #7c3aed 100%);
      border-radius: 10px;
    }

    .modal-detalhes-body::-webkit-scrollbar-thumb:hover {
      background: linear-gradient(180deg, #7c3aed 0%, #6d28d9 100%);
    }

    .modal-detalhes-section,
    .modal-detalhes-section-title,
    .modal-detalhes-row,
    .modal-detalhes-label,
    .modal-detalhes-value,
    .modal-detalhes-value.empty {
      all: unset;
    }

    /* Botão na tabela */
    .btn-ver-detalhes {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 36px;
      height: 36px;
      background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%);
      color: white;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.3s ease;
      box-shadow: 0 2px 8px rgba(59, 130, 246, 0.3);
      flex-shrink: 0;
    }

    .btn-ver-detalhes:hover {
      background: linear-gradient(135deg, #2563eb 0%, #1d4ed8 100%);
      transform: scale(1.1);
      box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
    }

    .btn-ver-detalhes svg {
      width: 18px;
      height: 18px;
    }

    body.modal-open {
      overflow: hidden !important;
      touch-action: none;
    }

    .select-shell {
      position: relative;
      width: 100%;
    }

    .select-native {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      opacity: 0;
      pointer-events: none;
    }

    .select-trigger {
      display: flex;
      align-items: center;
      justify-content: space-between;
      width: 100%;
      border: 1px solid #d1d5db;
      border-radius: 0.85rem;
      background: linear-gradient(180deg, #ffffff 0%, #fbfdff 100%);
      padding: 0.65rem 0.85rem;
      font-size: 0.875rem;
      line-height: 1.25rem;
      color: #111827;
      transition: box-shadow 220ms cubic-bezier(0.2, 0.8, 0.2, 1),
        border-color 220ms cubic-bezier(0.2, 0.8, 0.2, 1),
        transform 220ms cubic-bezier(0.2, 0.8, 0.2, 1),
        background-color 220ms cubic-bezier(0.2, 0.8, 0.2, 1);
      box-shadow: 0 1px 0 rgba(17, 24, 39, 0.02);
    }

    .select-trigger:hover {
      border-color: #93c5fd;
      background: linear-gradient(180deg, #ffffff 0%, #f3f8ff 100%);
      transform: translateY(-1px);
      box-shadow: 0 10px 24px rgba(15, 23, 42, 0.06);
    }

    .select-trigger:focus {
      outline: none;
    }

    .select-trigger:focus-visible {
      border-color: #3b82f6;
      box-shadow: 0 0 0 4px rgba(59, 130, 246, 0.18), 0 12px 26px rgba(15, 23, 42, 0.08);
      transform: translateY(-1px);
    }

    .select-trigger-icon {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 1.85rem;
      height: 1.85rem;
      border-radius: 0.7rem;
      color: #64748b;
      background: rgba(148, 163, 184, 0.12);
      transition: transform 220ms cubic-bezier(0.2, 0.8, 0.2, 1),
        background-color 220ms cubic-bezier(0.2, 0.8, 0.2, 1),
        color 220ms cubic-bezier(0.2, 0.8, 0.2, 1);
      flex-shrink: 0;
      margin-left: 0.75rem;
    }

    .select-shell[data-open="true"] .select-trigger-icon {
      transform: rotate(180deg);
      background: rgba(59, 130, 246, 0.14);
      color: #2563eb;
    }

    .select-menu {
      position: absolute;
      z-index: 9999;
      top: 0;
      left: 0;
      width: 280px;
      background: #ffffff;
      border: 1px solid rgba(148, 163, 184, 0.55);
      border-radius: 1rem;
      box-shadow: 0 18px 45px rgba(15, 23, 42, 0.14);
      padding: 0.4rem;
      max-height: 240px;
      overflow: auto;
      transform-origin: top;
      opacity: 0;
      transform: translateY(-6px) scale(0.985);
      pointer-events: none;
      visibility: hidden;
      transition: opacity 140ms ease, transform 180ms cubic-bezier(0.16, 1, 0.3, 1);
    }

    .select-menu.open {
      opacity: 1;
      transform: translateY(0) scale(1);
      pointer-events: auto;
      visibility: visible;
    }

    .select-menu.closing {
      visibility: visible;
      pointer-events: none;
    }

    /* Complementares: padronização visual (apenas dentro dos grupos colapsáveis) */
    .filter-group-content label {
      font-size: 0.875rem;
      line-height: 1.2;
      margin-bottom: 6px !important;
    }

    .filter-group-content label span.flex-1 {
      display: -webkit-box;
      -webkit-box-orient: vertical;
      -webkit-line-clamp: 2;
      line-clamp: 2;
      overflow: hidden;
    }

    .filter-group-content .grid {
      align-items: stretch;
    }

    .filter-group-content .grid>div:not(.hidden) {
      display: flex;
      flex-direction: column;
      justify-content: flex-start;
      min-height: 112px;
    }

    .filter-group-content .select-trigger {
      padding: 0.52rem 0.75rem;
      border-radius: 0.75rem;
    }

    .filter-group-content .select-trigger-icon {
      width: 1.65rem;
      height: 1.65rem;
      border-radius: 0.65rem;
      margin-left: 0.6rem;
    }

    .filter-badge {
      display: inline-flex;
      align-items: center;
      height: 18px;
      padding: 0 8px;
      border-radius: 9999px;
      font-size: 10px;
      font-weight: 700;
      line-height: 1;
      letter-spacing: 0.02em;
      color: #334155;
      background: #f1f5f9;
      border: 1px solid #e2e8f0;
      user-select: none;
      white-space: nowrap;
    }

    /* Animação do filtro condicional (parece "sair" do pai) */
    #filterOcorreuEscolaContainer {
      overflow: visible;
      transform-origin: top;
      will-change: height, opacity, transform;
    }

    #filterOcorreuEscolaContainer.is-animating {
      overflow: hidden;
      pointer-events: none;
    }

    .select-option {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      width: 100%;
      padding: 0.6rem 0.75rem;
      border-radius: 0.8rem;
      font-size: 0.875rem;
      line-height: 1.25rem;
      color: #0f172a;
      cursor: pointer;
      user-select: none;
      transition: background-color 160ms ease, transform 160ms ease;
    }

    .select-option:hover {
      background-color: rgba(59, 130, 246, 0.10);
      transform: translateY(-1px);
    }

    .select-option[aria-selected="true"] {
      background-color: rgba(37, 99, 235, 0.14);
      color: #1d4ed8;
      font-weight: 700;
    }

    .tooltip-trigger {
      position: relative;
      display: inline-flex;
      align-items: center;
    }

    .tooltip-trigger:focus {
      outline: none;
    }

    .tooltip-popover {
      display: none;
      z-index: 50000;
    }

    .tooltip-trigger:hover .tooltip-popover,
    .tooltip-trigger:focus-within .tooltip-popover {
      display: block;
    }

    .filter-group,
    .filter-group-content {
      overflow: visible;
    }

    #filtersSection {
      position: relative;
      overflow: visible;
    }

    /* Garante que o painel avançado não corte dropdowns */
    #advancedPanel,
    #advancedPanel>div,
    #advancedPanelContent,
    #advancedPanelContent .filter-group-content,
    #advancedPanelContent .filter-group-content>div,
    #advancedPanelContent .px-4 {
      overflow: visible !important;
    }

    /* Garante que cards e containers de filtros não cortem dropdowns */
    .child-filter-card-body,
    .child-filters-grid,
    .conditional-indent {
      overflow: visible !important;
    }

    #selectOverlay {
      position: absolute;
      inset: 0;
      z-index: 9999;
      pointer-events: none;
    }

    @media (max-width: 768px) {
      .modal-detalhes-conteudo {
        width: 100%;
        max-height: 95vh;
        margin: auto;
      }

      .modal-detalhes-header {
        padding: 0;
      }

      .modal-detalhes-titulo {
        font-size: inherit;
      }

      .modal-detalhes-body {
        padding: 0;
      }
    }

    /* ============================================
       CHECKBOX COMPACTO E RESPONSIVO
       ============================================ */

    .checkbox-container {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      padding: 0.5rem 0.75rem;
      /* Compacto: 8px vertical */
      background: white;
      border: 1.5px solid #e5e7eb;
      border-radius: 0.5rem;
      transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
      cursor: pointer;
      min-height: auto;
    }

    .checkbox-container:hover {
      background-color: #f8fafc;
      border-color: #cbd5e1;
      transform: translateY(-1px);
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
    }

    /* Estado selecionado: ÓBVIO em 1 segundo */
    .checkbox-container:has(.custom-checkbox:checked) {
      background: linear-gradient(135deg, #eff6ff 0%, #dbeafe 100%);
      border-color: #3b82f6;
      border-width: 2px;
      box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
    }

    .checkbox-container:has(.custom-checkbox:checked) .checkbox-label {
      color: #1e40af;
      font-weight: 600;
    }

    /* Estado desabilitado */
    .checkbox-container:has(.custom-checkbox:disabled) {
      opacity: 0.5;
      cursor: not-allowed;
      background: #f9fafb;
    }

    .checkbox-label {
      flex: 1;
      font-size: 0.875rem;
      line-height: 1.25rem;
      /* 1 linha */
      color: #374151;
      cursor: pointer;
      user-select: none;
    }

    /* ============================================
       GRIDS RESPONSIVOS POR TIPO
       ============================================ */

    .child-filter-card {
      background: #ffffff;
      border: 1px solid #e5e7eb;
      border-radius: 16px;
      box-shadow: 0 6px 18px rgba(15, 23, 42, 0.08);
      overflow: hidden;
    }

    /* Permite que dropdowns/overlays (autocomplete) renderizem acima do card quando necessário */
    .child-filter-card.has-flyout {
      overflow: visible !important;
    }

    .child-filter-card-header {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 14px 16px;
      border-bottom: 1px solid #f1f5f9;
    }

    .child-filter-card-icon {
      width: 34px;
      height: 34px;
      border-radius: 9999px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      background: #ede9fe;
      color: #6d28d9;
      font-size: 16px;
      flex: none;
    }

    .child-filter-card-title {
      font-size: 14px;
      font-weight: 700;
      color: #374151;
      letter-spacing: 0.02em;
    }

    .child-filter-card-body {
      padding: 14px 16px 16px;
    }

    .child-filters-grid {
      display: grid;
      grid-template-columns: 1fr;
      gap: 14px;
    }

    .child-filters-subgrid {
      display: grid;
      grid-template-columns: 1fr;
      gap: 14px;
    }

    @media (min-width: 768px) {
      .child-filters-subgrid {
        grid-template-columns: 1fr 1fr;
      }
    }

    .child-age-grid {
      display: grid;
      grid-template-columns: 1fr;
      gap: 12px;
    }

    @media (min-width: 768px) {
      .child-age-grid {
        grid-template-columns: 1fr 1fr;
      }
    }

    /* Inputs de idade no mesmo padrão visual do select-elegant */
    .child-age-input {
      width: 100%;
      height: 44px;
      padding: 0.625rem 0.875rem;
      border: 1px solid #e5e7eb;
      border-radius: 0.75rem;
      background: #ffffff;
      color: #111827;
      font-size: 0.95rem;
      line-height: 1.25rem;
      transition: box-shadow 0.2s ease, border-color 0.2s ease;
      outline: none;
    }

    .child-age-input::placeholder {
      color: #9ca3af;
    }

    .child-age-input:focus {
      border-color: #3b82f6;
      box-shadow: 0 0 0 4px rgba(59, 130, 246, 0.18);
    }

    /* Gênero: SEMPRE 2 colunas */
    #filterGeneroContainer {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 0.5rem 0.75rem;
      /* gap-y < gap-x */
    }

    /* Raça: 2 → 3 → 4 colunas */
    #filterRacaContainer {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 0.5rem 0.75rem;
    }

    @media (min-width: 768px) {
      #filterRacaContainer {
        grid-template-columns: repeat(3, 1fr);
      }
    }

    @media (min-width: 1024px) {
      #filterRacaContainer {
        grid-template-columns: repeat(4, 1fr);
      }
    }

    /* Orientação: 2 → 3 → 4 → 5 colunas */
    #filterOrientacaoContainer {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 0.5rem 0.75rem;
    }

    @media (min-width: 768px) {
      #filterOrientacaoContainer {
        grid-template-columns: repeat(3, 1fr);
      }
    }

    @media (min-width: 1024px) {
      #filterOrientacaoContainer {
        grid-template-columns: repeat(4, 1fr);
      }
    }

    @media (min-width: 1280px) {
      #filterOrientacaoContainer {
        grid-template-columns: repeat(5, 1fr);
      }
    }

    /* ============================================
       CARDS DE TIPO DE VIOLÊNCIA - REDESIGN
       Sistema escalável para 1-9+ tipos
       ============================================ */

    /* Container principal com grid auto-responsivo */
    #filterTipoViolenciaContainer {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
      gap: 0.75rem;
      padding: 0.5rem 0;
    }

    /* Ajustes responsivos para melhor distribuição */
    @media (min-width: 640px) {
      #filterTipoViolenciaContainer {
        grid-template-columns: repeat(auto-fill, minmax(160px, 1fr));
        gap: 0.875rem;
      }
    }

    @media (min-width: 1024px) {
      #filterTipoViolenciaContainer {
        grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
        gap: 1rem;
      }
    }

    /* Card individual de tipo de violência */
    .violence-type-card {
      position: relative;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 1rem 0.75rem;
      min-height: 100px;
      background: linear-gradient(145deg, #ffffff 0%, #f8fafc 100%);
      border: 2px solid #e2e8f0;
      border-radius: 12px;
      cursor: pointer;
      transition: all 0.25s cubic-bezier(0.4, 0, 0.2, 1);
      text-align: center;
      overflow: hidden;
    }

    .violence-type-card::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 4px;
      background: linear-gradient(90deg, var(--card-accent, #94a3b8) 0%, var(--card-accent-light, #cbd5e1) 100%);
      opacity: 0.6;
      transition: opacity 0.25s ease;
    }

    .violence-type-card:hover {
      border-color: #94a3b8;
      transform: translateY(-2px);
      box-shadow: 0 8px 20px rgba(15, 23, 42, 0.08), 0 4px 8px rgba(15, 23, 42, 0.04);
    }

    .violence-type-card:hover::before {
      opacity: 1;
    }

    /* Estado selecionado */
    .violence-type-card.selected {
      background: linear-gradient(145deg, #eff6ff 0%, #dbeafe 100%);
      border-color: #3b82f6;
      border-width: 2.5px;
      box-shadow: 0 0 0 4px rgba(59, 130, 246, 0.12), 0 8px 20px rgba(59, 130, 246, 0.15);
    }

    .violence-type-card.selected::before {
      background: linear-gradient(90deg, #3b82f6 0%, #60a5fa 100%);
      opacity: 1;
      height: 5px;
    }

    .violence-type-card.selected .violence-type-icon {
      transform: scale(1.1);
      filter: drop-shadow(0 2px 4px rgba(59, 130, 246, 0.3));
    }

    .violence-type-card.selected .violence-type-label {
      color: #1e40af;
      font-weight: 700;
    }

    .violence-type-card.selected .violence-type-check {
      opacity: 1;
      transform: scale(1);
    }

    /* Ícone do tipo */
    .violence-type-icon {
      font-size: 1.75rem;
      margin-bottom: 0.5rem;
      transition: transform 0.25s ease, filter 0.25s ease;
      line-height: 1;
    }

    /* Label do tipo */
    .violence-type-label {
      font-size: 0.8rem;
      font-weight: 600;
      color: #475569;
      line-height: 1.3;
      max-width: 100%;
      word-wrap: break-word;
      transition: color 0.2s ease, font-weight 0.2s ease;
    }

    /* Check mark no canto */
    .violence-type-check {
      position: absolute;
      top: 8px;
      right: 8px;
      width: 22px;
      height: 22px;
      background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%);
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      color: white;
      font-size: 12px;
      font-weight: bold;
      opacity: 0;
      transform: scale(0.5);
      transition: all 0.25s cubic-bezier(0.68, -0.55, 0.265, 1.55);
      box-shadow: 0 2px 6px rgba(37, 99, 235, 0.4);
    }

    /* Contador de registros no card */
    .violence-type-count {
      position: absolute;
      bottom: 6px;
      right: 8px;
      font-size: 0.65rem;
      color: #94a3b8;
      font-weight: 500;
      opacity: 0.8;
      transition: color 0.2s ease;
    }

    .violence-type-card.selected .violence-type-count {
      color: #3b82f6;
      opacity: 1;
    }

    /* Input checkbox oculto mas funcional */
    .violence-type-card input[type="checkbox"] {
      position: absolute;
      opacity: 0;
      width: 100%;
      height: 100%;
      top: 0;
      left: 0;
      cursor: pointer;
      z-index: 2;
    }

    /* Cores de destaque por tipo (customizável via data-type) */
    .violence-type-card[data-type="fisica"] {
      --card-accent: #ef4444;
      --card-accent-light: #fca5a5;
    }

    .violence-type-card[data-type="psicologica"] {
      --card-accent: #8b5cf6;
      --card-accent-light: #c4b5fd;
    }

    .violence-type-card[data-type="sexual"] {
      --card-accent: #ec4899;
      --card-accent-light: #f9a8d4;
    }

    .violence-type-card[data-type="negligencia"] {
      --card-accent: #f97316;
      --card-accent-light: #fdba74;
    }

    .violence-type-card[data-type="institucional"] {
      --card-accent: #0ea5e9;
      --card-accent-light: #7dd3fc;
    }

    .violence-type-card[data-type="bullying"] {
      --card-accent: #eab308;
      --card-accent-light: #fde047;
    }

    .violence-type-card[data-type="cyberbullying"] {
      --card-accent: #06b6d4;
      --card-accent-light: #67e8f9;
    }

    .violence-type-card[data-type="autolesao"] {
      --card-accent: #6366f1;
      --card-accent-light: #a5b4fc;
    }

    .violence-type-card[data-type="outros"] {
      --card-accent: #64748b;
      --card-accent-light: #94a3b8;
    }

    /* ============================================
       SEÇÃO CONDICIONAL DE VIOLÊNCIA INSTITUCIONAL
       (Subgrupo integrado ao card)
       ============================================ */

    .violence-conditional-section {
      margin-top: 1rem;
      padding: 1rem;
      background: linear-gradient(135deg, rgba(14, 165, 233, 0.04) 0%, rgba(14, 165, 233, 0.08) 100%);
      border: 2px dashed #0ea5e9;
      border-radius: 12px;
      position: relative;
      animation: conditionalSlideIn 0.35s cubic-bezier(0.4, 0, 0.2, 1);
    }

    @keyframes conditionalSlideIn {
      from {
        opacity: 0;
        transform: translateY(-10px);
        max-height: 0;
      }

      to {
        opacity: 1;
        transform: translateY(0);
        max-height: 500px;
      }
    }

    .violence-conditional-header {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      margin-bottom: 0.75rem;
      padding-bottom: 0.5rem;
      border-bottom: 1px solid rgba(14, 165, 233, 0.2);
    }

    .violence-conditional-icon {
      font-size: 1.25rem;
    }

    .violence-conditional-title {
      font-size: 0.8rem;
      font-weight: 700;
      color: #0369a1;
      text-transform: uppercase;
      letter-spacing: 0.025em;
    }

    .violence-conditional-badge {
      margin-left: auto;
      padding: 0.25rem 0.5rem;
      background: rgba(14, 165, 233, 0.15);
      color: #0284c7;
      font-size: 0.65rem;
      font-weight: 600;
      border-radius: 999px;
    }

    .violence-conditional-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(130px, 1fr));
      gap: 0.5rem;
    }

    @media (min-width: 768px) {
      .violence-conditional-grid {
        grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
      }
    }

    /* Mini cards para opções condicionais */
    .violence-sub-card {
      position: relative;
      display: flex;
      align-items: center;
      gap: 0.5rem;
      padding: 0.625rem 0.75rem;
      background: white;
      border: 1.5px solid #e2e8f0;
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .violence-sub-card:hover {
      border-color: #0ea5e9;
      background: #f0f9ff;
    }

    .violence-sub-card.selected {
      background: linear-gradient(135deg, #e0f2fe 0%, #bae6fd 100%);
      border-color: #0ea5e9;
      border-width: 2px;
    }

    .violence-sub-card.selected .violence-sub-label {
      color: #0369a1;
      font-weight: 600;
    }

    .violence-sub-card.selected .violence-sub-check {
      opacity: 1;
      transform: scale(1);
    }

    .violence-sub-icon {
      font-size: 1rem;
      flex-shrink: 0;
    }

    .violence-sub-label {
      font-size: 0.75rem;
      color: #475569;
      font-weight: 500;
      line-height: 1.2;
      flex: 1;
    }

    .violence-sub-check {
      width: 16px;
      height: 16px;
      background: linear-gradient(135deg, #0ea5e9 0%, #0284c7 100%);
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      color: white;
      font-size: 9px;
      font-weight: bold;
      opacity: 0;
      transform: scale(0.5);
      transition: all 0.2s cubic-bezier(0.68, -0.55, 0.265, 1.55);
      flex-shrink: 0;
    }

    .violence-sub-card input[type="checkbox"] {
      position: absolute;
      opacity: 0;
      width: 100%;
      height: 100%;
      top: 0;
      left: 0;
      cursor: pointer;
      z-index: 2;
    }

    /* Ações em lote no topo */
    .violence-actions-bar {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 0.75rem;
      padding-bottom: 0.5rem;
      border-bottom: 1px solid #e2e8f0;
    }

    .violence-actions-title {
      font-size: 0.75rem;
      font-weight: 600;
      color: #64748b;
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }

    .violence-actions-buttons {
      display: flex;
      gap: 0.5rem;
    }

    .violence-action-btn {
      padding: 0.375rem 0.625rem;
      font-size: 0.7rem;
      font-weight: 600;
      border-radius: 6px;
      border: none;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .violence-action-btn.select-all {
      background: #dbeafe;
      color: #1d4ed8;
    }

    .violence-action-btn.select-all:hover {
      background: #bfdbfe;
    }

    .violence-action-btn.clear-all {
      background: #fee2e2;
      color: #dc2626;
    }

    .violence-action-btn.clear-all:hover {
      background: #fecaca;
    }

    /* Tipo Deficiência: 2 → 3 colunas */
    #filterTipoDeficienciaContainer {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 0.5rem 0.75rem;
    }

    @media (min-width: 768px) {
      #filterTipoDeficienciaContainer {
        grid-template-columns: repeat(3, 1fr);
      }
    }

    /* Região, Tipo Instituição: 2 → 3 → 4 colunas */
    #filterRegiaoContainer,
    #filterTipoInstituicaoContainer {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 0.5rem 0.75rem;
    }

    @media (min-width: 768px) {

      #filterRegiaoContainer,
      #filterTipoInstituicaoContainer {
        grid-template-columns: repeat(3, 1fr);
      }
    }

    @media (min-width: 1024px) {

      #filterRegiaoContainer,
      #filterTipoInstituicaoContainer {
        grid-template-columns: repeat(4, 1fr);
      }
    }

    /* ============================================
       INDENTAÇÃO DE CONDICIONAIS
       ============================================ */

    .conditional-indent {
      position: relative;
      padding-left: 1.5rem;
      border-left: 3px solid #60a5fa;
      margin-left: 0.5rem;
      padding-top: 0.75rem;
      padding-bottom: 0.75rem;
      background: linear-gradient(90deg, rgba(96, 165, 250, 0.05) 0%, transparent 100%);
      border-radius: 0.5rem;
      animation: conditionalAppear 0.3s ease-out;
    }

    @keyframes conditionalAppear {
      from {
        opacity: 0;
        transform: translateX(-10px);
      }

      to {
        opacity: 1;
        transform: translateX(0);
      }
    }

    .filter-badge {
      display: inline-flex;
      align-items: center;
      height: 18px;
      padding: 0 8px;
      border-radius: 9999px;
      font-size: 10px;
      font-weight: 700;
      color: #1e40af;
      background: #dbeafe;
      border: 1px solid #93c5fd;
      white-space: nowrap;
    }

    /* ============================================
       NEUTRALIZAÇÃO
       ============================================ */

    /* Remove min-height excessiva */
    .filter-group-content .grid>div:not(.hidden) {
      min-height: auto !important;
    }
  </style>

  <!-- Intro.js - Sistema de Onboarding -->
  <link rel="stylesheet" href="https://unpkg.com/intro.js/minified/introjs.min.css">
  <link rel="stylesheet" href="assets/css/onboarding.css">
</head>

<body class="bg-gradient-to-br from-gray-50 to-blue-50 min-h-screen">

  <!-- Container Principal -->
  <div class="max-w-[1680px] mx-auto px-4 py-8">

    <!-- Menu de Navegação -->
    <div data-tour="header" class="bg-gradient-to-r from-blue-600 to-blue-700 rounded-xl shadow-lg mb-6">
      <div class="px-4 py-3">
        <!-- Botão Hamburguer (Mobile) -->
        <button onclick="toggleMobileMenu()"
          class="mobile-menu-button w-full flex items-center justify-between text-white font-semibold">
          <span>📱 Menu</span>
          <svg class="w-6 h-6 transition-transform" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16"></path>
          </svg>
        </button>

        <!-- Menu Desktop (renderizado dinamicamente por navigation.js) -->
        <nav data-tour="menu" class="desktop-menu flex flex-wrap gap-2 justify-center items-center">
          <!-- Menu sera renderizado por NAVMNavigation.renderMenus() -->
        </nav>

        <!-- Menu Mobile (Dropdown) -->
        <nav id="mobileMenuNav" class="mobile-menu mt-3">
          <div class="flex flex-col gap-2">
            <!-- Menu sera renderizado por NAVMNavigation.renderMenus() -->
          </div>
        </nav>
      </div>
    </div>

    <!-- Alerta de novas notificações -->
    <div id="alerta-novas-notificacoes" class="alerta-novas-notificacoes mb-4">
      <div class="flex items-center gap-3">
        <span class="text-lg">🔔</span>
        <div class="flex flex-col">
          <span class="font-semibold">Existem novas notificações!</span>
          <span class="text-sm text-rose-700">Clique em Atualizar Dados para recarregar.</span>
        </div>
      </div>
    </div>

    <!-- CABEÇALHO -->
    <div class="bg-white rounded-2xl shadow-xl p-6 mb-6">
      <div class="flex items-center justify-center gap-4 mb-3">
        <div
          class="h-14 w-14 flex items-center justify-center rounded-full bg-blue-100 text-blue-600 text-3xl shadow-sm">
          📊
        </div>
        <div class="text-center">
          <h1
            class="text-3xl md:text-4xl font-bold text-transparent bg-clip-text bg-gradient-to-r from-blue-600 to-blue-800">
            Painel de Casos de Violência Escolar
          </h1>
        </div>
      </div>
      <p class="text-center text-gray-600">Sistema de visualização e análise de dados conectado ao Google Sheets</p>
      <p class="text-center text-gray-500 text-sm mt-2">✅ Dados carregados automaticamente da planilha oficial</p>
    </div>

    <!-- CONEXÃO COM PLANILHA -->
    <section class="bg-white rounded-2xl shadow-xl p-6 mb-6">
      <h2 class="text-2xl font-semibold text-gray-800 mb-4">🔗 Conexão com Planilha</h2>

      <div class="mb-4 flex items-center justify-between">
        <div>
          <p class="text-slate-700 font-medium mb-1">Planilha conectada:</p>
          <p class="text-slate-500 text-sm">Os dados são carregados automaticamente da planilha configurada no Google
            Sheets</p>
        </div>
        <button id="btnAtualizar" onclick="carregarDadosPlanilha()"
          class="px-6 py-3 bg-gradient-to-r from-blue-600 to-blue-700 text-white rounded-lg font-semibold hover:from-blue-700 hover:to-blue-800 transition shadow-md hover:shadow-lg flex items-center gap-2">
          <span>🔄</span>
          <span>Atualizar Dados</span>
        </button>
      </div>

      <div id="uploadStatus" class="p-4 rounded-md bg-blue-50 text-blue-700">⏳ Carregando dados da planilha...</div>
    </section>

    <!-- FILTROS -->
    <section id="filtersSection" data-tour="filtros" class="bg-white rounded-2xl shadow-xl p-6 mb-6 hidden fade-in">
      <h2 class="text-2xl font-semibold text-gray-800 mb-4">🔍 Filtros</h2>

      <!-- Buscar por nome (sempre visível) -->
      <div class="mb-3 pb-3 border-b border-gray-200">
        <label class="block text-gray-700 font-medium mb-2">Buscar por nome da criança/estudante:</label>
        <input type="text" id="filterNome" placeholder="Digite parte do nome..."
          class="input-elegant w-full px-3 py-2 border border-gray-300 rounded-md text-sm">
      </div>

      <!-- NOVO PAINEL DE FILTROS (único) -->
      <div id="quickAdvancedFiltersBox" class="mt-4">
        <div class="bg-gradient-to-br from-gray-50 to-blue-50 rounded-xl p-4 border border-gray-200 shadow-sm">
          <div class="filters-grid">

            <details id="filterGroupPeriodo"
              class="filter-group group rounded-xl border border-gray-200 bg-white shadow-sm" data-mode="panel">
              <summary
                class="flex cursor-pointer list-none items-center justify-between gap-3 px-4 py-3 hover:bg-slate-50 transition-colors">
                <div class="flex items-center gap-3">
                  <div class="p-1.5 rounded-md bg-blue-100 text-blue-700">📅</div>
                  <span class="text-sm font-semibold text-gray-800">Período</span>
                </div>
                <span class="filter-group-chevron text-gray-400">▾</span>
              </summary>
              <div class="filter-group-content">
                <div class="px-4 pb-4 pt-2">
                  <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-4">
                    <!-- Filtro: Data Início -->
                    <div>
                      <label class="block text-gray-700 font-medium mb-2">Data Início:</label>
                      <input type="date" id="filterDataInicio"
                        class="input-elegant w-full px-3 py-2 border border-gray-300 rounded-md text-sm">
                    </div>

                    <!-- Filtro: Data Fim -->
                    <div>
                      <label class="block text-gray-700 font-medium mb-2">Data Fim:</label>
                      <input type="date" id="filterDataFim"
                        class="input-elegant w-full px-3 py-2 border border-gray-300 rounded-md text-sm">
                    </div>
                  </div>
                </div>
              </div>
            </details>

            <details id="filterGroupContextoEscolar"
              class="filter-group group rounded-xl border border-gray-200 bg-white shadow-sm" data-mode="panel">
              <summary
                class="flex cursor-pointer list-none items-center justify-between gap-3 px-4 py-3 hover:bg-slate-50 transition-colors">
                <div class="flex items-center gap-3">
                  <div class="p-1.5 rounded-md bg-blue-100 text-blue-700">🏫</div>
                  <span class="text-sm font-semibold text-gray-800">Escola / Contexto</span>
                </div>
                <span class="filter-group-chevron text-gray-400">▾</span>
              </summary>
              <div class="filter-group-content">
                <div class="px-4 pb-4 pt-2">

                  <!-- Região -->
                  <div class="mb-4">
                    <h4 class="text-sm font-semibold text-gray-600 mb-3 uppercase tracking-wide">📍 Região</h4>
                    <div id="filterRegiaoContainer"></div>
                  </div>

                  <!-- Tipo de Instituição -->
                  <div class="mb-4">
                    <h4 class="text-sm font-semibold text-gray-600 mb-3 uppercase tracking-wide">🏫 Tipo de Instituição
                    </h4>
                    <div id="filterTipoInstituicaoContainer"></div>
                  </div>

                  <!-- Escola Específica -->
                  <div id="section-escola" class="mb-4">
                    <h4 class="text-sm font-semibold text-gray-600 mb-3 uppercase tracking-wide">🏢 Escola Específica
                    </h4>
                    <div class="autocomplete-wrapper mb-2">
                      <input type="text" id="filterEscolaSearch"
                        class="w-full px-4 py-2.5 border border-gray-200 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500/60 focus:border-blue-500 transition-all duration-200 bg-white shadow-sm"
                        placeholder="Digite para buscar..." autocomplete="off">
                      <div class="autocomplete-list" id="filterEscolaAutocompleteList"></div>
                    </div>
                    <div id="filterEscolaSelectedTags" class="selected-tags mb-2"></div>
                    <p class="text-xs text-gray-500 mt-1.5">Digite para buscar e selecione uma instituição.</p>
                    <div id="filterEscolaContainer" style="display:none"></div>
                  </div>

                  <!-- Tempo Integral -->
                  <div id="section-ti" class="mb-4">
                    <h4 class="text-sm font-semibold text-gray-600 mb-3 uppercase tracking-wide">⏱️ Tempo Integral</h4>
                    <div class="flex gap-3 items-center">
                      <label class="text-sm font-medium text-gray-700">Filtrar por:</label>
                      <select id="filterTI"
                        class="px-4 py-2 border-2 border-gray-300 rounded-lg text-sm font-medium focus:border-blue-500 focus:ring-2 focus:ring-blue-200 transition-all">
                        <option value="">Todos</option>
                        <option value="TI">Tempo Integral (TI)</option>
                        <option value="Regular">Tempo Regular (não TI)</option>
                      </select>
                    </div>
                  </div>

                  <div class="grid grid-cols-1 md:grid-cols-2 xl:grid-cols-2 2xl:grid-cols-3 gap-4">
                    <!-- Filtro: Fonte informada -->
                    <div>
                      <label class="block text-gray-700 font-medium mb-2">
                        <span class="flex items-start gap-1">
                          <span class="flex-1">O relato foi feito pela escola?</span>
                          <span class="relative inline-flex align-middle ml-1 tooltip-trigger" tabindex="0"
                            role="button" aria-label="Ajuda">
                            <span
                              class="inline-flex items-center justify-center w-4 h-4 rounded-full bg-indigo-50 text-indigo-800 border border-indigo-300 text-[10px] leading-none select-none">ⓘ</span>
                            <span class="tooltip-popover absolute left-1/2 -translate-x-1/2 bottom-full mb-2">
                              <span class="absolute inset-[-10px] rounded-2xl bg-white/30 backdrop-blur-[2px]"></span>
                              <span
                                class="relative block w-80 max-w-[90vw] rounded-xl border border-indigo-300 bg-white/95 shadow-2xl shadow-indigo-900/20 p-4 text-xs text-gray-900">
                                <div class="text-[11px] font-extrabold text-indigo-900 mb-2 tracking-wide">Fonte do
                                  relato</div>
                                <div class="leading-relaxed text-gray-800">Mostra quem iniciou o relato/notificação do
                                  caso. “Sim” significa que a própria escola identificou e registrou o caso (direção,
                                  coordenação, professores ou equipe). “Não” indica que o caso chegou à escola por outra
                                  fonte (ex.: família, estudante, serviços, instituições externas). Isso ajuda a
                                  interpretar como a escola tomou conhecimento do ocorrido.</div>
                              </span>
                            </span>
                          </span>
                        </span>
                      </label>
                      <select id="filterFonteInformada" class="select-elegant w-full">
                        <option value="">Todos</option>
                        <option value="S">Sim</option>
                        <option value="N">Não</option>
                      </select>
                    </div>

                    <!-- Filtro: Violência identificada pela escola ocorrida na escola (Coluna Q) -->
                    <div>
                      <label class="block text-gray-700 font-medium mb-2 text-sm">
                        <span class="flex items-start gap-1">
                          <span class="flex-1">Escola identificou que a violência ocorreu na escola?</span>
                          <span class="relative inline-flex align-middle ml-1 tooltip-trigger" tabindex="0"
                            role="button" aria-label="Ajuda">
                            <span
                              class="inline-flex items-center justify-center w-4 h-4 rounded-full bg-indigo-50 text-indigo-800 border border-indigo-300 text-[10px] leading-none select-none">ⓘ</span>
                            <span class="tooltip-popover absolute left-1/2 -translate-x-1/2 bottom-full mb-2">
                              <span class="absolute inset-[-10px] rounded-2xl bg-white/30 backdrop-blur-[2px]"></span>
                              <span
                                class="relative block w-80 max-w-[90vw] rounded-xl border border-indigo-300 bg-white/95 shadow-2xl shadow-indigo-900/20 p-4 text-xs text-gray-900">
                                <div class="text-[11px] font-extrabold text-indigo-900 mb-2 tracking-wide">Local
                                  confirmado (na escola)</div>
                                <div class="leading-relaxed text-gray-800">Indica se, após apuração/verificação, foi
                                  confirmado que o fato ocorreu dentro do ambiente escolar (ex.: sala, pátio, banheiro,
                                  quadra). Este campo descreve o local do ocorrido — não a autoria — e ajuda a
                                  diferenciar situações internas da escola de situações externas acompanhadas pela
                                  escola.</div>
                              </span>
                            </span>
                          </span>
                        </span>
                      </label>
                      <select id="filterViolenciaEscolaOcorreu" class="select-elegant w-full">
                        <option value="">Todos</option>
                        <option value="S">Sim</option>
                        <option value="N">Não</option>
                      </select>
                    </div>

                    <!-- Filtro: Violência identificada não ocorrida na escola -->
                    <div>
                      <label class="block text-gray-700 font-medium text-sm" style="margin-bottom: 6px;">
                        <span class="flex items-start gap-1">
                          <span class="flex-1">Escola identificou que a violência NÃO ocorreu na escola?</span>
                          <span class="relative inline-flex align-middle ml-1 tooltip-trigger" tabindex="0"
                            role="button" aria-label="Ajuda">
                            <span
                              class="inline-flex items-center justify-center w-4 h-4 rounded-full bg-indigo-50 text-indigo-800 border border-indigo-300 text-[10px] leading-none select-none">ⓘ</span>
                            <span class="tooltip-popover absolute left-1/2 -translate-x-1/2 bottom-full mb-2">
                              <span class="absolute inset-[-10px] rounded-2xl bg-white/30 backdrop-blur-[2px]"></span>
                              <span
                                class="relative block w-80 max-w-[90vw] rounded-xl border border-indigo-300 bg-white/95 shadow-2xl shadow-indigo-900/20 p-4 text-xs text-gray-900">
                                <div class="text-[11px] font-extrabold text-indigo-900 mb-2 tracking-wide">Local
                                  confirmado (fora da escola)</div>
                                <div class="leading-relaxed text-gray-800">Indica se, após verificação, foi confirmado
                                  que o fato ocorreu fora do ambiente escolar (ex.: residência, via pública, transporte,
                                  outros locais externos). Mesmo quando a escola acompanha ou identifica o caso, este
                                  campo ajuda a registrar que o local do ocorrido não foi na escola.</div>
                              </span>
                            </span>
                          </span>
                        </span>
                      </label>
                      <select id="filterViolenciaNaoEscola" class="select-elegant w-full" style="margin-top: 2px;">
                        <option value="">Todos</option>
                        <option value="S">Sim</option>
                        <option value="N">Não</option>
                      </select>
                    </div>

                    <!-- Filtro: Estudo de Caso -->
                    <div>
                      <label class="block text-gray-700 font-medium mb-2">
                        <span class="flex items-start gap-1">
                          <span class="flex-1">Foi realizado estudo de caso pela equipe?</span>
                          <span class="relative inline-flex align-middle ml-1 tooltip-trigger" tabindex="0"
                            role="button" aria-label="Ajuda">
                            <span
                              class="inline-flex items-center justify-center w-4 h-4 rounded-full bg-indigo-50 text-indigo-800 border border-indigo-300 text-[10px] leading-none select-none">ⓘ</span>
                            <span class="tooltip-popover absolute left-1/2 -translate-x-1/2 bottom-full mb-2">
                              <span class="absolute inset-[-10px] rounded-2xl bg-white/30 backdrop-blur-[2px]"></span>
                              <span
                                class="relative block w-80 max-w-[90vw] rounded-xl border border-indigo-300 bg-white/95 shadow-2xl shadow-indigo-900/20 p-4 text-xs text-gray-900">
                                <div class="text-[11px] font-extrabold text-indigo-900 mb-2 tracking-wide">Estudo de
                                  caso</div>
                                <div class="leading-relaxed text-gray-800">Indica se a equipe realizou estudo de caso
                                  (análise estruturada do registro), geralmente com reuniões, avaliação multidisciplinar
                                  (pedagógica/psicossocial/direção), definição de plano de intervenção e documentação
                                  interna. Ajuda a entender o nível de consolidação do acompanhamento do caso.</div>
                              </span>
                            </span>
                          </span>
                        </span>
                      </label>
                      <select id="filterEstudoCaso" class="select-elegant w-full">
                        <option value="">Todos</option>
                        <option value="S">Sim</option>
                        <option value="N">Não</option>
                      </select>
                    </div>

                    <!-- Filtro: Violência informada à escola -->
                    <div>
                      <label class="block text-gray-700 font-medium mb-2">
                        <span class="flex items-start gap-1">
                          <span class="flex-1">Violência comunicada à escola por algum agente externo?</span>
                          <span class="relative inline-flex align-middle ml-1 tooltip-trigger" tabindex="0"
                            role="button" aria-label="Ajuda">
                            <span
                              class="inline-flex items-center justify-center w-4 h-4 rounded-full bg-indigo-50 text-indigo-800 border border-indigo-300 text-[10px] leading-none select-none">ⓘ</span>
                            <span class="tooltip-popover absolute left-1/2 -translate-x-1/2 bottom-full mb-2">
                              <span class="absolute inset-[-10px] rounded-2xl bg-white/30 backdrop-blur-[2px]"></span>
                              <span
                                class="relative block w-80 max-w-[90vw] rounded-xl border border-indigo-300 bg-white/95 shadow-2xl shadow-indigo-900/20 p-4 text-xs text-gray-900">
                                <div class="text-[11px] font-extrabold text-indigo-900 mb-2 tracking-wide">Comunicação
                                  por terceiros</div>
                                <div class="leading-relaxed text-gray-800">Indica se a escola tomou conhecimento do caso
                                  por comunicação de terceiros (agentes externos), e não por identificação direta da
                                  equipe escolar. Exemplos: família, o próprio estudante, vizinhos, Conselho Tutelar,
                                  Polícia, UBS, CRAS, entre outros. Esse campo é útil para interpretar a origem da
                                  informação e o fluxo de notificação.</div>
                              </span>
                            </span>
                          </span>
                        </span>
                      </label>
                      <select id="filterViolenciaInformada" class="select-elegant w-full">
                        <option value="">Todos</option>
                        <option value="S">Sim</option>
                        <option value="N">Não</option>
                      </select>
                    </div>

                    <!-- Filtro (condicional): Ocorreu na escola (apenas quando agente externo = Sim) -->
                    <div id="filterOcorreuEscolaContainer" class="hidden conditional-indent">
                      <label class="block text-gray-700 font-medium mb-2">
                        <span class="flex items-start gap-1">
                          <span class="flex-1">➜ A violência ocorreu na escola?</span>
                          <span class="relative inline-flex align-middle ml-1 tooltip-trigger" tabindex="0"
                            role="button" aria-label="Condição">
                            <span class="filter-badge">Condicional: Agente Externo = Sim</span>
                            <span class="tooltip-popover absolute left-1/2 -translate-x-1/2 bottom-full mb-2">
                              <span class="absolute inset-[-10px] rounded-2xl bg-white/30 backdrop-blur-[2px]"></span>
                              <span
                                class="relative block w-80 max-w-[90vw] rounded-xl border border-indigo-300 bg-white/95 shadow-2xl shadow-indigo-900/20 p-4 text-xs text-gray-900">
                                <div class="text-[11px] font-extrabold text-indigo-900 mb-2 tracking-wide">Condição de
                                  exibição</div>
                                <div class="leading-relaxed text-gray-800">Exibido quando: “A violência foi comunicada à
                                  escola por algum agente externo?” = Sim.</div>
                              </span>
                            </span>
                          </span>
                          <span class="relative inline-flex align-middle ml-1 tooltip-trigger" tabindex="0"
                            role="button" aria-label="Ajuda">
                            <span
                              class="inline-flex items-center justify-center w-4 h-4 rounded-full bg-indigo-50 text-indigo-800 border border-indigo-300 text-[10px] leading-none select-none">ⓘ</span>
                            <span class="tooltip-popover absolute left-1/2 -translate-x-1/2 bottom-full mb-2">
                              <span class="absolute inset-[-10px] rounded-2xl bg-white/30 backdrop-blur-[2px]"></span>
                              <span
                                class="relative block w-80 max-w-[90vw] rounded-xl border border-indigo-300 bg-white/95 shadow-2xl shadow-indigo-900/20 p-4 text-xs text-gray-900">
                                <div class="text-[11px] font-extrabold text-indigo-900 mb-2 tracking-wide">Confirmação
                                  do local</div>
                                <div class="leading-relaxed text-gray-800">Este campo aparece quando o caso foi
                                  comunicado por agente externo. Ele registra a conclusão (após apuração) sobre onde o
                                  fato ocorreu: dentro ou fora da escola. Serve para evitar interpretações ambíguas
                                  quando a informação chegou por terceiros, mas o local do ocorrido ainda precisa ser
                                  confirmado.</div>
                              </span>
                            </span>
                          </span>
                        </span>
                      </label>
                      <select id="filterOcorreuEscola" class="select-elegant w-full">
                        <option value="">Todos</option>
                        <option value="S">Sim</option>
                        <option value="N">Não</option>
                      </select>
                    </div>
                  </div>
                </div>
              </div>
            </details>

            <details id="filterGroupAutoriaAgente"
              class="filter-group group rounded-xl border border-gray-200 bg-white shadow-sm" data-mode="panel">
              <summary
                class="flex cursor-pointer list-none items-center justify-between gap-3 px-4 py-3 hover:bg-slate-50 transition-colors">
                <div class="flex items-center gap-3">
                  <div class="p-1.5 rounded-md bg-blue-100 text-blue-700">🧑‍🤝‍🧑</div>
                  <span class="text-sm font-semibold text-gray-800">Autoria / Agente</span>
                </div>
                <span class="filter-group-chevron text-gray-400">▾</span>
              </summary>
              <div class="filter-group-content">
                <div class="px-4 pb-4 pt-2">
                  <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-4">
                    <!-- Filtro: Foi um membro familiar? -->
                    <div>
                      <label class="block text-gray-700 font-medium mb-2">
                        <span class="inline-flex items-center gap-1">
                          O autor era membro da família?
                          <span class="relative inline-flex align-middle ml-1 tooltip-trigger" tabindex="0"
                            role="button" aria-label="Ajuda">
                            <span
                              class="inline-flex items-center justify-center w-4 h-4 rounded-full bg-indigo-50 text-indigo-800 border border-indigo-300 text-[10px] leading-none select-none">ⓘ</span>
                            <span class="tooltip-popover absolute left-1/2 -translate-x-1/2 bottom-full mb-2">
                              <span class="absolute inset-[-10px] rounded-2xl bg-white/30 backdrop-blur-[2px]"></span>
                              <span
                                class="relative block w-80 max-w-[90vw] rounded-xl border border-indigo-300 bg-white/95 shadow-2xl shadow-indigo-900/20 p-4 text-xs text-gray-900">
                                <div class="text-[11px] font-extrabold text-indigo-900 mb-2 tracking-wide">Membro da
                                  família</div>
                                <div class="leading-relaxed text-gray-800">Use esta informação para entender se o caso
                                  tem indício de violência intrafamiliar. Considere como familiar: pais ou responsáveis
                                  legais, avós, irmãos, tios, primos e outros parentes consanguíneos ou por afinidade.
                                  Quando marcado como “Sim”, costuma indicar necessidade de atenção para contexto
                                  doméstico e rede de proteção.</div>
                              </span>
                            </span>
                          </span>
                        </span>
                      </label>
                      <select id="filterMembroFamiliar" class="select-elegant w-full">
                        <option value="">Todos</option>
                        <option value="Sim">Sim</option>
                        <option value="Não">Não</option>
                        <option value="naoinformado">Não informado</option>
                      </select>
                    </div>

                    <!-- Filtro: Profissional autor -->
                    <div>
                      <label class="block text-gray-700 font-medium mb-2">
                        <span class="inline-flex items-center gap-1">
                          Profissional/funcionário foi autor?
                          <span class="relative inline-flex align-middle ml-1 tooltip-trigger" tabindex="0"
                            role="button" aria-label="Ajuda">
                            <span
                              class="inline-flex items-center justify-center w-4 h-4 rounded-full bg-indigo-50 text-indigo-800 border border-indigo-300 text-[10px] leading-none select-none">ⓘ</span>
                            <span class="tooltip-popover absolute left-1/2 -translate-x-1/2 bottom-full mb-2">
                              <span class="absolute inset-[-10px] rounded-2xl bg-white/30 backdrop-blur-[2px]"></span>
                              <span
                                class="relative block w-80 max-w-[90vw] rounded-xl border border-indigo-300 bg-white/95 shadow-2xl shadow-indigo-900/20 p-4 text-xs text-gray-900">
                                <div class="text-[11px] font-extrabold text-indigo-900 mb-2 tracking-wide">Autoria
                                  (profissional)</div>
                                <div class="leading-relaxed text-gray-800">Indica se a autoria do caso foi atribuída a
                                  profissional/funcionário da escola. Considere professores, coordenação, direção,
                                  auxiliares, terceirizados (limpeza, segurança, portaria, merenda) e demais
                                  colaboradores. Esse campo é importante porque muda a interpretação do caso e os
                                  encaminhamentos administrativos.</div>
                              </span>
                            </span>
                          </span>
                        </span>
                      </label>
                      <select id="filterProfissionalAutor" class="select-elegant w-full">
                        <option value="">Todos</option>
                        <option value="S">Sim</option>
                        <option value="N">Não</option>
                      </select>
                    </div>

                    <!-- Filtro: Estudante autor -->
                    <div>
                      <label class="block text-gray-700 font-medium mb-2">
                        <span class="inline-flex items-center gap-1">
                          Estudante foi autor?
                          <span class="relative inline-flex align-middle ml-1 tooltip-trigger" tabindex="0"
                            role="button" aria-label="Ajuda">
                            <span
                              class="inline-flex items-center justify-center w-4 h-4 rounded-full bg-indigo-50 text-indigo-800 border border-indigo-300 text-[10px] leading-none select-none">ⓘ</span>
                            <span class="tooltip-popover absolute left-1/2 -translate-x-1/2 bottom-full mb-2">
                              <span class="absolute inset-[-10px] rounded-2xl bg-white/30 backdrop-blur-[2px]"></span>
                              <span
                                class="relative block w-80 max-w-[90vw] rounded-xl border border-indigo-300 bg-white/95 shadow-2xl shadow-indigo-900/20 p-4 text-xs text-gray-900">
                                <div class="text-[11px] font-extrabold text-indigo-900 mb-2 tracking-wide">Autoria
                                  (estudante)</div>
                                <div class="leading-relaxed text-gray-800">Indica se a autoria foi atribuída a estudante
                                  (da mesma escola ou de outra unidade). Em geral, é usado para casos como agressões
                                  entre estudantes, bullying/cyberbullying e outras violências no contexto escolar entre
                                  pares.</div>
                              </span>
                            </span>
                          </span>
                        </span>
                      </label>
                      <select id="filterEstudanteAutor" class="select-elegant w-full">
                        <option value="">Todos</option>
                        <option value="S">Sim</option>
                        <option value="N">Não</option>
                      </select>
                    </div>
                  </div>
                </div>
              </div>
            </details>

            <details id="filterGroupViolencia"
              class="filter-group group rounded-xl border border-gray-200 bg-white shadow-sm" data-mode="panel">
              <summary
                class="flex cursor-pointer list-none items-center justify-between gap-3 px-4 py-3 hover:bg-slate-50 transition-colors">
                <div class="flex items-center gap-3">
                  <div class="p-1.5 rounded-md bg-blue-100 text-blue-700">⚠️</div>
                  <span class="text-sm font-semibold text-gray-800">Violência</span>
                </div>
                <span class="filter-group-chevron text-gray-400">▾</span>
              </summary>
              <div class="filter-group-content">
                <div class="px-4 pb-4 pt-2">

                  <!-- Tipo de Violência - Redesign com Cards -->
                  <div class="mb-4">
                    <!-- Barra de ações -->
                    <div class="violence-actions-bar">
                      <h4 class="violence-actions-title">⚠️ Tipo de Violência</h4>
                      <div class="violence-actions-buttons">
                        <button type="button" class="violence-action-btn select-all" onclick="selectAllViolenceTypes()">
                          ✓ Todos
                        </button>
                        <button type="button" class="violence-action-btn clear-all" onclick="clearAllViolenceTypes()">
                          ✕ Limpar
                        </button>
                      </div>
                    </div>
                    <!-- Container de cards de tipos de violência -->
                    <div id="filterTipoViolenciaContainer"></div>
                  </div>

                  <!-- CONDICIONAL: Violência Institucional (integrado como subgrupo visual) -->
                  <div id="section-violenciaInstitucional" class="hidden">
                    <div class="violence-conditional-section">
                      <div class="violence-conditional-header">
                        <span class="violence-conditional-icon">🏛️</span>
                        <span class="violence-conditional-title">Detalhamento: Violências Institucionais</span>
                        <span class="violence-conditional-badge">Filtro ativo</span>
                        <span id="badge-violenciaInstitucional-total"
                          class="badge-count hidden inline-flex items-center justify-center px-2 py-0.5 text-xs font-bold leading-none text-white bg-sky-600 rounded-full ml-2">0</span>
                      </div>
                      <div id="filterViolenciaInstitucionalContainer" class="violence-conditional-grid"></div>
                    </div>
                  </div>

                </div>
              </div>
            </details>

            <details id="filterGroupEncaminhamentos"
              class="filter-group group rounded-xl border border-gray-200 bg-white shadow-sm" data-mode="panel">
              <summary
                class="flex cursor-pointer list-none items-center justify-between gap-3 px-4 py-3 hover:bg-slate-50 transition-colors">
                <div class="flex items-center gap-3">
                  <div class="p-1.5 rounded-md bg-blue-100 text-blue-700">📋</div>
                  <span class="text-sm font-semibold text-gray-800">Encaminhamentos</span>
                </div>
                <span class="filter-group-chevron text-gray-400">▾</span>
              </summary>
              <div class="filter-group-content">
                <div class="px-4 pb-4 pt-2">

                  <div>
                    <h4
                      class="text-sm font-semibold text-gray-600 mb-3 uppercase tracking-wide flex items-center justify-between">
                      <span>📋 Encaminhamento</span>
                      <span id="badge-encaminhamento-total"
                        class="badge-count hidden inline-flex items-center justify-center px-2.5 py-1 text-xs font-bold leading-none text-white bg-blue-600 rounded-full">0</span>
                    </h4>
                    <div id="filterEncaminhamentoContainer" class="space-y-3"></div>
                  </div>

                </div>
              </div>
            </details>

            <details id="filterGroupPerfilEstudante"
              class="filter-group group rounded-xl border border-gray-200 bg-white shadow-sm" data-mode="panel">
              <summary
                class="flex cursor-pointer list-none items-center justify-between gap-3 px-4 py-3 hover:bg-slate-50 transition-colors">
                <div class="flex items-center gap-3">
                  <div class="p-1.5 rounded-md bg-blue-100 text-blue-700">👥</div>
                  <span class="text-sm font-semibold text-gray-800">Criança / Perfil</span>
                </div>
                <span class="filter-group-chevron text-gray-400">▾</span>
              </summary>
              <div class="filter-group-content">
                <div class="px-4 pb-4 pt-2">
                  <div class="child-filters-grid">
                    <div class="child-filter-card">
                      <div class="child-filter-card-header">
                        <div class="child-filter-card-icon">📅</div>
                        <div class="child-filter-card-title">Faixa Etária</div>
                      </div>
                      <div class="child-filter-card-body">
                        <div class="child-age-grid">
                          <div>
                            <label class="block text-gray-700 font-medium mb-2">Idade Mínima:</label>
                            <input type="number" id="filterIdadeMin" placeholder="Ex: 5" class="child-age-input">
                          </div>
                          <div>
                            <label class="block text-gray-700 font-medium mb-2">Idade Máxima:</label>
                            <input type="number" id="filterIdadeMax" placeholder="Ex: 18" class="child-age-input">
                          </div>
                        </div>
                      </div>
                    </div>

                    <div class="child-filters-subgrid">
                      <div class="child-filter-card">
                        <div class="child-filter-card-header">
                          <div class="child-filter-card-icon">⚧️</div>
                          <div class="child-filter-card-title">GÊNERO (M/F)</div>
                        </div>
                        <div class="child-filter-card-body">
                          <div id="filterGeneroContainer"></div>
                        </div>
                      </div>

                      <div class="child-filter-card">
                        <div class="child-filter-card-header">
                          <div class="child-filter-card-icon">👥</div>
                          <div class="child-filter-card-title">RAÇA/COR</div>
                        </div>
                        <div class="child-filter-card-body">
                          <div id="filterRacaContainer"></div>
                        </div>
                      </div>

                      <div class="child-filter-card">
                        <div class="child-filter-card-header">
                          <div class="child-filter-card-icon">🌈</div>
                          <div class="child-filter-card-title">ORIENTAÇÃO SEXUAL</div>
                        </div>
                        <div class="child-filter-card-body">
                          <div id="filterOrientacaoContainer"></div>
                        </div>
                      </div>

                      <div class="child-filter-card">
                        <div class="child-filter-card-header">
                          <div class="child-filter-card-icon">♿</div>
                          <div class="child-filter-card-title">É PCD / TEM TRANSTORNO?</div>
                        </div>
                        <div class="child-filter-card-body">
                          <label class="block text-gray-700 font-medium mb-2">Selecione:</label>
                          <select id="filterPCD" class="select-elegant w-full">
                            <option value="">Todos</option>
                            <option value="S">Sim</option>
                            <option value="N">Não</option>
                          </select>
                        </div>
                      </div>
                    </div>
                  </div>

                  <!-- CONDICIONAL: Tipo Deficiência -->
                  <div id="section-tipoDeficiencia" class="mt-4 hidden conditional-indent">
                    <div class="child-filter-card has-flyout">
                      <div class="child-filter-card-header">
                        <div class="child-filter-card-icon">♿</div>
                        <div class="child-filter-card-title">TIPO DE DEFICIÊNCIA / TRANSTORNO</div>
                        <span class="filter-badge">Condicional: PCD = Sim</span>
                      </div>
                      <div class="child-filter-card-body">
                        <div id="filterTipoDeficienciaSelectedTags" class="selected-tags mb-2"></div>
                        <div class="autocomplete-wrapper mb-2">
                          <input type="text" id="filterTipoDeficienciaSearch"
                            class="w-full px-4 py-2.5 border border-gray-200 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500/60 focus:border-blue-500 transition-all duration-200 bg-white shadow-sm"
                            placeholder="Digite para buscar..." autocomplete="off">
                          <div class="autocomplete-list" id="filterTipoDeficienciaAutocompleteList"></div>
                        </div>
                        <p class="text-xs text-gray-500 mt-1.5">Digite para buscar e selecione um ou mais tipos.</p>
                        <div id="filterTipoDeficienciaContainer" style="display:none"></div>
                      </div>
                    </div>
                  </div>

                </div>
              </div>
            </details>

          </div>

          <!-- Painel (abre apenas 1 filtro por vez, como no backup) -->
          <div id="advancedPanel" class="advanced-panel mt-4">
            <div class="bg-gradient-to-br from-gray-50 to-blue-50 rounded-xl p-4 border border-gray-200 shadow-sm">
              <div id="advancedPanelContent"></div>
            </div>
          </div>
        </div>
      </div>

      <div data-tour="exportar" class="mt-4 flex gap-2 flex-wrap">
        <button id="btnLimparFiltros" class="btn-elegant btn-secondary-elegant px-4 py-2 rounded-md font-medium">
          🔄 Limpar Filtros
        </button>
        <button id="btnExportarCSV"
          class="btn-elegant px-4 py-2 bg-gradient-to-r from-green-600 to-green-700 hover:from-green-700 hover:to-green-800 text-white rounded-md font-medium">
          📥 Exportar CSV
        </button>
        <button id="btnExportarExcel"
          class="btn-elegant px-4 py-2 bg-gradient-to-r from-blue-600 to-blue-700 hover:from-blue-700 hover:to-blue-800 text-white rounded-md font-medium">
          📊 Exportar Excel
        </button>
        <button id="btnExportarPDF"
          class="btn-elegant px-4 py-2 bg-gradient-to-r from-red-600 to-red-700 hover:from-red-700 hover:to-red-800 text-white rounded-md font-medium">
          📄 Exportar PDF
        </button>
      </div>
    </section>

    <!-- DASHBOARD EXECUTIVO -->
    <section id="dashboardExecutivo" data-tour="dashboard"
      class="card-elegant bg-gradient-to-br from-slate-50 to-blue-50 rounded-2xl shadow-xl p-6 mb-6 hidden fade-in border-2 border-blue-200"
      data-reveal="fade-up">
      <div class="flex items-center justify-between mb-6">
        <h2 class="text-3xl font-bold text-gray-800 flex items-center gap-3">
          <span class="text-4xl animate-float">📊</span>
          <span>Dashboard Executivo</span>
        </h2>
        <button id="btnAtualizarKPIs"
          class="btn-elegant btn-primary-elegant px-4 py-2 rounded-lg text-sm font-semibold">
          🔄 Atualizar
        </button>
      </div>

      <!-- KPIs Principais -->
      <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4 mb-6">
        <div
          class="card-elegant bg-gradient-to-br from-blue-500 to-blue-600 rounded-xl p-5 text-white shadow-lg hover:shadow-xl transition-all duration-300 transform hover:scale-105"
          data-reveal="scale-up" data-stagger="50">
          <div class="flex items-center justify-between mb-2">
            <span class="text-sm font-medium opacity-90">Total de Casos</span>
            <span class="text-2xl">📋</span>
          </div>
          <div id="kpiTotalCasos" class="text-4xl font-bold mb-1">0</div>
          <div class="text-xs opacity-75" id="kpiTotalCasosVariacao">-</div>
        </div>

        <div
          class="card-elegant bg-gradient-to-br from-green-500 to-green-600 rounded-xl p-5 text-white shadow-lg hover:shadow-xl transition-all duration-300 transform hover:scale-105"
          data-reveal="scale-up" data-stagger="50">
          <div class="flex items-center justify-between mb-2">
            <span class="text-sm font-medium opacity-90">Casos Filtrados</span>
            <span class="text-2xl">🔍</span>
          </div>
          <div id="kpiCasosFiltrados" class="text-4xl font-bold mb-1">0</div>
          <div class="text-xs opacity-75" id="kpiCasosFiltradosPercentual">-</div>
        </div>

        <div
          class="card-elegant bg-gradient-to-br from-amber-500 to-amber-600 rounded-xl p-5 text-white shadow-lg hover:shadow-xl transition-all duration-300 transform hover:scale-105"
          data-reveal="scale-up" data-stagger="50">
          <div class="flex items-center justify-between mb-2">
            <span class="text-sm font-medium opacity-90">Top Escola</span>
            <span class="text-2xl">🏫</span>
          </div>
          <div id="kpiTopEscola" class="text-2xl font-bold mb-1 truncate">-</div>
          <div class="text-xs opacity-75" id="kpiTopEscolaCasos">-</div>
        </div>

        <div
          class="card-elegant bg-gradient-to-br from-purple-500 to-purple-600 rounded-xl p-5 text-white shadow-lg hover:shadow-xl transition-all duration-300 transform hover:scale-105"
          data-reveal="scale-up" data-stagger="50">
          <div class="flex items-center justify-between mb-2">
            <span class="text-sm font-medium opacity-90">Tipo Mais Frequente</span>
            <span class="text-2xl">⚠️</span>
          </div>
          <div id="kpiTipoFrequente" class="text-lg font-bold mb-1 truncate">-</div>
          <div class="text-xs opacity-75" id="kpiTipoFrequenteCasos">-</div>
        </div>
      </div>

      <!-- Análise Estatística e Top 5 -->
      <div class="grid grid-cols-1 lg:grid-cols-2 gap-4 mb-6">
        <div class="card-elegant bg-white rounded-xl p-5 border-2 border-gray-200 shadow-md">
          <h3 class="text-xl font-bold text-gray-800 mb-4 flex items-center gap-2">
            <span>📈</span>
            <span>Estatísticas Descritivas (Idade)</span>
          </h3>
          <div class="space-y-3">
            <div class="flex justify-between items-center py-2 border-b border-gray-100">
              <span class="text-gray-600 font-medium">Média:</span>
              <span id="statMediaIdade" class="text-lg font-bold text-blue-600">-</span>
            </div>
            <div class="flex justify-between items-center py-2 border-b border-gray-100">
              <span class="text-gray-600 font-medium">Mediana:</span>
              <span id="statMedianaIdade" class="text-lg font-bold text-blue-600">-</span>
            </div>
            <div class="flex justify-between items-center py-2 border-b border-gray-100">
              <span class="text-gray-600 font-medium">Mínima:</span>
              <span id="statIdadeMin" class="text-lg font-bold text-green-600">-</span>
            </div>
            <div class="flex justify-between items-center py-2 border-b border-gray-100">
              <span class="text-gray-600 font-medium">Máxima:</span>
              <span id="statIdadeMax" class="text-lg font-bold text-red-600">-</span>
            </div>
            <div class="flex justify-between items-center py-2">
              <span class="text-gray-600 font-medium">Desvio Padrão:</span>
              <span id="statDesvioPadrao" class="text-lg font-bold text-purple-600">-</span>
            </div>
          </div>
        </div>

        <div class="card-elegant bg-white rounded-xl p-5 border-2 border-gray-200 shadow-md">
          <h3 class="text-xl font-bold text-gray-800 mb-4 flex items-center gap-2">
            <span>🏆</span>
            <span>Top 5 Escolas</span>
          </h3>
          <div id="top5Escolas" class="space-y-2">
            <div class="text-gray-400 text-center py-4">Carregando...</div>
          </div>
        </div>
      </div>

      <!-- Análise Temporal -->
      <div class="card-elegant bg-white rounded-xl p-5 border-2 border-gray-200 shadow-md">
        <h3 class="text-xl font-bold text-gray-800 mb-4 flex items-center gap-2">
          <span>📅</span>
          <span>Análise Temporal</span>
        </h3>
        <div class="grid grid-cols-1 md:grid-cols-3 gap-4">
          <div class="text-center p-4 bg-gradient-to-br from-blue-50 to-blue-100 rounded-lg border border-blue-200">
            <div class="text-sm text-gray-600 mb-1">Casos Este Mês</div>
            <div id="statCasosEsteMes" class="text-3xl font-bold text-blue-700">0</div>
          </div>
          <div class="text-center p-4 bg-gradient-to-br from-green-50 to-green-100 rounded-lg border border-green-200">
            <div class="text-sm text-gray-600 mb-1">Casos Mês Anterior</div>
            <div id="statCasosMesAnterior" class="text-3xl font-bold text-green-700">0</div>
          </div>
          <div
            class="text-center p-4 bg-gradient-to-br from-purple-50 to-purple-100 rounded-lg border border-purple-200">
            <div class="text-sm text-gray-600 mb-1">Variação</div>
            <div id="statVariacaoMensal" class="text-3xl font-bold text-purple-700">0%</div>
          </div>
        </div>
      </div>
    </section>

    <!-- ESTATÍSTICAS -->
    <section id="statsSection" class="card-elegant bg-white rounded-2xl shadow-xl p-6 mb-6 hidden fade-in"
      data-reveal="fade-up">
      <h2 class="text-2xl font-semibold text-gray-800 mb-4 flex items-center gap-2">
        <span class="text-3xl animate-float">📈</span>
        <span>Estatísticas</span>
      </h2>

      <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4">
        <div class="card-elegant bg-gradient-to-br from-blue-50 to-blue-100 rounded-xl p-5 border-2 border-blue-200"
          data-reveal="fade-left" data-stagger="40">
          <div class="text-gray-600 text-sm font-medium mb-2">Total de Registros</div>
          <div id="statTotal" class="text-4xl font-bold text-blue-700">0</div>
        </div>

        <div class="card-elegant bg-gradient-to-br from-green-50 to-green-100 rounded-xl p-5 border-2 border-green-200"
          data-reveal="fade-up" data-stagger="40">
          <div class="text-gray-600 text-sm font-medium mb-2">Registros Filtrados</div>
          <div id="statFiltrados" class="text-4xl font-bold text-green-700">0</div>
        </div>

        <div class="card-elegant bg-gradient-to-br from-amber-50 to-amber-100 rounded-xl p-5 border-2 border-amber-200"
          data-reveal="fade-up" data-stagger="40">
          <div class="text-gray-600 text-sm font-medium mb-2">Ocorreram na Escola</div>
          <div id="statEscola" class="text-4xl font-bold text-amber-700">0</div>
        </div>

        <div
          class="card-elegant bg-gradient-to-br from-purple-50 to-purple-100 rounded-xl p-5 border-2 border-purple-200"
          data-reveal="fade-right" data-stagger="40">
          <div class="text-gray-600 text-sm font-medium mb-2">Tipos de Violência</div>
          <div id="statTipos" class="text-sm text-purple-700 mt-1 max-h-20 overflow-y-auto scrollbar-elegant"></div>
        </div>
      </div>
    </section>

    <!-- GRÁFICOS -->
    <section id="chartsSection" class="bg-white rounded-2xl shadow-xl p-6 mb-6 hidden fade-in" data-reveal="fade-up">
      <h2 class="text-2xl font-semibold text-gray-800 mb-6">📊 Gráficos Dinâmicos</h2>

      <div class="grid grid-cols-1 lg:grid-cols-2 gap-6">

        <!-- Gráfico: Tipos de Violência -->
        <div class="bg-gray-50 rounded-lg p-4 border border-gray-200" data-reveal="zoom-in" data-stagger="60">
          <div class="flex justify-between items-center mb-4">
            <h3 class="text-lg font-semibold text-gray-700">Tipos de Violência</h3>
            <button id="btnToggleChartType"
              class="p-1 px-2 text-xs bg-white border border-gray-300 rounded hover:bg-gray-50 transition-colors text-gray-600 shadow-sm"
              title="Alternar visualização">
              Mudar para Barras
            </button>
          </div>
          <div class="relative" style="height: 300px;">
            <canvas id="chartTipoViolencia"></canvas>
          </div>
        </div>

        <!-- Gráfico: Tipos de Violência Institucional -->
        <div id="containerChartViolenciaInstitucional"
          class="bg-gradient-to-br from-orange-50 to-red-50 rounded-lg p-4 border border-orange-200 hidden"
          data-reveal="zoom-in" data-stagger="60">
          <div class="flex justify-between items-center mb-4">
            <h3 class="text-lg font-semibold text-orange-700">🏛️ Violência Institucional</h3>
            <button id="btnToggleChartInstType"
              class="p-1 px-2 text-xs bg-white border border-orange-200 rounded hover:bg-orange-50 transition-colors text-orange-700 shadow-sm"
              title="Alternar visualização">
              Mudar para Barras
            </button>
          </div>
          <div class="relative" style="height: 300px;">
            <canvas id="chartTipoViolenciaInstitucional"></canvas>
          </div>
        </div>

        <!-- Gráfico: Por Região -->
        <div class="bg-gray-50 rounded-lg p-4 border border-gray-200" data-reveal="zoom-in" data-stagger="60">
          <h3 class="text-lg font-semibold text-gray-700 mb-4">Casos por Região</h3>
          <div class="relative" style="height: 300px;">
            <canvas id="chartRegiao"></canvas>
          </div>
        </div>

        <!-- Gráfico: Por Escola -->
        <div class="bg-slate-50 rounded-lg p-4 border border-slate-200" data-reveal="zoom-in" data-stagger="60">
          <h3 class="text-lg font-semibold text-slate-700 mb-4">Top 10 Escolas</h3>
          <div class="relative" style="height: 300px;">
            <canvas id="chartEscola"></canvas>
          </div>
        </div>

        <!-- Gráfico: Por Faixa Etária -->
        <div class="bg-slate-50 rounded-lg p-4 border border-slate-200" data-reveal="zoom-in" data-stagger="60">
          <h3 class="text-lg font-semibold text-slate-700 mb-4">Faixa Etária</h3>
          <div class="relative" style="height: 300px;">
            <canvas id="chartIdade"></canvas>
          </div>
        </div>

        <!-- Gráfico: Por Gênero -->
        <div class="bg-slate-50 rounded-lg p-4 border border-slate-200" data-reveal="zoom-in" data-stagger="60">
          <h3 class="text-lg font-semibold text-slate-700 mb-4">Gênero (M/F)</h3>
          <div class="relative" style="height: 300px;">
            <canvas id="chartGenero"></canvas>
          </div>
        </div>

        <!-- Gráfico: Por Raça/Cor -->
        <div class="bg-slate-50 rounded-lg p-4 border border-slate-200" data-reveal="zoom-in" data-stagger="60">
          <h3 class="text-lg font-semibold text-slate-700 mb-4">Raça/Cor</h3>
          <div class="relative" style="height: 300px;">
            <canvas id="chartRaca"></canvas>
          </div>
        </div>

        <!-- Gráfico: Linha do Tempo -->
        <div class="bg-slate-50 rounded-lg p-4 border border-slate-200 lg:col-span-2" data-reveal="zoom-in"
          data-stagger="60">
          <h3 class="text-lg font-semibold text-slate-700 mb-4">Linha do Tempo (Por Mês)</h3>
          <div class="relative" style="height: 300px;">
            <canvas id="chartTemporal"></canvas>
          </div>
        </div>

        <!-- Gráfico: Encaminhamentos -->
        <div
          class="bg-gradient-to-br from-slate-50 to-blue-50 rounded-xl p-5 border-2 border-slate-200 shadow-lg hover:shadow-xl transition-all duration-300 card-hover lg:col-span-2"
          data-reveal="zoom-in" data-stagger="60">
          <h3 class="text-xl font-bold text-slate-800 mb-4 flex items-center gap-2">
            <span class="text-2xl">📊</span>
            <span>Encaminhamentos por Rede</span>
          </h3>
          <div class="relative" style="height: 320px;">
            <canvas id="chartEncaminhamento"></canvas>
          </div>
        </div>

        <!-- Gráfico: Autor da Violência -->
        <div
          class="bg-gradient-to-br from-slate-50 to-purple-50 rounded-xl p-5 border-2 border-slate-200 shadow-lg hover:shadow-xl transition-all duration-300 card-hover"
          data-reveal="zoom-in" data-stagger="60">
          <h3 class="text-xl font-bold text-slate-800 mb-4 flex items-center gap-2">
            <span class="text-2xl">👤</span>
            <span>Autor da Violência</span>
          </h3>
          <div class="relative" style="height: 300px;">
            <canvas id="chartAutor"></canvas>
          </div>
        </div>

        <!-- Gráfico: Ocorreu na Escola? -->
        <div
          class="bg-gradient-to-br from-slate-50 to-green-50 rounded-xl p-5 border-2 border-slate-200 shadow-lg hover:shadow-xl transition-all duration-300 card-hover"
          data-reveal="zoom-in" data-stagger="60">
          <h3 class="text-xl font-bold text-slate-800 mb-4 flex items-center gap-2">
            <span class="text-2xl">🏫</span>
            <span>Ocorreu na Escola?</span>
          </h3>
          <div class="relative" style="height: 300px;">
            <canvas id="chartOcorreuEscola"></canvas>
          </div>
        </div>

        <!-- Gráfico: Correlação Tipo de Violência vs Faixa Etária -->
        <div
          class="bg-gradient-to-br from-indigo-50 to-purple-50 rounded-xl p-5 border-2 border-indigo-200 shadow-lg hover:shadow-xl transition-all duration-300 card-hover lg:col-span-2"
          data-reveal="zoom-in" data-stagger="60">
          <h3 class="text-xl font-bold text-slate-800 mb-4 flex items-center gap-2">
            <span class="text-2xl">🔗</span>
            <span>Correlação: Tipo de Violência vs Faixa Etária</span>
          </h3>
          <div class="relative" style="height: 350px;">
            <canvas id="chartCorrelacaoTipoIdade"></canvas>
          </div>
        </div>

        <!-- Gráfico: Comparativo Temporal (Últimos 6 Meses vs Período Anterior) -->
        <div
          class="bg-gradient-to-br from-amber-50 to-orange-50 rounded-xl p-5 border-2 border-amber-200 shadow-lg hover:shadow-xl transition-all duration-300 card-hover lg:col-span-2"
          data-reveal="zoom-in" data-stagger="60">
          <h3 class="text-xl font-bold text-slate-800 mb-4 flex items-center gap-2">
            <span class="text-2xl">📊</span>
            <span>Comparativo Temporal: Últimos 6 Meses vs Período Anterior</span>
          </h3>
          <div class="relative" style="height: 350px;">
            <canvas id="chartComparativoTemporal"></canvas>
          </div>
        </div>

        <!-- Gráfico: Tendência Anual (Comparação Ano Atual vs Ano Anterior) -->
        <div
          class="bg-gradient-to-br from-teal-50 to-cyan-50 rounded-xl p-5 border-2 border-teal-200 shadow-lg hover:shadow-xl transition-all duration-300 card-hover lg:col-span-2"
          data-reveal="zoom-in" data-stagger="60">
          <h3 class="text-xl font-bold text-slate-800 mb-4 flex items-center gap-2">
            <span class="text-2xl">📈</span>
            <span>Tendência Anual: Comparação Mês a Mês</span>
          </h3>
          <div class="relative" style="height: 350px;">
            <canvas id="chartTendenciaAnual"></canvas>
          </div>
        </div>

      </div>
    </section>

    <!-- RESULTADOS -->
    <section id="resultsSection" class="bg-white rounded-2xl shadow-xl p-6 hidden fade-in">
      <div class="flex items-center justify-between mb-6 pb-4 border-b-2 border-gray-200">
        <h2 class="text-3xl font-bold text-gray-800 flex items-center gap-3">
          <span class="text-4xl">📋</span>
          <span>Registros</span>
          <span
            class="inline-flex items-center px-3 py-1 rounded-full text-sm font-semibold bg-blue-100 text-blue-800 border border-blue-200">
            <span id="recordCount">0</span>
          </span>
        </h2>
      </div>

      <div id="noResultsMessage" class="hidden p-6 text-center text-gray-500">⚠️ Nenhum registro encontrado com os
        filtros atuais.</div>

      <div id="tableContainer" data-tour="tabela" class="overflow-x-auto rounded-lg border border-gray-200 shadow-sm">
        <table class="min-w-full border-collapse text-sm">
          <thead class="bg-gradient-to-r from-blue-50 via-indigo-50 to-purple-50 sticky top-0 shadow-sm">
            <tr>
              <th
                class="px-4 py-3.5 text-left text-xs font-semibold uppercase tracking-wide text-gray-700 border-b-2 border-blue-200">
                👤 Criança/Estudante</th>
              <th
                class="px-4 py-3.5 text-left text-xs font-semibold uppercase tracking-wide text-gray-700 border-b-2 border-indigo-200">
                📅 Idade</th>
              <th
                class="px-4 py-3.5 text-left text-xs font-semibold uppercase tracking-wide text-gray-700 border-b-2 border-purple-200">
                🗓️ Data</th>
              <th
                class="px-4 py-3.5 text-left text-xs font-semibold uppercase tracking-wide text-gray-700 border-b-2 border-blue-200">
                ⚠️ Tipo de Violência</th>
              <th
                class="px-4 py-3.5 text-left text-xs font-semibold uppercase tracking-wide text-gray-700 border-b-2 border-indigo-200">
                🏫 CMEI/EMEF</th>
              <th
                class="px-4 py-3.5 text-left text-xs font-semibold uppercase tracking-wide text-gray-700 border-b-2 border-purple-200">
                📍 Região</th>
              <th
                class="px-4 py-3.5 text-left text-xs font-semibold uppercase tracking-wide text-gray-700 border-b-2 border-blue-200">
                📋 Encaminhamento</th>
              <th
                class="px-4 py-3.5 text-left text-xs font-semibold uppercase tracking-wide text-gray-700 border-b-2 border-indigo-200">
                ✓ Na Escola?</th>
              <th
                class="px-4 py-3.5 text-center text-xs font-semibold uppercase tracking-wide text-gray-700 border-b-2 border-purple-200">
                🔍 Ações</th>
            </tr>
          </thead>
          <tbody id="tableBody" class="bg-white divide-y divide-slate-200"></tbody>
        </table>
      </div>

      <!-- Controles de Paginação Modernos -->
      <div id="paginacao"
        class="mt-6 flex flex-col sm:flex-row items-center justify-between gap-4 px-6 py-4 bg-gradient-to-r from-gray-50 to-gray-100 rounded-lg border border-gray-200 shadow-sm">
        <div class="flex items-center gap-3">
          <span class="text-sm font-medium text-gray-700">📄 Exibir:</span>
          <select id="registrosPorPaginaSelect"
            class="px-3 py-2 bg-white border-2 border-gray-300 rounded-lg text-sm font-medium text-gray-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500 transition-all hover:border-gray-400 cursor-pointer shadow-sm">
            <option value="5">5 registros</option>
            <option value="10" selected>10 registros</option>
            <option value="25">25 registros</option>
            <option value="50">50 registros</option>
            <option value="100">100 registros</option>
          </select>
        </div>

        <div class="flex items-center gap-2 px-4 py-2 bg-white rounded-lg shadow-sm border border-slate-200">
          <span class="text-xs font-medium text-slate-500 uppercase tracking-wide">Página</span>
          <span id="paginacaoInfo" class="text-sm font-bold text-slate-700 px-2">1 de 1</span>
        </div>

        <div class="flex items-center gap-1.5">
          <button id="btnPrimeiraPagina"
            class="group px-3 py-2 text-sm font-medium text-slate-600 bg-white border-2 border-slate-300 rounded-lg hover:bg-blue-50 hover:border-blue-500 hover:text-blue-600 disabled:opacity-40 disabled:cursor-not-allowed disabled:hover:bg-white disabled:hover:border-slate-300 disabled:hover:text-slate-600 transition-all duration-200 shadow-sm hover:shadow-md"
            disabled title="Primeira página">
            <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M11 19l-7-7 7-7m8 14l-7-7 7-7">
              </path>
            </svg>
          </button>
          <button id="btnPaginaAnterior"
            class="group px-4 py-2 text-sm font-medium text-gray-600 bg-white border-2 border-gray-300 rounded-lg hover:bg-blue-50 hover:border-blue-500 hover:text-blue-600 disabled:opacity-40 disabled:cursor-not-allowed disabled:hover:bg-white disabled:hover:border-gray-300 disabled:hover:text-gray-600 transition-all duration-200 shadow-sm hover:shadow-md flex items-center gap-1.5"
            disabled title="Página anterior">
            <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7"></path>
            </svg>
            <span class="hidden sm:inline">Anterior</span>
          </button>
          <button id="btnProximaPagina"
            class="group px-4 py-2 text-sm font-medium text-slate-600 bg-white border-2 border-slate-300 rounded-lg hover:bg-blue-50 hover:border-blue-500 hover:text-blue-600 disabled:opacity-40 disabled:cursor-not-allowed disabled:hover:bg-white disabled:hover:border-slate-300 disabled:hover:text-slate-600 transition-all duration-200 shadow-sm hover:shadow-md flex items-center gap-1.5"
            title="Próxima página">
            <span class="hidden sm:inline">Próxima</span>
            <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"></path>
            </svg>
          </button>
          <button id="btnUltimaPagina"
            class="group px-3 py-2 text-sm font-medium text-slate-600 bg-white border-2 border-slate-300 rounded-lg hover:bg-blue-50 hover:border-blue-500 hover:text-blue-600 disabled:opacity-40 disabled:cursor-not-allowed disabled:hover:bg-white disabled:hover:border-slate-300 disabled:hover:text-slate-600 transition-all duration-200 shadow-sm hover:shadow-md"
            title="Última página">
            <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 5l7 7-7 7M5 5l7 7-7 7">
              </path>
            </svg>
          </button>
        </div>
      </div>
    </section>

    </main>


    <script>
      // ==============================
      // Variáveis globais
      // ==============================
      let originalData = [];
      let filteredData = [];
      let columnNames = {};
      let charts = {}; // Armazena instâncias dos gráficos

      // Expõe variáveis globalmente para dashboard-stats.js
      window.originalData = originalData;
      window.filteredData = filteredData;
      window.columnNames = columnNames;

      // Variáveis de paginação (frontend-only)
      let paginaAtual = 1;
      let registrosPorPagina = 10;
      let totalPaginas = 1;

      // Dados CSV inline das listas de CMEIs e EMEFs
      const CSV_CMEIS = `Nome,Sigla
Adácio Bispo dos Santos TI,ABS
Álvaro Fernandes Lima TI,AFL
Ana Maria Chaves Colares,AMCC
Anízio Spínola Teixeira,AST
Carlos Alberto Martinelli de Souza TI,EAMS
Carlita Corrêa Pereira TI,CCP
Carlos Mendes,CM
Darcy Castello de Mendonça,DCM
Dom. João Batista da Motta e Albuquerque TI,JBMA
Dr. Denizart Santos TI,DS
Darcy Vargas,DV
Edlma Maria Soares Braga TTI,EMSB
Ernestina Pessoa,EP
Gilda de Athayde Ramos,GAR
Gisela da Cruz Militão,GCM
Georgiana da Trindade Faria,GTF
Hecy Alves Fraga TI,HAF
Jacivinha Ferreira de Souza Simões TI,JFSS
Juízo Pedro de Aguiar,JPA
Luiz Carlos Grecco TI,LCG
Laurentina Mendonça Corrêa,LMC
Luíza Pereira Muniz Corrêa TI,LPMC
Lidia Rocha Feitosa,LRF
Lisandra Ignes Carpanedo do Carmo,LICC
Magnólia Dias Miranda Cunha TTI,MUMC
Maria Goretti Coutinho Cosme TI,MGCC
Menino Jesus TI,MJ
Maria Nazareth Menegueli TTI,MNM
Marlene Dilande Simonetti,MDS
Nalcyrley Silva Braga,NSB
Oscalina Nunes Andrade,ONA
Odila Simões,OS
Professora Cida Barreto,PCB
Dr. Pedro Feu Rosa,PFR
Padre Giovanni Bartesaghi TTI,PGB
Rubem Braga,RB
Rubens Duarte de Albuquerque TTI,RDA
Robson José Nassur Peçoto TI,RJNP
Rubens José Vervloet Gomes TI,RJVG
Reinaldo Ridolfi,RR
Professora Sophia Musengiyvi Loureiro,SML
Sinclair Phillips,SP
Silvanete da Silva Rosa Rocha TI,SSRR
Thomas Tommasi TTI,TT
Terezinha Vasconcellos Salvador,TVS
Valdivia de Penna Antunes Rodrigues TI,VPAR
Yolanda Lucas da Silva,VLS
Zilmar Alves de Melo,ZAM
Zulmira Gomes Martins Marcarini Cavalcanti,ZGMC
Zélia Viana de Aguiar,ZVA`;

      const CSV_EMEFS = `Nome,Sigla
Alberto de Almeida,AA
Adão Benezath,AB
Aristóbulo Barbosa Leão,ABL
Álvaro de Castro Mattos,ACM
Arthur da Costa e Silva,ACS
Amilton Monteiro da Silva,AMS
Alvimar Silva,AS
Adilson da Silva Castro,ASC
Adevalni Sysesmundo Ferreira de Azevedo,ASFA
Anacleta Schneider Lucas TI,ASLC
Ceciliano Abel de Almeida,CAA
Castelo Branco,CB
Custódia Dias de Campos,CDC
CEJA Prof. Admardo Serafim de Oliveira,EJA ASO
Éber Louzada Zippinotti,ELZ
Edna de Mattos Siqueira Gaudio TI,EMSG
Eunice Perreira Silveira TI,EPS
Eliane Rodrigues dos Santos,ERS
Escola Experimental de Vitória-UFES,UFES
Elzira Vivacqua dos Santos,EVS
Francisco Lacerda de Aguiar,FLA
Heloisa Abreu Júdice de Mattos,HAJM
Irmã Jacinta Soares de Souza Lima,IJSSL
Izaura Marques da Silva TI,IMS
José Áureo Monjardim TI,JAM
João Bandeira,JB
Juscelino Kubitschek de Oliveira,JKO
José Lemos de Miranda TI,JLM
Lenir Borlot,LB
Moacyr Avidos TI,MA
Mauro Braga,MB
Marieta Escobar,ME
Maria José Costa Moraes,MJCM
Maria Leonor Pereira da Silva,MLPS
Marechal Mascarenhas de Moraes,MMM
Maria Madalena Oliveira Domingues,MMOD
Maria Stella de Novaes,MSN
Neusa Nunes Gonçalves,NNG
Orlandina D'Almeida Lucas,ODAL
Otto Ewald Júnior,OEJ
Octacílio Lomba,OL
Prezideu Amorim,PA
Padre Anchieta,PAN
Padre Guido Ceotto,PGC
Paulo Reglus Neves Freire TI,PRNF
Paulo Roberto Vieira Gomes,PRVG
Rita de Cássia Oliveira,RCO
Regina Maria Silva,RMS
Ronaldo Soares,RS
Suzete Cuendet,SC
São Vicente de Paulo,SVP
Tancredo de Almeida Neves,TAN
Vercenílio da Silva Pascoal,VSP
Zilda Andrade,ZA`;

      // Função para processar os CSVs e criar os mapeamentos
      function processarCSVs() {
        const linhasCMEI = CSV_CMEIS.split('\n').slice(1); // Remove header
        const linhasEMEF = CSV_EMEFS.split('\n').slice(1); // Remove header

        const cmeiSiglas = {};
        const emefSiglas = {};

        linhasCMEI.forEach(linha => {
          const partes = linha.split(',');
          if (partes.length >= 2) {
            const sigla = partes[1].trim();
            const nome = partes[0].trim();
            if (sigla && nome) {
              cmeiSiglas[sigla] = nome;
            }
          }
        });

        linhasEMEF.forEach(linha => {
          const partes = linha.split(',');
          if (partes.length >= 2) {
            const sigla = partes[1].trim();
            const nome = partes[0].trim();
            if (sigla && nome) {
              emefSiglas[sigla] = nome;
            }
          }
        });

        return { cmeiSiglas, emefSiglas };
      }

      // Processa os CSVs e cria os mapeamentos
      const { cmeiSiglas: CMEI_SIGLAS, emefSiglas: EMEF_SIGLAS } = processarCSVs();

      // ==============================
      // Função auxiliar: Detecta se escola é Tempo Integral
      // ==============================
      function isTempoIntegral(escolaValor) {
        if (!escolaValor) return false;

        const sigla = String(escolaValor).trim().toUpperCase();
        let nomeCompleto = null;

        // Tenta achar nas listas de siglas
        if (CMEI_SIGLAS[sigla]) {
          nomeCompleto = CMEI_SIGLAS[sigla];
        } else if (EMEF_SIGLAS[sigla]) {
          nomeCompleto = EMEF_SIGLAS[sigla];
        } else {
          // Fallback: usa o próprio valor caso a planilha um dia venha com nome em vez de sigla
          nomeCompleto = String(escolaValor).trim();
        }

        const nomeUpper = nomeCompleto.toUpperCase();

        // Tempo Integral: nome completo termina com " TI" ou " TTI"
        return nomeUpper.endsWith(' TI') || nomeUpper.endsWith(' TTI');
      }

      // ==============================
      // Utilitários de texto / listas
      // ==============================

      // Normalização para reduzir erro de digitação: tira acento, pontuação, caixa
      // IMPORTANTE: Preserva a barra (/) para tipos compostos como "Financeira/Econômica"
      function normalizeText(str) {
        return String(str || '')
          .normalize('NFD')
          .replace(/[\u0300-\u036f]/g, '')
          .toLowerCase()
          .replace(/[^a-z0-9\s\/]/g, ' ') // ← Preserva / além de letras, números e espaços
          .replace(/\s+/g, ' ')
          .trim();
      }

      // Identifica se uma escola é EMEF ou CMEI baseado no nome/sigla
      function getTipoInstituicao(nomeEscola) {
        if (!nomeEscola) return null;

        const nome = String(nomeEscola).trim().toUpperCase();

        // Verifica se é uma sigla exata de EMEF
        if (EMEF_SIGLAS[nome]) {
          return 'EMEF';
        }

        // Verifica se é uma sigla exata de CMEI
        if (CMEI_SIGLAS[nome]) {
          return 'CMEI';
        }

        // Verifica se o nome contém a sigla como palavra isolada (EMEF)
        for (const sigla in EMEF_SIGLAS) {
          const regex = new RegExp('\\b' + sigla + '\\b', 'i');
          if (regex.test(nome)) {
            return 'EMEF';
          }
        }

        // Verifica se o nome contém a sigla como palavra isolada (CMEI)
        for (const sigla in CMEI_SIGLAS) {
          const regex = new RegExp('\\b' + sigla + '\\b', 'i');
          if (regex.test(nome)) {
            return 'CMEI';
          }
        }

        // Verifica se contém "EMEF" no nome
        if (nome.includes('EMEF')) {
          return 'EMEF';
        }

        // Verifica se contém "CMEI" no nome
        if (nome.includes('CMEI')) {
          return 'CMEI';
        }

        // Se não identificou, retorna null
        return null;
      }

      // Converte sigla para nome completo (se for uma EMEF ou CMEI conhecida)
      function getDisplayName(nomeEscola) {
        if (!nomeEscola) return '';

        const nome = String(nomeEscola).trim().toUpperCase();

        // Se for uma sigla exata de EMEF, retorna "EMEF Sigla"
        if (EMEF_SIGLAS[nome]) {
          return `EMEF ${nome}`;
        }

        // Se for uma sigla exata de CMEI, retorna "CMEI Sigla"
        if (CMEI_SIGLAS[nome]) {
          return `CMEI ${nome}`;
        }

        return nomeEscola;
      }

      // ==============================
      // Sistema de Grupos de Encaminhamento
      // ==============================

      // Definição dos grupos de encaminhamento
      const encaminhamentosAgrupados = {
        redeAssistencia: ['Assistência Social', 'CRAS', 'CREAS', 'Casa Rosa', 'Psicólogo'],
        redeSaude: ['Saúde', 'UBS', 'US', 'CAPSIN'],
        redeEducacao: ['NAAM', 'Educação', 'Escola'],
        conselhoTutelar: ['CT'],
        redeSegurancaJustica: ['DACLE', 'DEAM', 'DEPI', 'DPCA', 'Defensoria Pública', 'Ministério Público', 'Outras delegacias']
      };

      // Nomes amigáveis dos grupos
      const grupoNomes = {
        redeAssistencia: 'Rede de Assistência Social',
        redeSaude: 'Rede de Saúde',
        redeEducacao: 'Rede de Educação',
        conselhoTutelar: 'Conselho Tutelar',
        redeSegurancaJustica: 'Rede de Segurança e Justiça'
      };

      // Verifica se um termo pertence a algum grupo
      function belongsToAnyGroup(term) {
        const termNorm = normalizeText(term);
        for (const groupKey in encaminhamentosAgrupados) {
          const children = encaminhamentosAgrupados[groupKey];
          if (children.some(child => normalizeText(child) === termNorm)) {
            return true;
          }
        }
        return false;
      }

      // Constrói os grupos de encaminhamento baseado nos dados reais
      function buildEncaminhamentoGroups(availableEncaminhamentos) {
        const container = document.getElementById('filterEncaminhamentoContainer');
        container.innerHTML = '';

        // Normalizar availableEncaminhamentos para comparação
        const availableNormalized = availableEncaminhamentos.map(e => normalizeText(e));

        // Construir cada grupo
        for (const groupKey in encaminhamentosAgrupados) {
          const children = encaminhamentosAgrupados[groupKey];

          // Filtrar apenas os filhos que existem nos dados
          const childrenPresent = children.filter(child =>
            availableNormalized.includes(normalizeText(child))
          );

          // Se não há filhos presentes, não renderizar o grupo
          if (childrenPresent.length === 0) continue;

          // Renderizar o grupo
          renderEncaminhamentoGroup(groupKey, childrenPresent);
        }

        // Identificar encaminhamentos não mapeados ("Outros detectados")
        const outrosDetectados = availableEncaminhamentos.filter(term => !belongsToAnyGroup(term));

        if (outrosDetectados.length > 0) {
          renderOutrosDetectados(outrosDetectados);
        }
      }

      // Renderiza um grupo de encaminhamento
      function renderEncaminhamentoGroup(groupId, childrenPresent) {
        const container = document.getElementById('filterEncaminhamentoContainer');
        const groupName = grupoNomes[groupId] || groupId;

        // Criar estrutura do grupo
        const groupDiv = document.createElement('div');
        groupDiv.className = 'encaminhamento-group';
        groupDiv.dataset.group = groupId;

        // Header do grupo
        const header = document.createElement('div');
        header.className = 'group-header';
        header.onclick = () => toggleGroupPanel(groupId);

        const headerLeft = document.createElement('div');
        headerLeft.className = 'group-header-left';

        // Checkbox do grupo
        const checkboxWrapper = document.createElement('div');
        checkboxWrapper.className = 'group-checkbox-wrapper';

        const groupCheckbox = document.createElement('input');
        groupCheckbox.type = 'checkbox';
        groupCheckbox.id = `group-${groupId}`;
        groupCheckbox.className = 'custom-checkbox';
        groupCheckbox.onclick = (e) => e.stopPropagation();
        groupCheckbox.onchange = () => onGroupCheckboxChange(groupId);

        checkboxWrapper.appendChild(groupCheckbox);

        // Título do grupo
        const title = document.createElement('span');
        title.className = 'group-title';
        title.textContent = groupName;

        headerLeft.appendChild(checkboxWrapper);
        headerLeft.appendChild(title);

        // Badge de contagem
        const badge = document.createElement('span');
        badge.id = `badge-${groupId}`;
        badge.className = 'group-badge hidden';
        badge.textContent = '0';

        // Ícone de toggle
        const toggleIcon = document.createElement('svg');
        toggleIcon.id = `toggle-${groupId}`;
        toggleIcon.className = 'toggle-icon';
        toggleIcon.setAttribute('fill', 'none');
        toggleIcon.setAttribute('stroke', 'currentColor');
        toggleIcon.setAttribute('viewBox', '0 0 24 24');
        toggleIcon.innerHTML = '<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path>';

        header.appendChild(headerLeft);
        header.appendChild(badge);
        header.appendChild(toggleIcon);

        // Body do grupo (conteúdo colapsável)
        const body = document.createElement('div');
        body.id = `body-${groupId}`;
        body.className = 'group-body';

        const bodyContent = document.createElement('div');
        bodyContent.className = 'group-body-content';

        // Criar checkboxes dos filhos
        childrenPresent.forEach((child, index) => {
          const childDiv = document.createElement('div');
          childDiv.className = 'checkbox-container flex items-center gap-2.5 p-2.5 bg-gray-50 rounded-lg border border-gray-200';

          const childCheckbox = document.createElement('input');
          childCheckbox.type = 'checkbox';
          childCheckbox.id = `${groupId}_child_${index}`;
          childCheckbox.className = 'custom-checkbox';
          childCheckbox.dataset.value = child;
          childCheckbox.dataset.group = groupId;
          childCheckbox.onchange = () => onChildCheckboxChange(groupId);

          const label = document.createElement('label');
          label.htmlFor = `${groupId}_child_${index}`;
          label.className = 'checkbox-label flex-1 text-gray-700 text-sm cursor-pointer';
          label.textContent = child;

          childDiv.appendChild(childCheckbox);
          childDiv.appendChild(label);
          bodyContent.appendChild(childDiv);
        });

        body.appendChild(bodyContent);

        groupDiv.appendChild(header);
        groupDiv.appendChild(body);
        container.appendChild(groupDiv);
      }

      // Renderiza grupo "Outros detectados"
      function renderOutrosDetectados(termos) {
        const container = document.getElementById('filterEncaminhamentoContainer');
        const groupId = 'outrosDetectados';

        const groupDiv = document.createElement('div');
        groupDiv.className = 'encaminhamento-group outros-detectados';
        groupDiv.dataset.group = groupId;

        const header = document.createElement('div');
        header.className = 'group-header';
        header.onclick = () => toggleGroupPanel(groupId);

        const headerLeft = document.createElement('div');
        headerLeft.className = 'group-header-left';

        const checkboxWrapper = document.createElement('div');
        checkboxWrapper.className = 'group-checkbox-wrapper';

        const groupCheckbox = document.createElement('input');
        groupCheckbox.type = 'checkbox';
        groupCheckbox.id = `group-${groupId}`;
        groupCheckbox.className = 'custom-checkbox';
        groupCheckbox.onclick = (e) => e.stopPropagation();
        groupCheckbox.onchange = () => onGroupCheckboxChange(groupId);

        checkboxWrapper.appendChild(groupCheckbox);

        const title = document.createElement('span');
        title.className = 'group-title';
        title.textContent = '⚠️ Outros detectados';

        headerLeft.appendChild(checkboxWrapper);
        headerLeft.appendChild(title);

        const badge = document.createElement('span');
        badge.id = `badge-${groupId}`;
        badge.className = 'group-badge hidden';
        badge.textContent = '0';

        const toggleIcon = document.createElement('svg');
        toggleIcon.id = `toggle-${groupId}`;
        toggleIcon.className = 'toggle-icon';
        toggleIcon.setAttribute('fill', 'none');
        toggleIcon.setAttribute('stroke', 'currentColor');
        toggleIcon.setAttribute('viewBox', '0 0 24 24');
        toggleIcon.innerHTML = '<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path>';

        header.appendChild(headerLeft);
        header.appendChild(badge);
        header.appendChild(toggleIcon);

        const body = document.createElement('div');
        body.id = `body-${groupId}`;
        body.className = 'group-body';

        const bodyContent = document.createElement('div');
        bodyContent.className = 'group-body-content';

        termos.forEach((termo, index) => {
          const childDiv = document.createElement('div');
          childDiv.className = 'checkbox-container flex items-center gap-2.5 p-2.5 bg-amber-50 rounded-lg border border-amber-300';

          const childCheckbox = document.createElement('input');
          childCheckbox.type = 'checkbox';
          childCheckbox.id = `${groupId}_child_${index}`;
          childCheckbox.className = 'custom-checkbox';
          childCheckbox.dataset.value = termo;
          childCheckbox.dataset.group = groupId;
          childCheckbox.onchange = () => onChildCheckboxChange(groupId);

          const label = document.createElement('label');
          label.htmlFor = `${groupId}_child_${index}`;
          label.className = 'checkbox-label flex-1 text-gray-700 text-sm cursor-pointer';
          label.textContent = termo;

          childDiv.appendChild(childCheckbox);
          childDiv.appendChild(label);
          bodyContent.appendChild(childDiv);
        });

        body.appendChild(bodyContent);

        groupDiv.appendChild(header);
        groupDiv.appendChild(body);
        container.appendChild(groupDiv);
      }

      // Toggle panel de um grupo
      function toggleGroupPanel(groupId) {
        const body = document.getElementById(`body-${groupId}`);
        const icon = document.getElementById(`toggle-${groupId}`);

        if (body && icon) {
          body.classList.toggle('expanded');
          icon.classList.toggle('rotated');
        }
      }

      // Handler quando checkbox de grupo muda
      function onGroupCheckboxChange(groupId) {
        const groupCheckbox = document.getElementById(`group-${groupId}`);
        const childCheckboxes = document.querySelectorAll(`input[data-group="${groupId}"]`);

        // Marcar/desmarcar todos os filhos
        childCheckboxes.forEach(child => {
          child.checked = groupCheckbox.checked;
        });

        updateGroupBadge(groupId);
        updateBadgeEncaminhamentoTotal();
        applyFilters();
      }

      // Handler quando checkbox de filho muda
      function onChildCheckboxChange(groupId) {
        const groupCheckbox = document.getElementById(`group-${groupId}`);
        const childCheckboxes = document.querySelectorAll(`input[data-group="${groupId}"]`);

        const allChecked = Array.from(childCheckboxes).every(cb => cb.checked);
        const someChecked = Array.from(childCheckboxes).some(cb => cb.checked);

        // Atualizar estado do grupo (checked, indeterminate, unchecked)
        groupCheckbox.checked = allChecked;
        groupCheckbox.indeterminate = someChecked && !allChecked;

        updateGroupBadge(groupId);
        updateBadgeEncaminhamentoTotal();
        applyFilters();
      }

      // Atualiza badge de um grupo específico
      function updateGroupBadge(groupId) {
        const childCheckboxes = document.querySelectorAll(`input[data-group="${groupId}"]:checked`);
        const count = childCheckboxes.length;
        const badge = document.getElementById(`badge-${groupId}`);

        if (badge) {
          if (count > 0) {
            badge.textContent = count;
            badge.classList.remove('hidden');
          } else {
            badge.classList.add('hidden');
          }
        }
      }

      // Atualiza badge total de encaminhamento
      function updateBadgeEncaminhamentoTotal() {
        const allChildCheckboxes = document.querySelectorAll('#filterEncaminhamentoContainer input[data-group]:checked');
        const count = allChildCheckboxes.length;
        const badge = document.getElementById('badge-encaminhamento-total');

        if (badge) {
          if (count > 0) {
            badge.textContent = count;
            badge.classList.remove('hidden');
          } else {
            badge.classList.add('hidden');
          }
        }
      }

      // ==============================
      // Sistema de Grupos de Violências Institucionais
      // ==============================

      // Definição dos grupos de violências institucionais (similar aos encaminhamentos)
      const violenciasInstitucionaisAgrupadas = {
        fisica: ['Física', 'Fisica'],
        psicologica: ['Psicológica', 'Psicologica', 'Psicológica/Moral'],
        sexual: ['Sexual', 'Abuso Sexual'],
        verbal: ['Verbal', 'Verbal/Moral'],
        negligencia: ['Negligência', 'Negligencia', 'Negligência/Abandono'],
        patrimonial: ['Patrimonial', 'Patrimonial/Econômica'],
        bullying: ['Bullying', 'Bullying/Cyberbullying'],
        outras: ['Outras', 'Outros']
      };

      // Nomes amigáveis dos grupos
      const grupoNomesViolenciaInstitucional = {
        fisica: 'Violência Física',
        psicologica: 'Violência Psicológica',
        sexual: 'Violência Sexual',
        verbal: 'Violência Verbal',
        negligencia: 'Negligência',
        patrimonial: 'Violência Patrimonial',
        bullying: 'Bullying/Cyberbullying',
        outras: 'Outras Violências Institucionais'
      };

      // Verifica se um termo pertence a algum grupo
      function belongsToAnyGroupViolenciaInstitucional(term) {
        const termNorm = normalizeText(term);
        for (const groupKey in violenciasInstitucionaisAgrupadas) {
          const children = violenciasInstitucionaisAgrupadas[groupKey];
          if (children.some(child => normalizeText(child) === termNorm)) {
            return true;
          }
        }
        return false;
      }

      // Constrói a lista de violências institucionais com cards (REDESIGN)
      function buildViolenciaInstitucionalGroups(data) {
        const container = document.getElementById('filterViolenciaInstitucionalContainer');
        if (!container) return;

        container.innerHTML = '';

        // Coleta todas as violências institucionais dos dados
        // Apenas de registros que têm "Institucional" em tipoViolencia
        const violenciasInstitucionais = new Set();

        data.forEach(row => {
          const tipoViolencia = String(row[columnNames.tipo] || '').toLowerCase();
          const temInstitucional = tipoViolencia.includes('institucional');

          if (temInstitucional && columnNames.tipoViolenciaInstitucional) {
            const violenciaInstitucional = row[columnNames.tipoViolenciaInstitucional];
            if (violenciaInstitucional) {
              // Pode ter múltiplos valores separados por vírgula
              const valores = String(violenciaInstitucional).split(',').map(v => v.trim()).filter(v => v);
              valores.forEach(v => violenciasInstitucionais.add(v));
            }
          }
        });

        const availableViolencias = Array.from(violenciasInstitucionais).sort();

        if (availableViolencias.length === 0) {
          container.innerHTML = '<p class="text-gray-500 text-sm italic">Nenhuma violência institucional encontrada nos dados.</p>';
          return;
        }

        // Usar a nova função de sub-cards para renderizar
        createViolenceSubCards('filterViolenciaInstitucionalContainer', availableViolencias, 'violenciaInstitucional');
      }


      // Atualiza badge total de violência institucional
      function updateBadgeViolenciaInstitucionalTotal() {
        // Conta apenas os checkboxes individuais (exclui o checkbox geral)
        const allChildCheckboxes = document.querySelectorAll('#filterViolenciaInstitucionalContainer input[data-filter="violenciaInstitucional"]:checked:not(#checkbox-violencia-institucional-geral)');
        const count = allChildCheckboxes.length;
        const badge = document.getElementById('badge-violenciaInstitucional-total');

        if (badge) {
          if (count > 0) {
            badge.textContent = count;
            badge.classList.remove('hidden');
          } else {
            badge.classList.add('hidden');
          }
        }
      }

      // Coleta todos os tipos de violência institucional selecionados
      function gatherSelectedViolenciasInstitucionais() {
        // Retorna apenas os checkboxes individuais (exclui o checkbox geral)
        const selectedCheckboxes = document.querySelectorAll('#filterViolenciaInstitucionalContainer input[data-filter="violenciaInstitucional"]:checked:not(#checkbox-violencia-institucional-geral)');
        return Array.from(selectedCheckboxes).map(cb => cb.dataset.value);
      }

      // Verifica se uma célula de violência institucional corresponde aos termos selecionados (lógica OR)
      function matchViolenciaInstitucionalCell(cellValue, selectedTerms) {
        // Se nenhum termo foi selecionado, aceita todos
        if (selectedTerms.length === 0) return true;

        // Se há termos selecionados mas a célula está vazia, REJEITA
        if (!cellValue) return false;

        // Normalizar célula (split por vírgula)
        const cellValues = String(cellValue)
          .split(',')
          .map(v => normalizeText(v.trim()))
          .filter(v => v);

        // Se após normalizar não há valores, REJEITA
        if (cellValues.length === 0) return false;

        // Normalizar termos selecionados
        const selectedNormalized = selectedTerms.map(t => normalizeText(t));

        // Retorna true se qualquer valor da célula estiver nos selecionados (OR)
        return cellValues.some(cv => selectedNormalized.includes(cv));
      }

      // Verifica se "Institucional" está selecionado e mostra/esconde a seção de detalhamento
      function verificarViolenciaInstitucionalNoFiltro() {
        const sectionViolenciaInstitucional = document.getElementById('section-violenciaInstitucional');
        if (!sectionViolenciaInstitucional) return;

        // Verifica se algum checkbox de "Institucional" está marcado no filtro de Tipo Violência
        const tipoViolenciaCheckboxes = document.querySelectorAll('input[data-filter="tipoViolencia"]:checked');
        const temInstitucional = Array.from(tipoViolenciaCheckboxes).some(cb => {
          const valor = (cb.dataset.value || '').toLowerCase();
          return valor === 'institucional' || valor.includes('institucional');
        });

        if (temInstitucional) {
          // Mostra a seção de detalhamento de Violências Institucionais
          sectionViolenciaInstitucional.classList.remove('hidden');

          // Mostra o gráfico de violência institucional
          const containerChartViolenciaInst = document.getElementById('containerChartViolenciaInstitucional');
          if (containerChartViolenciaInst) {
            containerChartViolenciaInst.classList.remove('hidden');
          }

          // Re-renderiza os gráficos para atualizar o gráfico de violência institucional
          setTimeout(() => {
            if (typeof renderCharts === 'function' && filteredData) {
              renderCharts(filteredData);
            }
          }, 100);
        } else {
          // Esconde a seção de detalhamento
          sectionViolenciaInstitucional.classList.add('hidden');

          // Desmarca todos os sub-cards de violências institucionais
          const viCards = document.querySelectorAll('#filterViolenciaInstitucionalContainer .violence-sub-card');
          viCards.forEach(card => {
            const checkbox = card.querySelector('input[type="checkbox"]');
            if (checkbox && checkbox.checked) {
              checkbox.checked = false;
              card.classList.remove('selected');
            }
          });

          // Atualiza badges
          updateBadgeViolenciaInstitucionalTotal();

          // Esconde o gráfico de violência institucional
          const containerChartViolenciaInst = document.getElementById('containerChartViolenciaInstitucional');
          if (containerChartViolenciaInst) {
            containerChartViolenciaInst.classList.add('hidden');
          }

          // Destroi o gráfico se existir
          if (charts['chartTipoViolenciaInstitucional']) {
            charts['chartTipoViolenciaInstitucional'].destroy();
            delete charts['chartTipoViolenciaInstitucional'];
          }

          // Aplica filtros para atualizar a tabela
          applyFilters();
        }
      }

      // Torna a função acessível globalmente
      window.verificarViolenciaInstitucionalNoFiltro = verificarViolenciaInstitucionalNoFiltro;

      // Coleta todos os encaminhamentos selecionados (de todos os grupos)
      function gatherSelectedEncaminhamentos() {
        const selectedCheckboxes = document.querySelectorAll('#filterEncaminhamentoContainer input[data-group]:checked');
        return Array.from(selectedCheckboxes).map(cb => cb.dataset.value);
      }

      // Verifica se uma célula de encaminhamento corresponde aos termos selecionados (lógica OR)
      function matchEncaminhamentoCell(cellValue, selectedTerms) {
        // Se nenhum termo foi selecionado, aceita todos
        if (selectedTerms.length === 0) return true;

        // Se há termos selecionados mas a célula está vazia, REJEITA
        if (!cellValue) return false;

        // Normalizar célula (split por vírgula e barra)
        const cellValues = String(cellValue)
          .split(',')
          .flatMap(v => v.split('/'))
          .map(v => normalizeText(v.trim()))
          .filter(v => v);

        // Se após normalizar não há valores, REJEITA
        if (cellValues.length === 0) return false;

        // Normalizar termos selecionados
        const selectedNormalized = selectedTerms.map(t => normalizeText(t));

        // Retorna true se qualquer valor da célula estiver nos selecionados (OR)
        return cellValues.some(cv => selectedNormalized.includes(cv));
      }

      // Gera opções "agrupadas" por texto normalizado (com suporte a multi-valor)
      function buildNormalizedOptions(colKey, data) {
        const map = new Map(); // norm -> rótulo original mais comum
        data.forEach(row => {
          const raw = row[colKey];
          if (!raw) return;

          // Suporta valores múltiplos separados por vírgula E por barra (/)
          // Primeiro separa por vírgula, depois cada parte por barra
          const valores = String(raw)
            .split(',')
            .flatMap(v => v.split('/'))
            .map(v => v.trim())
            .filter(v => v);

          valores.forEach(val => {
            const norm = normalizeText(val);
            if (!norm) return;

            // Guarda o label original mais completo (maior length)
            if (!map.has(norm) || val.length > map.get(norm).length) {
              map.set(norm, val);
            }
          });
        });
        return Array.from(map.values()).sort();
      }

      // Gera opções para TIPO DE VIOLÊNCIA (NÃO separa por barra - "Financeira/Econômica" fica junto)
      function buildNormalizedOptionsTipoViolencia(colKey, data) {
        const map = new Map(); // norm -> rótulo original mais comum
        data.forEach(row => {
          const raw = row[colKey];
          if (!raw) return;

          // Suporta valores múltiplos separados APENAS por vírgula
          // NÃO separa por barra (/) para manter "Financeira/Econômica" como uma única categoria
          const valores = String(raw)
            .split(',')
            .map(v => v.trim())
            .filter(v => v);

          valores.forEach(val => {
            const norm = normalizeText(val);
            if (!norm) return;

            // Guarda o label original mais completo (maior length)
            if (!map.has(norm) || val.length > map.get(norm).length) {
              map.set(norm, val);
            }
          });
        });
        return Array.from(map.values()).sort();
      }

      // ========================================
      // NORMALIZAÇÃO DE TRANSTORNOS (UNIFICAÇÃO)
      // ========================================
      // Unifica variações de transtornos em rótulos padronizados
      function normalizarTranstorno(label) {
        if (!label) return label;

        const norm = normalizeText(label);

        // Equivalências para TDAH
        const equivalenciasTDAH = [
          'tdah',
          'tdh',
          'tda h',
          't d a h',
          'deficit de atencao',
          'deficit atencao',
          'deficitdeatencao',
          'deficit hiperatividade',
          'transtorno de deficit',
          'transtorno deficit',
          'transtorno de deficit de atencao',
          'transtorno deficit atencao',
          'deficit de atencao e hiperatividade',
          'deficit de atencao hiperatividade'
        ];

        if (equivalenciasTDAH.some(e => norm.includes(e) || e.includes(norm))) {
          return 'TDAH (Déficit de Atenção e Hiperatividade)';
        }

        // Equivalências para TEA (Autismo)
        const equivalenciasTEA = [
          'tea',
          't e a',
          'autismo',
          'autista',
          'transtorno do espectro autista',
          'espectro autista',
          'transtorno autista'
        ];

        if (equivalenciasTEA.some(e => norm.includes(e) || e.includes(norm))) {
          return 'TEA (Transtorno do Espectro Autista)';
        }

        // Equivalências para DI (Deficiência Intelectual)
        const equivalenciasDI = [
          'di ',
          ' di',
          'd i',
          'deficiencia intelectual',
          'deficiencia mental'
        ];

        if (equivalenciasDI.some(e => norm === e || norm.includes(e))) {
          return 'DI (Deficiência Intelectual)';
        }

        // Equivalências para TOD (Transtorno Opositor Desafiador)
        const equivalenciasTOD = [
          'tod',
          't o d',
          'transtorno opositor',
          'opositor desafiador',
          'transtorno opositor desafiador'
        ];

        if (equivalenciasTOD.some(e => norm.includes(e) || e.includes(norm))) {
          return 'TOD (Transtorno Opositor Desafiador)';
        }

        // Retorna o label original se não encontrou equivalência
        return label;
      }

      // Aplica normalização a uma lista de opções
      function normalizarListaTranstornos(opcoes) {
        const map = new Map(); // Usa Map para evitar duplicatas após normalização

        opcoes.forEach(opt => {
          const normalizado = normalizarTranstorno(opt);
          // Guarda apenas uma vez (a primeira ocorrência)
          if (!map.has(normalizado)) {
            map.set(normalizado, true);
          }
        });

        return Array.from(map.keys()).sort();
      }

      // Gera opções para coluna de Gênero (apenas M ou F)
      function buildGeneroOptions(data) {
        const valores = new Set();
        data.forEach(row => {
          const genero = row[columnNames.genero];
          if (genero) {
            const val = String(genero).trim().toUpperCase();
            if (val === 'M' || val === 'F') {
              valores.add(val);
            }
          }
        });
        return Array.from(valores).sort();
      }

      // Cria checkboxes elegantes para filtros
      function createCheckboxes(containerId, options, filterName) {
        const container = document.getElementById(containerId);
        container.innerHTML = '';

        options.forEach((opt, index) => {
          const id = `${filterName}_${index}`;
          const div = document.createElement('div');
          div.className = 'checkbox-container';

          const checkbox = document.createElement('input');
          checkbox.type = 'checkbox';
          checkbox.id = id;
          checkbox.className = 'custom-checkbox';
          checkbox.dataset.value = opt;
          checkbox.dataset.filter = filterName;
          checkbox.addEventListener('change', function () {
            updateBadge(filterName);
            applyFilters();

            // Se for filtro de tipoViolencia, verifica se "Institucional" está selecionado
            if (filterName === 'tipoViolencia') {
              verificarViolenciaInstitucionalNoFiltro();
            }
          });

          const label = document.createElement('label');
          label.htmlFor = id;
          label.className = 'checkbox-label';
          label.textContent = opt;

          div.appendChild(checkbox);
          div.appendChild(label);
          container.appendChild(div);
        });
      }

      // ============================================
      // CARDS DE TIPO DE VIOLÊNCIA - REDESIGN
      // Sistema escalável para 1-9+ tipos
      // ============================================

      // Mapeamento de tipos para ícones e cores
      const VIOLENCE_TYPE_CONFIG = {
        'fisica': { icon: '👊', color: 'fisica', keywords: ['física', 'fisica', 'agressão física', 'agressao fisica'] },
        'psicologica': { icon: '🧠', color: 'psicologica', keywords: ['psicológica', 'psicologica', 'emocional', 'mental'] },
        'sexual': { icon: '⚠️', color: 'sexual', keywords: ['sexual', 'abuso sexual'] },
        'negligencia': { icon: '🚫', color: 'negligencia', keywords: ['negligência', 'negligencia', 'abandono', 'omissão'] },
        'institucional': { icon: '🏛️', color: 'institucional', keywords: ['institucional'] },
        'bullying': { icon: '😢', color: 'bullying', keywords: ['bullying'] },
        'cyberbullying': { icon: '💻', color: 'cyberbullying', keywords: ['cyberbullying', 'cyber'] },
        'autolesao': { icon: '💔', color: 'autolesao', keywords: ['autolesão', 'autolesao', 'automutilação', 'suicídio'] },
        'financeira': { icon: '💰', color: 'outros', keywords: ['financeira', 'econômica', 'patrimonial'] },
        'outros': { icon: '📋', color: 'outros', keywords: ['outro', 'outros', 'outra'] }
      };

      /**
       * Detecta o tipo de violência baseado no texto
       * @param {string} text - Texto do tipo de violência
       * @returns {Object} Configuração do tipo (icon, color)
       */
      function detectViolenceType(text) {
        const normalized = normalizeText(text);

        for (const [key, config] of Object.entries(VIOLENCE_TYPE_CONFIG)) {
          for (const keyword of config.keywords) {
            if (normalized.includes(normalizeText(keyword))) {
              return { key, ...config };
            }
          }
        }

        // Fallback para tipos não mapeados
        return { key: 'outros', icon: '📋', color: 'outros', keywords: [] };
      }

      /**
       * Cria cards de tipo de violência (versão card-based)
       * @param {string} containerId - ID do container
       * @param {Array} options - Lista de opções
       * @param {string} filterName - Nome do filtro (tipoViolencia)
       */
      function createViolenceTypeCards(containerId, options, filterName) {
        const container = document.getElementById(containerId);
        if (!container) return;

        container.innerHTML = '';

        options.forEach((opt, index) => {
          const id = `${filterName}_${index}`;
          const typeConfig = detectViolenceType(opt);

          // Criar card
          const card = document.createElement('div');
          card.className = 'violence-type-card';
          card.dataset.type = typeConfig.key;
          card.dataset.value = opt;

          // Checkbox oculto mas funcional
          const checkbox = document.createElement('input');
          checkbox.type = 'checkbox';
          checkbox.id = id;
          checkbox.dataset.value = opt;
          checkbox.dataset.filter = filterName;
          checkbox.addEventListener('change', function () {
            // Atualiza estado visual do card
            if (this.checked) {
              card.classList.add('selected');
            } else {
              card.classList.remove('selected');
            }

            // Atualiza badge e aplica filtros
            updateBadge(filterName);
            applyFilters();

            // Verifica se "Institucional" está selecionado
            if (filterName === 'tipoViolencia') {
              verificarViolenciaInstitucionalNoFiltro();
            }
          });

          // Ícone do tipo
          const icon = document.createElement('div');
          icon.className = 'violence-type-icon';
          icon.textContent = typeConfig.icon;

          // Label do tipo
          const label = document.createElement('div');
          label.className = 'violence-type-label';
          label.textContent = opt;

          // Check mark
          const check = document.createElement('div');
          check.className = 'violence-type-check';
          check.textContent = '✓';

          // Montar card
          card.appendChild(checkbox);
          card.appendChild(icon);
          card.appendChild(label);
          card.appendChild(check);

          // Click no card alterna o checkbox
          card.addEventListener('click', function (e) {
            if (e.target !== checkbox) {
              checkbox.checked = !checkbox.checked;
              checkbox.dispatchEvent(new Event('change'));
            }
          });

          container.appendChild(card);
        });
      }

      /**
       * Cria cards para violência institucional (subgrupo)
       * @param {string} containerId - ID do container
       * @param {Array} options - Lista de opções
       * @param {string} filterName - Nome do filtro
       */
      function createViolenceSubCards(containerId, options, filterName) {
        const container = document.getElementById(containerId);
        if (!container) return;

        container.innerHTML = '';

        // Ícones para tipos de violência institucional
        const INST_ICONS = {
          'verbal': '🗣️',
          'física': '👊',
          'omissão': '🚫',
          'discriminação': '🎯',
          'negligência': '⚡',
          'exposição': '👁️',
          'humilhação': '😔',
          'constrangimento': '😣',
          'default': '📌'
        };

        const getInstIcon = (text) => {
          const normalized = normalizeText(text);
          for (const [key, icon] of Object.entries(INST_ICONS)) {
            if (key !== 'default' && normalized.includes(normalizeText(key))) {
              return icon;
            }
          }
          return INST_ICONS.default;
        };

        options.forEach((opt, index) => {
          const id = `${filterName}_${index}`;

          // Criar sub-card
          const card = document.createElement('div');
          card.className = 'violence-sub-card';
          card.dataset.value = opt;

          // Checkbox oculto
          const checkbox = document.createElement('input');
          checkbox.type = 'checkbox';
          checkbox.id = id;
          checkbox.dataset.value = opt;
          checkbox.dataset.filter = filterName;
          checkbox.addEventListener('change', function () {
            if (this.checked) {
              card.classList.add('selected');
            } else {
              card.classList.remove('selected');
            }
            updateBadgeViolenciaInstitucionalTotal();
            applyFilters();
          });

          // Ícone
          const icon = document.createElement('span');
          icon.className = 'violence-sub-icon';
          icon.textContent = getInstIcon(opt);

          // Label
          const label = document.createElement('span');
          label.className = 'violence-sub-label';
          label.textContent = opt;

          // Check
          const check = document.createElement('span');
          check.className = 'violence-sub-check';
          check.textContent = '✓';

          // Montar card
          card.appendChild(checkbox);
          card.appendChild(icon);
          card.appendChild(label);
          card.appendChild(check);

          // Click toggle
          card.addEventListener('click', function (e) {
            if (e.target !== checkbox) {
              checkbox.checked = !checkbox.checked;
              checkbox.dispatchEvent(new Event('change'));
            }
          });

          container.appendChild(card);
        });
      }

      /**
       * Seleciona todos os tipos de violência
       */
      function selectAllViolenceTypes() {
        const cards = document.querySelectorAll('#filterTipoViolenciaContainer .violence-type-card');
        cards.forEach(card => {
          const checkbox = card.querySelector('input[type="checkbox"]');
          if (checkbox && !checkbox.checked) {
            checkbox.checked = true;
            card.classList.add('selected');
          }
        });
        updateBadge('tipoViolencia');
        applyFilters();
        verificarViolenciaInstitucionalNoFiltro();
      }

      /**
       * Limpa todos os tipos de violência selecionados
       */
      function clearAllViolenceTypes() {
        const cards = document.querySelectorAll('#filterTipoViolenciaContainer .violence-type-card');
        cards.forEach(card => {
          const checkbox = card.querySelector('input[type="checkbox"]');
          if (checkbox && checkbox.checked) {
            checkbox.checked = false;
            card.classList.remove('selected');
          }
        });
        updateBadge('tipoViolencia');
        applyFilters();
        verificarViolenciaInstitucionalNoFiltro();
      }

      function setupEscolaAutocomplete() {
        const input = document.getElementById('filterEscolaSearch');
        const container = document.getElementById('filterEscolaContainer');
        const list = document.getElementById('filterEscolaAutocompleteList');
        const tagsContainer = document.getElementById('filterEscolaSelectedTags');
        if (!input || !container || !list) return;

        if (input.dataset.bound === 'true') return;
        input.dataset.bound = 'true';

        let cached = [];
        let selectedIndex = -1;
        let closeTimer = null;

        const enablePortal = () => {
          // Portal logic optional for now
        };

        const disablePortal = () => {
          // Portal logic optional for now
        };

        const buildReverseSiglas = () => {
          const rev = { cmei: {}, emef: {} };
          if (typeof CMEI_SIGLAS === 'object' && CMEI_SIGLAS) {
            Object.keys(CMEI_SIGLAS).forEach((sigla) => {
              const nome = CMEI_SIGLAS[sigla];
              if (!sigla || !nome) return;
              const full = `CMEI ${String(nome).trim()}`;
              rev.cmei[normalizeText(full)] = String(sigla).trim();
            });
          }
          if (typeof EMEF_SIGLAS === 'object' && EMEF_SIGLAS) {
            Object.keys(EMEF_SIGLAS).forEach((sigla) => {
              const nome = EMEF_SIGLAS[sigla];
              if (!sigla || !nome) return;
              const full = `EMEF ${String(nome).trim()}`;
              rev.emef[normalizeText(full)] = String(sigla).trim();
            });
          }
          return rev;
        };

        const reverseSiglas = buildReverseSiglas();

        const getNomeFromSigla = (sigla) => {
          const s = String(sigla || '').trim().toUpperCase();
          if (!s) return '';
          if (typeof CMEI_SIGLAS === 'object' && CMEI_SIGLAS && CMEI_SIGLAS[s]) return `CMEI ${CMEI_SIGLAS[s]}`;
          if (typeof EMEF_SIGLAS === 'object' && EMEF_SIGLAS && EMEF_SIGLAS[s]) return `EMEF ${EMEF_SIGLAS[s]}`;
          return '';
        };

        const renderSelectedTags = () => {
          if (!tagsContainer) return;
          const checked = Array.from(container.querySelectorAll('input[type="checkbox"][data-filter="escola"]:checked'));
          tagsContainer.innerHTML = '';

          if (!checked.length) {
            tagsContainer.innerHTML = '<span class="text-xs text-gray-500">Nenhuma escola selecionada</span>';
            return;
          }

          checked.forEach((cb) => {
            const raw = String(cb.getAttribute('data-value') || '').trim();
            const nomeFromSigla = getNomeFromSigla(raw);
            const label = nomeFromSigla || raw;

            const tag = document.createElement('span');
            tag.className = 'selected-tag';

            const tipo = getTipoInstituicao(label) || getTipoInstituicao(raw) || '';
            if (tipo) {
              const badge = document.createElement('span');
              badge.className = `autocomplete-badge ${String(tipo).toLowerCase()}`;
              badge.textContent = tipo;
              tag.appendChild(badge);
            }

            const text = document.createElement('span');
            text.className = 'selected-tag-label';
            text.textContent = label;
            tag.appendChild(text);

            const remove = document.createElement('button');
            remove.type = 'button';
            remove.className = 'selected-tag-remove';
            remove.textContent = '×';
            remove.addEventListener('click', () => {
              cb.checked = false;
              cb.dispatchEvent(new Event('change', { bubbles: true }));
            });
            tag.appendChild(remove);

            tagsContainer.appendChild(tag);
          });
        };

        const rebuildCache = () => {
          // Base do autocomplete = opções realmente existentes no filtro (vindas da planilha)
          const checkboxes = Array.from(container.querySelectorAll('input[type="checkbox"][data-filter="escola"]'));

          cached = checkboxes
            .map((cb) => {
              const raw = String(cb.getAttribute('data-value') || '').trim();
              if (!raw) return null;

              // Se o valor do checkbox for uma sigla, resolve o nome completo (para exibir/pesquisar por nome)
              const nomeFromSigla = getNomeFromSigla(raw);
              const value = nomeFromSigla || raw;
              const tipo = getTipoInstituicao(value) || getTipoInstituicao(raw) || '';

              // Determina sigla real (se raw já for sigla, usa; se raw for nome, tenta achar no reverse)
              let sigla = '';
              if (nomeFromSigla) {
                sigla = raw;
              } else {
                const key = normalizeText(raw);
                sigla = reverseSiglas.cmei[key] || reverseSiglas.emef[key] || '';
              }

              const normalized = normalizeText(value);
              const siglaNormalized = normalizeText(sigla);

              return {
                checkboxValue: raw,
                value,
                tipo,
                sigla,
                siglaNormalized,
                normalized,
              };
            })
            .filter(Boolean);
        };

        const closeList = () => {
          if (closeTimer) {
            window.clearTimeout(closeTimer);
            closeTimer = null;
          }
          if (!list.classList.contains('show')) {
            list.classList.remove('hide');
            input.classList.remove('autocomplete-open');
            selectedIndex = -1;
            disablePortal();
            return;
          }

          list.classList.add('hide');
          list.classList.remove('show');
          input.classList.remove('autocomplete-open');
          selectedIndex = -1;

          window.setTimeout(() => {
            list.classList.remove('hide');
            list.style.display = 'none';
            disablePortal();
          }, 160);
        };

        const openList = () => {
          enablePortal();
          list.style.display = 'block';
          list.classList.remove('hide');
          if (!list.classList.contains('show')) list.classList.add('show');
          input.classList.add('autocomplete-open');
        };

        const updateSelectedVisual = () => {
          const items = Array.from(list.querySelectorAll('.autocomplete-item'));
          items.forEach((el, idx) => {
            if (idx === selectedIndex) el.classList.add('active');
            else el.classList.remove('active');
          });
          if (selectedIndex >= 0 && items[selectedIndex]) {
            items[selectedIndex].scrollIntoView({ block: 'nearest', behavior: 'smooth' });
          }
        };

        const filterItems = (termRaw) => {
          // Replica o algoritmo do novo registro:
          // - palavras devem bater no NOME
          // - sigla (sem espaços) bate por includes
          // - iniciais consecutivas bate por startsWith na sigla
          const termoLower = normalizeText(String(termRaw || '')).trim();
          const termoSemEspacos = termoLower.replace(/\s+/g, '');
          const palavras = termoLower.split(/\s+/).filter(Boolean);

          if (!termoLower) return [];

          // Não sugere opções já selecionadas
          const selectedSet = new Set(
            Array.from(container.querySelectorAll('input[type="checkbox"][data-filter="escola"]:checked'))
              .map((cb) => normalizeText(String(cb.getAttribute('data-value') || '').trim()))
              .filter(Boolean)
          );

          return cached.filter((it) => {
            const key = normalizeText(String(it.checkboxValue || '').trim());
            if (key && selectedSet.has(key)) return false;

            const nomeNormalizado = it.normalized;
            const siglaNormalizada = it.siglaNormalized || '';

            const matchPorPalavras = palavras.length ? palavras.every(p => nomeNormalizado.includes(p)) : true;
            const matchPorSigla = termoSemEspacos ? siglaNormalizada.includes(termoSemEspacos) : true;
            const matchPorIniciaisConsecutivas = termoSemEspacos ? siglaNormalizada.startsWith(termoSemEspacos) : true;

            return matchPorPalavras || matchPorSigla || matchPorIniciaisConsecutivas;
          });
        };

        const selectItem = (it) => {
          // Multi-seleção: alterna o checkbox correspondente e mantém os demais
          const checkboxes = Array.from(container.querySelectorAll('input[type="checkbox"][data-filter="escola"]'));

          // Encontra o checkbox correspondente
          const target = normalizeText(String(it.checkboxValue || '').trim());
          const cbMatch = checkboxes.find((cb) => {
            const v = String(cb.getAttribute('data-value') || '').trim();
            return normalizeText(v) === target;
          });

          if (cbMatch) {
            cbMatch.checked = !cbMatch.checked;
            cbMatch.dispatchEvent(new Event('change', { bubbles: true }));
          }

          // Limpa para permitir adicionar outra escola rapidamente
          input.value = '';
          input.focus();
          closeList();
        };

        const render = (results) => {
          list.innerHTML = '';

          if (!results.length) {
            list.innerHTML = '<div class="no-results">🔍 Nenhuma instituição encontrada</div>';
            openList();
            return;
          }

          results.slice(0, 60).forEach((it, idx) => {
            const item = document.createElement('div');
            item.className = 'autocomplete-item';

            const badge = document.createElement('span');
            badge.className = `autocomplete-badge ${String(it.tipo || '').toLowerCase()}`;
            badge.textContent = it.tipo || '';

            const infoContainer = document.createElement('div');
            infoContainer.className = 'flex flex-col';

            const nomeSemTipo = it.tipo ? String(it.value).replace(String(it.tipo) + ' ', '') : it.value;
            const nomeSpan = document.createElement('span');
            nomeSpan.className = 'autocomplete-nome';
            nomeSpan.textContent = nomeSemTipo;

            const siglaSpan = document.createElement('span');
            siglaSpan.className = 'text-xs text-gray-500 mt-0.5';
            siglaSpan.textContent = `Sigla: ${it.sigla || ''}`;

            infoContainer.appendChild(nomeSpan);
            infoContainer.appendChild(siglaSpan);

            if (it.tipo) item.appendChild(badge);
            item.appendChild(infoContainer);

            item.addEventListener('click', () => selectItem(it));
            list.appendChild(item);
            if (idx === 0) selectedIndex = 0;
          });

          openList();
          updateSelectedVisual();
        };

        input.addEventListener('input', function () {
          const termRaw = String(this.value || '').trim();
          selectedIndex = -1;
          if (termRaw.length === 0) {
            list.innerHTML = '';
            closeList();
            return;
          }
          const results = filterItems(termRaw);
          render(results);
        });

        input.addEventListener('keydown', function (e) {
          const items = Array.from(list.querySelectorAll('.autocomplete-item'));
          if (!items.length) return;

          if (e.key === 'ArrowDown') {
            e.preventDefault();
            selectedIndex = Math.min(selectedIndex + 1, items.length - 1);
            updateSelectedVisual();
          } else if (e.key === 'ArrowUp') {
            e.preventDefault();
            selectedIndex = Math.max(selectedIndex - 1, -1);
            updateSelectedVisual();
          } else if (e.key === 'Enter') {
            e.preventDefault();
            if (selectedIndex >= 0 && items[selectedIndex]) {
              items[selectedIndex].click();
            }
          } else if (e.key === 'Escape') {
            closeList();
          }
        });

        document.addEventListener('click', function (e) {
          if (!input.contains(e.target) && !list.contains(e.target)) {
            closeList();
          }
        });

        // Mantém cache atualizado quando createCheckboxes recriar o container
        const obs = new MutationObserver(() => {
          rebuildCache();
          renderSelectedTags();
        });
        obs.observe(container, { childList: true, subtree: true });

        // Atualiza tags quando checkboxes mudarem (event delegation)
        container.addEventListener('change', (e) => {
          const t = e.target;
          if (t && t.matches && t.matches('input[type="checkbox"][data-filter="escola"]')) {
            renderSelectedTags();
          }
        });

        rebuildCache();
        renderSelectedTags();
      }

      function setupTipoDeficienciaAutocomplete() {
        const input = document.getElementById('filterTipoDeficienciaSearch');
        const container = document.getElementById('filterTipoDeficienciaContainer');
        const list = document.getElementById('filterTipoDeficienciaAutocompleteList');
        const tagsContainer = document.getElementById('filterTipoDeficienciaSelectedTags');
        if (!input || !container || !list || !tagsContainer) return;

        if (input.dataset.bound === 'true') return;
        input.dataset.bound = 'true';

        let cached = [];
        let selectedIndex = -1;
        let lastJustSelectedValue = null;

        const DEF_BADGE_COLORS = [
          { bg: '#7c3aed', fg: '#ffffff' },
          { bg: '#2563eb', fg: '#ffffff' },
          { bg: '#059669', fg: '#ffffff' },
          { bg: '#d97706', fg: '#ffffff' },
          { bg: '#dc2626', fg: '#ffffff' },
          { bg: '#0f766e', fg: '#ffffff' },
        ];

        const hashString = (str) => {
          let h = 0;
          const s = String(str || '');
          for (let i = 0; i < s.length; i += 1) {
            h = (h * 31 + s.charCodeAt(i)) >>> 0;
          }
          return h;
        };

        const pickBadge = (value) => {
          const h = hashString(normalizeText(value || ''));
          return DEF_BADGE_COLORS[h % DEF_BADGE_COLORS.length];
        };

        const getAbbr = (value) => {
          const s = String(value || '').trim();
          if (!s) return 'D';
          const words = s.split(/\s+/).filter(Boolean);
          const abbr = words.map((w) => (w[0] || '').toUpperCase()).join('');
          return (abbr || 'D').slice(0, 2);
        };

        let closeTimer = null;

        const getAllOptions = () => {
          const cbs = Array.from(container.querySelectorAll('input.custom-checkbox[data-filter="tipoDeficiencia"]'));
          return cbs
            .map((cb) => {
              const labelEl = cb.closest('.checkbox-container')?.querySelector('.checkbox-label');
              const label = labelEl ? String(labelEl.textContent || '').trim() : String(cb.dataset.value || '').trim();
              const value = String(cb.dataset.value || label).trim();
              return {
                value,
                label,
                norm: normalizeText(label) || normalizeText(value),
                cb,
              };
            })
            .filter((o) => o.value && o.label);
        };

        const getSelectedValues = () => {
          return new Set(
            Array.from(container.querySelectorAll('input.custom-checkbox[data-filter="tipoDeficiencia"]:checked'))
              .map((cb) => String(cb.dataset.value || '').trim())
              .filter(Boolean)
          );
        };

        const closeList = () => {
          if (!list.classList.contains('show')) {
            list.classList.remove('hide');
            input.classList.remove('autocomplete-open');
            selectedIndex = -1;
            return;
          }

          list.classList.add('hide');
          list.classList.remove('show');
          input.classList.remove('autocomplete-open');
          selectedIndex = -1;

          closeTimer = window.setTimeout(() => {
            list.classList.remove('hide');
            list.style.display = 'none';
            closeTimer = null;
          }, 160);
        };

        const openList = () => {
          if (closeTimer) {
            window.clearTimeout(closeTimer);
            closeTimer = null;
          }
          list.style.display = 'block';
          list.classList.remove('hide');
          if (!list.classList.contains('show')) list.classList.add('show');
          input.classList.add('autocomplete-open');
        };

        const updateSelectedVisual = () => {
          const items = Array.from(list.querySelectorAll('.autocomplete-item'));
          items.forEach((el, idx) => {
            if (idx === selectedIndex) el.classList.add('active');
            else el.classList.remove('active');
          });
          if (selectedIndex >= 0 && items[selectedIndex]) {
            items[selectedIndex].scrollIntoView({ block: 'nearest', behavior: 'smooth' });
          }
        };

        const renderSelectedTags = () => {
          const selected = getSelectedValues();
          tagsContainer.innerHTML = '';

          if (selected.size === 0) {
            tagsContainer.innerHTML = '<span class="text-xs text-gray-500">Nenhum tipo selecionado</span>';
            return;
          }

          const opts = cached.length ? cached : getAllOptions();
          const byValue = new Map(opts.map((o) => [o.value, o]));

          Array.from(selected).forEach((val) => {
            const opt = byValue.get(val);
            const label = opt ? opt.label : val;

            const badgeCfg = pickBadge(label || val);

            const tag = document.createElement('span');
            tag.className = 'selected-tag';

            const badge = document.createElement('span');
            badge.className = 'deficiency-tag-badge';
            badge.textContent = getAbbr(label || val);
            badge.style.background = badgeCfg.bg;
            badge.style.color = badgeCfg.fg;
            if (lastJustSelectedValue && String(val) === String(lastJustSelectedValue)) {
              badge.classList.add('badge-pop');
            }
            tag.appendChild(badge);

            const text = document.createElement('span');
            text.className = 'selected-tag-label';
            text.textContent = label;
            tag.appendChild(text);

            const remove = document.createElement('button');
            remove.type = 'button';
            remove.className = 'selected-tag-remove';
            remove.textContent = '×';
            remove.addEventListener('click', (e) => {
              e.preventDefault();
              e.stopPropagation();
              const cb = opt?.cb;
              if (!cb) return;
              remove.disabled = true;
              badge.classList.remove('badge-pop');
              badge.classList.add('badge-out');
              window.setTimeout(() => {
                cb.checked = false;
                cb.dispatchEvent(new Event('change', { bubbles: true }));
                renderSelectedTags();
                renderList(input.value);
              }, 190);
            });
            tag.appendChild(remove);
            tagsContainer.appendChild(tag);
          });

          // Evita animar em rerenders futuros
          lastJustSelectedValue = null;
        };

        const renderList = (rawQuery) => {
          const query = normalizeText(rawQuery || '').trim();
          const selected = getSelectedValues();

          cached = getAllOptions();
          let results = cached.filter((o) => !selected.has(o.value));

          // Sem texto: mostra tudo
          if (query) {
            results = results.filter((o) => (o.norm || '').includes(query));
          }

          list.innerHTML = '';
          selectedIndex = -1;

          if (!results.length) {
            list.innerHTML = '<div class="no-results">🔍 Nenhum tipo encontrado</div>';
            openList();
            return;
          }

          results.slice(0, 50).forEach((opt, idx) => {
            const item = document.createElement('div');
            item.className = 'autocomplete-item';
            item.dataset.index = String(idx);

            const label = document.createElement('div');
            label.className = 'autocomplete-item-label';
            label.textContent = opt.label;
            item.appendChild(label);

            item.addEventListener('mousedown', (e) => {
              e.preventDefault();
              const cb = opt.cb;
              if (!cb || cb.disabled) return;
              lastJustSelectedValue = opt.value;
              cb.checked = true;
              cb.dispatchEvent(new Event('change', { bubbles: true }));
              input.value = '';
              renderSelectedTags();
              renderList('');
            });

            list.appendChild(item);
          });

          openList();
        };

        input.addEventListener('input', () => {
          renderList(input.value);
        });

        input.addEventListener('focus', () => {
          renderList(input.value);
        });

        input.addEventListener('keydown', (e) => {
          const items = Array.from(list.querySelectorAll('.autocomplete-item'));
          if (!items.length) return;

          if (e.key === 'ArrowDown') {
            e.preventDefault();
            selectedIndex = Math.min(selectedIndex + 1, items.length - 1);
            updateSelectedVisual();
          } else if (e.key === 'ArrowUp') {
            e.preventDefault();
            selectedIndex = Math.max(selectedIndex - 1, 0);
            updateSelectedVisual();
          } else if (e.key === 'Enter') {
            e.preventDefault();
            const el = items[selectedIndex] || items[0];
            if (el) el.dispatchEvent(new MouseEvent('mousedown', { bubbles: true }));
          } else if (e.key === 'Escape') {
            closeList();
          }
        });

        document.addEventListener('click', (e) => {
          const t = e.target;
          if (t === input || (t && t.closest && t.closest('#filterTipoDeficienciaAutocompleteList'))) return;
          closeList();
        });

        const mo = new MutationObserver(() => {
          cached = getAllOptions();
          renderSelectedTags();
        });
        mo.observe(container, { childList: true, subtree: true });

        cached = getAllOptions();
        renderSelectedTags();
      }

      // Obtém valores selecionados dos checkboxes
      function getCheckedValues(filterName) {
        const checkboxes = document.querySelectorAll(`input[data-filter="${filterName}"]:checked`);
        return Array.from(checkboxes).map(cb => cb.dataset.value);
      }

      // Atualiza o badge de contagem
      function updateBadge(filterName) {
        const count = getCheckedValues(filterName).length;
        const badge = document.getElementById(`badge-${filterName}`);

        // Verifica se o badge existe antes de tentar acessar suas propriedades
        if (!badge) {
          console.warn(`[updateBadge] Badge não encontrado para filtro: ${filterName}`);
          return;
        }

        if (count > 0) {
          badge.textContent = count;
          badge.classList.remove('hidden');
        } else {
          badge.classList.add('hidden');
        }
      }

      // Atualiza badge para filtro TI (select ao invés de checkboxes)
      function updateBadgeTI() {
        const selectTI = document.getElementById('filterTI');
        const badge = document.getElementById('badge-ti');

        if (selectTI && selectTI.value && selectTI.value !== '') {
          badge.textContent = '1';
          badge.classList.remove('hidden');
        } else if (badge) {
          badge.classList.add('hidden');
        }
      }

      function ensureFilterCardBadges() {
        const groups = document.querySelectorAll('details.filter-group[data-mode="panel"]');
        groups.forEach((d) => {
          const summary = d.querySelector('summary');
          if (!summary) return;
          const existing = summary.querySelector('.filter-card-badge');
          if (existing) {
            // Normaliza caso exista um badge antigo com classes grandes
            existing.className = 'filter-card-badge';
            existing.style.pointerEvents = 'none';
            if (!existing.textContent) existing.textContent = '0';
            return;
          }

          const badge = document.createElement('span');
          badge.className = 'filter-card-badge';
          badge.textContent = '0';
          badge.style.display = 'none';

          summary.appendChild(badge);
        });
      }

      function updateFilterCardBadges() {
        ensureFilterCardBadges();
        const groups = document.querySelectorAll('details.filter-group[data-mode="panel"]');

        const isCountable = (el) => {
          if (!el) return false;
          if (el.disabled) return false;
          // Não conta campos em seções condicionais escondidas
          if (el.closest('.hidden')) return false;
          return true;
        };

        groups.forEach((d) => {
          const content = d.__panelContent || d.querySelector('.filter-group-content');
          const summary = d.querySelector('summary');
          const badge = summary ? summary.querySelector('.filter-card-badge') : null;
          if (!content || !badge) return;

          let count = 0;
          const fields = content.querySelectorAll('input, select, textarea');

          fields.forEach((el) => {
            if (!isCountable(el)) return;

            // Ignorar campo de busca do autocomplete (não é filtro aplicado)
            if (el.id === 'filterEscolaSearch') return;

            const tag = (el.tagName || '').toLowerCase();
            if (tag === 'select') {
              if (String(el.value || '').trim() !== '') count += 1;
              return;
            }

            const type = String(el.type || '').toLowerCase();
            if (type === 'checkbox' || type === 'radio') {
              if (el.checked) count += 1;
              return;
            }

            // text/number/date/etc
            if (String(el.value || '').trim() !== '') count += 1;
          });

          if (count > 0) {
            badge.textContent = String(count);
            badge.style.display = 'inline-flex';
          } else {
            badge.style.display = 'none';
          }
        });
      }

      // Formata data para exibição (dd/mm/aaaa)
      function formatDate(value) {
        if (!value || value === '') return null; // Retorna null para valores vazios
        const date = parseDateCell(value);
        if (!date) return value; // Se não conseguir parsear, retorna o valor original

        const dia = String(date.getDate()).padStart(2, '0');
        const mes = String(date.getMonth() + 1).padStart(2, '0');
        const ano = date.getFullYear();
        return `${dia}/${mes}/${ano}`;
      }

      // Converte célula de data (dd/mm/aaaa, número serial do Excel, etc.) em Date
      function parseDateCell(value) {
        const str = String(value || '').trim();
        if (!str) return null;

        // IMPORTANTE: Formato Date(YYYY,M,D) do Google Sheets
        // O mês já vem base-0 (0=janeiro, 11=dezembro)
        const dateMatch = str.match(/^Date\((\d{4}),(\d{1,2}),(\d{1,2})\)$/);
        if (dateMatch) {
          const ano = parseInt(dateMatch[1], 10);
          const mes = parseInt(dateMatch[2], 10); // Já está em base-0
          const dia = parseInt(dateMatch[3], 10);
          return new Date(ano, mes, dia);
        }

        // Tenta formato dd/mm/aaaa ou dd-mm-aaaa (brasileiro)
        const m = str.match(/^(\d{1,2})[\/\-](\d{1,2})[\/\-](\d{2,4})$/);
        if (m) {
          let dia = parseInt(m[1], 10);
          let mes = parseInt(m[2], 10) - 1;
          let ano = parseInt(m[3], 10);
          if (ano < 100) ano += 2000;

          // Valida se a data é válida
          const d = new Date(ano, mes, dia);
          if (d.getFullYear() === ano && d.getMonth() === mes && d.getDate() === dia) {
            return d;
          }
          return null;
        }

        // Tenta como número serial do Excel (ex: 45803)
        const num = parseFloat(str);
        if (!isNaN(num) && num > 1 && num < 100000) {
          // Excel conta dias desde 01/01/1900
          // Mas Excel tem um bug: considera 1900 como ano bissexto (não é)
          // Então para datas >= 01/03/1900, subtraímos 1 dia extra
          const excelEpoch = new Date(1899, 11, 30); // 30/12/1899
          const days = num >= 60 ? num - 1 : num; // Corrige bug do Excel
          const date = new Date(excelEpoch.getTime() + days * 24 * 60 * 60 * 1000);
          return date;
        }

        // Tenta parse direto (formato ISO ou outros)
        const d = new Date(str);
        return isNaN(d.getTime()) ? null : d;
      }

      // ==============================
      // Inicialização da página
      // ==============================
      window.addEventListener('load', function () {
        // Estado global de atualização (compartilhado via localStorage)
        window.EstadoBotaoAtualizacaoPainel = false;

        // Event listeners do modal
        const modal = document.getElementById('modal-detalhes');

        // Fechar modal ao clicar fora
        if (modal) {
          modal.addEventListener('click', function (e) {
            if (e.target === modal) {
              fecharModalDetalhes();
            }
          });
        }

        // Fechar modal com ESC
        document.addEventListener('keydown', function (e) {
          if (e.key === 'Escape') {
            if (modal && modal.classList.contains('visible')) {
              fecharModalDetalhes();
            }
          }
        });
        // Ao clicar em Atualizar Dados, atualiza estado global, invalida cache e carrega dados
        document.getElementById('btnAtualizar').addEventListener('click', function () {
          try {
            window.EstadoBotaoAtualizacaoPainel = true;
            localStorage.setItem('naam_estado_atualizacao_painel', JSON.stringify({
              state: true,
              timestamp: Date.now(),
              source: 'painel-casos'
            }));
            console.log('[Painel] 🧭 Estado global definido: Atualizar Dados clicado');
          } catch (e) {
            console.warn('[Painel] ⚠️ Erro ao definir estado global:', e);
          }

          // Garante limpeza de cache e recarrega notificações
          if (typeof limparCacheERecarregarNotificacoes === 'function') {
            limparCacheERecarregarNotificacoes();
          }
          // Comportamento normal do botão
          // Passa true para indicar que é uma ação explícita do usuário
          if (typeof carregarDadosPlanilha === 'function') {
            carregarDadosPlanilha(true);
          }
        });

        // Event listeners de paginação
        document.getElementById('btnPrimeiraPagina').addEventListener('click', () => irParaPagina(1));
        document.getElementById('btnPaginaAnterior').addEventListener('click', () => irParaPagina(paginaAtual - 1));
        document.getElementById('btnProximaPagina').addEventListener('click', () => irParaPagina(paginaAtual + 1));
        document.getElementById('btnUltimaPagina').addEventListener('click', () => irParaPagina(totalPaginas));
        document.getElementById('registrosPorPaginaSelect').addEventListener('change', alterarRegistrosPorPagina);

        // Event listeners de exportação e dashboard
        const btnExportarCSV = document.getElementById('btnExportarCSV');
        const btnExportarExcel = document.getElementById('btnExportarExcel');
        const btnExportarPDF = document.getElementById('btnExportarPDF');
        const btnAtualizarKPIs = document.getElementById('btnAtualizarKPIs');

        // Wrapper para atualizarKPIs que limpa cache e recarrega notificações
        function atualizarKPIsComLimpeza() {
          // Limpa cache e recarrega notificações antes de atualizar KPIs
          if (typeof limparCacheERecarregarNotificacoes === 'function') {
            limparCacheERecarregarNotificacoes();
          }
          // Chama a função original de atualizar KPIs
          if (typeof atualizarKPIs === 'function') {
            atualizarKPIs();
          }
        }

        if (btnExportarCSV) btnExportarCSV.addEventListener('click', exportarCSV);
        if (btnExportarExcel) btnExportarExcel.addEventListener('click', exportarExcel);
        if (btnExportarPDF) btnExportarPDF.addEventListener('click', exportarPDF);
        if (btnAtualizarKPIs) btnAtualizarKPIs.addEventListener('click', atualizarKPIsComLimpeza);

        // Carrega os dados automaticamente ao iniciar
        carregarDadosPlanilha();
      });

      // Abre seção específica do filtro
      function openFilterSection(filterName) {
        const box = document.getElementById('quickAdvancedFiltersBox');
        if (!box) return;

        const map = {
          periodo: { group: 'filterGroupPeriodo', target: 'filterDataInicio' },
          perfilEstudante: { group: 'filterGroupPerfilEstudante', target: 'filterPCD' },
          contextoEscolar: { group: 'filterGroupContextoEscolar', target: 'filterFonteInformada' },
          autoriaAgente: { group: 'filterGroupAutoriaAgente', target: 'filterMembroFamiliar' },
          violencia: { group: 'filterGroupViolencia', target: 'filterTipoViolenciaContainer' },
          encaminhamento: { group: 'filterGroupEncaminhamentos', target: 'filterEncaminhamentoContainer' },

          // atalhos antigos
          regiao: { group: 'filterGroupContextoEscolar', target: 'filterRegiaoContainer' },
          tipoInstituicao: { group: 'filterGroupContextoEscolar', target: 'filterTipoInstituicaoContainer' },
          escola: { group: 'filterGroupContextoEscolar', target: 'filterEscolaSearch' },
          ti: { group: 'filterGroupContextoEscolar', target: 'filterTI' },
          tipoViolencia: { group: 'filterGroupViolencia', target: 'filterTipoViolenciaContainer' },
          violenciaInstitucional: { group: 'filterGroupViolencia', target: 'section-violenciaInstitucional' },
          raca: { group: 'filterGroupPerfilEstudante', target: 'filterRacaContainer' },
          genero: { group: 'filterGroupPerfilEstudante', target: 'filterGeneroContainer' },
          orientacao: { group: 'filterGroupPerfilEstudante', target: 'filterOrientacaoContainer' },
          tipoDeficiencia: { group: 'filterGroupPerfilEstudante', target: 'section-tipoDeficiencia' },
        };

        const conf = map[filterName] || null;
        if (!conf) return;

        const details = document.getElementById(conf.group);
        if (details && !details.hasAttribute('open')) {
          details.setAttribute('open', '');
          details.dataset.expanded = 'true';
          const content = details.querySelector('.filter-group-content');
          if (content) {
            content.style.overflow = 'visible';
            content.style.height = '';
          }
        }

        const target = document.getElementById(conf.target);
        if (target) {
          setTimeout(() => {
            target.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
          }, 100);
        }
      }

      // Busca nome de coluna
      function findColumn(data, possibleNames) {
        if (!data || data.length === 0) return null;
        const keys = Object.keys(data[0]);

        for (const possible of possibleNames) {
          const found = keys.find(k => {
            const kLower = k.toLowerCase().trim();
            const pLower = possible.toLowerCase().trim();
            // Busca exata ou que contenha (mas não ao contrário para evitar "Idade" pegar "Identidade")
            return kLower === pLower || kLower.includes(pLower);
          });
          if (found) return found;
        }
        return null;
      }

      // ==============================
      // Carregamento de dados do Google Sheets via JSONP
      // ==============================

      // ID da planilha (extraído do link de edição)
      // Usando configuração centralizada (config.js)
      const SPREADSHEET_ID = (typeof CONFIG !== 'undefined' && CONFIG.SPREADSHEET_ID)
        ? CONFIG.SPREADSHEET_ID
        : '1A6a2ZLiHegPJBDpE3YLPGsa8RXVRLjpkXmKdauSlb9Y';

      function carregarDadosPlanilha(isUserAction = false) {
        // Armazena flag para uso no callback de sucesso
        window._carregarDadosPlanilhaIsUserAction = isUserAction;

        // ✨ Remove alerta e animação quando usuário clica para carregar
        // (indica que ele viu a notificação e está atualizando)
        if (typeof NotificationManager !== 'undefined' && NotificationManager.state === 'alert_showing') {
          NotificationManager.startAlertExit();
        }

        // Remove o alerta vermelho de notificações novas
        const alertaExistente = document.getElementById('alerta-novas-notificacoes');
        if (alertaExistente) {
          alertaExistente.remove();
          console.log('[Painel] 🔴 Alerta de notificações removido do DOM');
        }

        // Remove animação do botão
        desativarPulseBotao('btnAtualizar');

        // ✨ SINCRONIZAÇÃO: Só marca como atualizado se for uma ação explícita do usuário
        // (não marca se for chamada automaticamente durante navegação ou carregamento inicial)
        if (isUserAction) {
          const ultimoIdSalvo = localStorage.getItem('naam_ultimo_id_notificacao');
          if (ultimoIdSalvo) {
            const notifId = parseInt(ultimoIdSalvo, 10);
            if (typeof marcarPopupAzulAtualizado === 'function') {
              marcarPopupAzulAtualizado(notifId);
            }
            // Atualiza último ID sincronizado imediatamente
            try {
              localStorage.setItem(SYNC_LAST_NOTIF_ID_KEY, String(notifId));
              console.log('[Sync] ✅ Estado sincronizado limpo e último ID atualizado após clique no botão Atualizar Dados');
              // Zera contador global de novas notificações
              localStorage.removeItem('naam_new_notif_count');
            } catch (e) {
              console.warn('[Sync] ⚠️ Erro ao atualizar estado sincronizado:', e);
            }
          }
        }

        // Limpa flag do localStorage
        try {
          localStorage.removeItem('naam_new_notif_flag');
        } catch (e) {
          console.warn('[carregarDadosPlanilha] Erro ao limpar flag:', e);
        }

        // Limpa cache e recarrega notificações antes de carregar dados
        if (typeof limparCacheERecarregarNotificacoes === 'function') {
          limparCacheERecarregarNotificacoes();
        }

        // Validação: Verifica se SPREADSHEET_ID está configurado
        if (!SPREADSHEET_ID || SPREADSHEET_ID.includes('SEU_ID_DA_PLANILHA_AQUI') || SPREADSHEET_ID.trim() === '') {
          updateUploadStatus('error', '⚠️ Configure SPREADSHEET_ID em config.js para carregar dados da planilha');
          console.error('❌ SPREADSHEET_ID não configurado em config.js');
          return;
        }

        updateUploadStatus('loading', '⏳ Carregando dados da planilha...');

        console.log('🔄 Buscando dados via JSONP...');

        // Remove script antigo se existir
        const oldScript = document.getElementById('jsonp-script');
        if (oldScript) {
          oldScript.remove();
        }

        // Timestamp para evitar cache
        const timestamp = Date.now();
        const random = Math.random().toString(36).substring(2, 15);

        // Cria objeto global google.visualization para interceptar a resposta
        if (!window.google) {
          window.google = {};
        }
        if (!window.google.visualization) {
          window.google.visualization = {};
        }
        if (!window.google.visualization.Query) {
          window.google.visualization.Query = {};
        }

        // Define função que receberá os dados
        window.google.visualization.Query.setResponse = function (response) {
          try {
            console.log('✅ Dados recebidos via JSONP');

            if (!response || !response.table || !response.table.rows) {
              updateUploadStatus('error', '❌ Formato de resposta inválido');
              return;
            }

            // Extrai cabeçalhos
            const headers = response.table.cols.map(col => col.label || '');

            // Converte linhas para objetos
            const data = response.table.rows.map(row => {
              const obj = {};
              row.c.forEach((cell, index) => {
                const header = headers[index];
                if (header) {
                  obj[header] = cell && cell.v !== null && cell.v !== undefined ? cell.v : '';
                }
              });
              return obj;
            });

            console.log('📊 Total de registros:', data.length);

            // Limpa dados anteriores
            originalData = [];
            filteredData = [];
            window.originalData = [];
            window.filteredData = [];

            processLoadedData(data);

            // ✨ SINCRONIZAÇÃO: Após carregar dados com sucesso, atualiza último ID sincronizado
            // Só atualiza se foi uma ação explícita do usuário (isUserAction = true)
            // Isso é controlado pela flag window._carregarDadosPlanilhaIsUserAction
            setTimeout(() => {
              if (window._carregarDadosPlanilhaIsUserAction) {
                const ultimoIdSalvo = localStorage.getItem('naam_ultimo_id_notificacao');
                if (ultimoIdSalvo) {
                  const notifId = parseInt(ultimoIdSalvo, 10);
                  try {
                    localStorage.setItem(SYNC_LAST_NOTIF_ID_KEY, String(notifId));
                    console.log('[Sync] ✅ Último ID sincronizado atualizado após carregar dados (ação do usuário):', notifId);
                  } catch (e) {
                    console.warn('[Sync] ⚠️ Erro ao atualizar último ID sincronizado:', e);
                  }
                }
                // Limpa a flag
                window._carregarDadosPlanilhaIsUserAction = false;
              }
            }, 1000);

          } catch (error) {
            console.error('❌ Erro ao processar:', error);
            updateUploadStatus('error', '❌ Erro ao processar dados: ' + error.message);
          }
        };

        // Cria script tag para JSONP (não usa fetch, não precisa de proxy)
        const script = document.createElement('script');
        script.id = 'jsonp-script';
        script.src = `https://docs.google.com/spreadsheets/d/${SPREADSHEET_ID}/gviz/tq?tqx=out:json&_=${timestamp}&r=${random}`;

        script.onerror = function () {
          console.error('❌ Erro ao carregar script');
          updateUploadStatus('error', '❌ Erro ao conectar com Google Sheets. Verifique se a planilha está compartilhada como "Qualquer pessoa com o link pode visualizar"');
        };

        document.head.appendChild(script);
      }

      function processLoadedData(data) {
        if (!data || data.length === 0) {
          updateUploadStatus('error', '❌ Arquivo vazio ou sem dados válidos');
          return;
        }

        originalData = data;
        filteredData = [...data];

        // Atualiza variáveis globais para dashboard-stats.js
        window.originalData = originalData;
        window.filteredData = filteredData;

        // Mapeia colunas - Atualizado para novo cabeçalho
        columnNames = {
          // Criança/Estudante
          crianca: findColumn(data, ['criança/ estudante', 'crianca/ estudante', 'criança/estudante', 'crianca/estudante', 'criança', 'crianca', 'estud']),

          // Data da NT
          data: findColumn(data, ['data da nt', 'data nt', 'data da', 'data', 'dt']),

          // Idade
          idade: findColumn(data, ['idade']),

          // Identidade de Gênero
          genero: findColumn(data, ['identidade de gênero', 'identidade de genero', 'gênero', 'genero', 'sexo']),

          // É PCD/tem Transtorno?
          pcd: findColumn(data, ['é pcd/tem transtorno', 'e pcd/tem transtorno', 'pcd/tem transtorno', 'pcd', 'deficiência', 'deficiencia', 'transtorno']),

          // Qual o Transtorno?
          detalhePCD: findColumn(data, [
            'qual o transtorno',
            'qual transtorno',
            'transtorno',
            'detalhamento',
            'detalhamento pcd',
            'detalhamento transtorno',
            'tipo de deficiencia',
            'tipo de deficiência',
            'tipo de transtorno',
            'detalhamento de pcd',
            'detalhamento de transtorno'
          ]),

          // Raça/Cor
          raca: findColumn(data, ['raça/cor', 'raca/cor', 'raça', 'raca', 'cor']),

          // Qual a Orientação Sexual?
          orientacaoSexual: findColumn(data, ['qual a orientação sexual', 'qual a orientacao sexual', 'orientação sexual', 'orientacao sexual', 'orientação', 'orientacao']),

          // Tipo de Violência
          tipo: findColumn(data, ['tipo de violência', 'tipo de violencia', 'tipo']),

          // Tipo de Violência Institucional (coluna K)
          // OBS: Aceita tanto o novo cabeçalho quanto o antigo ("motivação da violência"),
          // mas SEMPRE trata essa coluna como detalhamento da violência institucional.
          tipoViolenciaInstitucional: findColumn(data, [
            // Novos nomes esperados
            'tipo de violência institucional',
            'tipo de violencia institucional',
            'violencia institucional',
            'violência institucional',
            'tipo violencia institucional',
            // Nomes antigos reaproveitados (motivação da violência)
            'qual a motivação da violencia',
            'qual a motivacao da violencia',
            'motivação da violencia',
            'motivacao da violencia',
            'motivação',
            'motivacao'
          ]),

          // Encaminhamento
          encaminhamento: findColumn(data, ['encaminhamento']),

          // CMEI/EMEF
          escola: findColumn(data, ['cmei/emef', 'cmei / emef', 'cmei', 'emef', 'escola']),

          // Região
          regiao: findColumn(data, ['região', 'regiao']),

          // Responsável pelo Registro
          responsavel: findColumn(data, ['responsável pelo registro', 'responsavel pelo registro', 'responsável', 'responsavel']),

          // fonte informadores foi a escola?
          fonteInformada: findColumn(data, ['fonte informadores foi a escola', 'fonte informadora foi a escola', 'fonte informada', 'fonte']),

          // violência identificada pela escola ocorrida na escola
          violenciaEscolaOcorreu: findColumn(data, ['violência identificada pela escola ocorrida na escola', 'violencia identificada pela escola ocorrida na escola', 'violencia identificada pela escola ocorrida']),

          // Algum profissional da escola foi autor da violência
          profissionalAutor: findColumn(data, ['algum profissional da escola foi autor da violência', 'algum profissional da escola foi autor', 'profissional da escola foi autor', 'profissional autor']),

          // Album estudante foi autor da violência?? (Algum)
          estudanteAutor: findColumn(data, ['album estudante foi autor da violência', 'algum estudante foi autor da violência', 'algum estudante foi autor', 'estudante foi autor', 'estudante autor']),

          // violência identificada pela escola não ocorrida na escola
          violenciaNaoEscola: findColumn(data, ['violência identificada pela escola não ocorrida na escola', 'violencia identificada pela escola nao ocorrida na escola', 'violência identificada pela escola não ocorrida', 'violencia nao ocorrida']),

          // ocorreu na escola? 1.1
          ocorreu: findColumn(data, ['ocorreu na escola? 1.1', 'ocorreu na escola', 'ocorreu']),

          // violência informada a escola por qualquer um dos agentes que a compõe 1.2
          violenciaInformada: findColumn(data, ['violência informada a escola por qualquer um dos agentes que a compõe', 'violencia informada a escola', 'violência informada à escola', 'violencia informada', 'violência informada']),

          // Estudo de Caso
          estudoCaso: findColumn(data, [
            'foi realizado estudo de caso',
            'foi realizado estudo de caso?',
            'estudo de caso',
            'estudo caso',
            'estudo caso?',
            'estudo'
          ])
          ,
          // Foi um membro familiar?
          foiMembroFamiliar: findColumn(data, [
            'foi um membro familiar?',
            'foi um membro familiar',
            'membro familiar',
            'foi membro familiar',
            'membro da família',
            'membro da familia',
            'familiar',
            'foi familiar'
          ])
        };

        // Debug essencial (reduzido)
        console.log('Todas as colunas do primeiro registro:', Object.keys(data[0]));
        if (columnNames.genero && data.length > 0) {
          console.log('Exemplo de gênero (primeiro registro):', data[0][columnNames.genero]);
          console.log('Exemplo de gênero (segundo registro):', data[1] ? data[1][columnNames.genero] : 'N/A');
          console.log('Exemplo de gênero (terceiro registro):', data[2] ? data[2][columnNames.genero] : 'N/A');
        }
        if (columnNames.detalhePCD && data.length > 0) {
          console.log('Exemplo de detalhePCD (primeiro registro):', data[0][columnNames.detalhePCD]);
          console.log('Exemplo de detalhePCD (segundo registro):', data[1] ? data[1][columnNames.detalhePCD] : 'N/A');
          console.log('Exemplo de detalhePCD (terceiro registro):', data[2] ? data[2][columnNames.detalhePCD] : 'N/A');
        }

        // Verifica se está pegando a coluna errada
        if (columnNames.genero === 'Idade') {
          console.warn('⚠️ ERRO: Gênero está mapeado para coluna Idade!');
          // Tenta encontrar pela letra da coluna
          const primeiroRegistro = data[0];
          const colunas = Object.keys(primeiroRegistro);
          console.log('Colunas disponíveis:', colunas);

          // Procura coluna que contenha apenas M ou F
          for (const col of colunas) {
            const valores = data.slice(0, 10).map(row => String(row[col] || '').trim().toUpperCase());
            const todosMouF = valores.every(v => v === '' || v === 'M' || v === 'F');
            if (todosMouF && valores.some(v => v === 'M' || v === 'F')) {
              console.log(`✓ Coluna candidata para gênero: "${col}" - valores:`, valores);
            }
          }
        }

        console.log('=== FIM DEBUG ===');

        // Atualiza variáveis globais para dashboard-stats.js
        window.columnNames = columnNames;

        updateUploadStatus('success', `✅ Arquivo carregado – ${data.length} registros`);

        initializeFilters(data);

        document.getElementById('filtersSection').classList.remove('hidden');
        document.getElementById('statsSection').classList.remove('hidden');
        document.getElementById('chartsSection').classList.remove('hidden');
        document.getElementById('resultsSection').classList.remove('hidden');
        document.getElementById('dashboardExecutivo').classList.remove('hidden');

        // Resetar para primeira página ao carregar dados
        paginaAtual = 1;

        renderStats(filteredData);
        renderCharts(filteredData);
        renderTable(filteredData);

        // Atualiza KPIs do Dashboard Executivo
        setTimeout(() => {
          if (typeof atualizarKPIs === 'function') {
            atualizarKPIs();
          }
        }, 500);
      }

      function updateUploadStatus(type, message) {
        const statusDiv = document.getElementById('uploadStatus');
        statusDiv.textContent = message;
        statusDiv.className = 'p-4 rounded-md';

        if (type === 'loading') {
          statusDiv.classList.add('bg-blue-50', 'text-blue-700');
        } else if (type === 'success') {
          statusDiv.classList.add('bg-green-50', 'text-green-700');
        } else if (type === 'error') {
          statusDiv.classList.add('bg-red-50', 'text-red-700');
        } else {
          statusDiv.classList.add('bg-gray-50', 'text-gray-600');
        }
      }

      // ==============================
      // Filtros
      // ==============================
      function initializeFilters(data) {
        if (columnNames.regiao) {
          const valores = buildNormalizedOptions(columnNames.regiao, data);
          createCheckboxes('filterRegiaoContainer', valores, 'regiao');
        }
        if (columnNames.tipo) {
          // Usa função específica que NÃO separa por barra (mantém "Financeira/Econômica" junto)
          const valores = buildNormalizedOptionsTipoViolencia(columnNames.tipo, data);

          // REDESIGN: Usa cards de violência ao invés de checkboxes simples
          createViolenceTypeCards('filterTipoViolenciaContainer', valores, 'tipoViolencia');

          // Verifica inicialmente se há "Institucional" já selecionado
          setTimeout(verificarViolenciaInstitucionalNoFiltro, 500);
        }
        if (columnNames.escola) {
          // Filtro por tipo de instituição (CMEI/EMEF/Não Encontrada)
          const tiposSet = new Set();
          data.forEach(row => {
            const tipo = getTipoInstituicao(row[columnNames.escola]);
            if (tipo) {
              tiposSet.add(tipo);
            } else if (row[columnNames.escola]) {
              tiposSet.add('Não Encontrada');
            }
          });
          const tiposInstituicao = Array.from(tiposSet).sort();
          createCheckboxes('filterTipoInstituicaoContainer', tiposInstituicao, 'tipoInstituicao');

          // Filtro por escola específica
          const valores = buildNormalizedOptions(columnNames.escola, data);
          createCheckboxes('filterEscolaContainer', valores, 'escola');
        }
        if (columnNames.encaminhamento) {
          const valores = buildNormalizedOptions(columnNames.encaminhamento, data);
          buildEncaminhamentoGroups(valores);
        }
        if (columnNames.raca) {
          const valores = buildNormalizedOptions(columnNames.raca, data);
          createCheckboxes('filterRacaContainer', valores, 'raca');
        }
        if (columnNames.genero) {
          const valores = buildGeneroOptions(data); // Função específica para gênero
          createCheckboxes('filterGeneroContainer', valores, 'genero');
        }

        // NOVO FILTRO: Tipo de deficiência/transtorno
        // Gera automaticamente as opções a partir da coluna detalhePCD
        // Suporta valores múltiplos separados por vírgula
        // APLICA NORMALIZAÇÃO para unificar variações (TDAH/TDH/tdh, etc.)
        if (columnNames.detalhePCD) {
          const valoresBrutos = buildNormalizedOptions(columnNames.detalhePCD, data);
          const valoresNormalizados = normalizarListaTranstornos(valoresBrutos);
          createCheckboxes('filterTipoDeficienciaContainer', valoresNormalizados, 'tipoDeficiencia');
        }

        // NOVO FILTRO: Orientação Sexual
        if (columnNames.orientacaoSexual) {
          const valores = buildNormalizedOptions(columnNames.orientacaoSexual, data);
          createCheckboxes('filterOrientacaoContainer', valores, 'orientacao');
        }

        // NOVO FILTRO: Violências Institucionais (agrupadas, similar aos encaminhamentos)
        // Só constrói os grupos se a coluna existir (mas o card só aparece quando "Institucional" está selecionado)
        if (columnNames.tipoViolenciaInstitucional) {
          buildViolenciaInstitucionalGroups(data);
        }

        // Verifica se "Institucional" já está selecionado ao carregar os dados
        setTimeout(verificarViolenciaInstitucionalNoFiltro, 1000);


        // Adiciona o filtro de membro familiar
        const filterIds = [
          'filterPCD', 'filterOcorreuEscola',
          'filterFonteInformada', 'filterViolenciaEscolaOcorreu', 'filterProfissionalAutor',
          'filterEstudanteAutor', 'filterViolenciaNaoEscola', 'filterViolenciaInformada', 'filterEstudoCaso',
          'filterIdadeMin', 'filterIdadeMax', 'filterNome',
          'filterDataInicio', 'filterDataFim', 'filterTI',
          'filterMembroFamiliar' // <-- Adicionado aqui
        ];

        filterIds.forEach(id => {
          const element = document.getElementById(id);
          if (element) {
            // Para inputs type="date", usar 'change' ao invés de 'input'
            const eventType = (element.type === 'date') ? 'change' :
              (element.tagName === 'INPUT') ? 'input' : 'change';
            element.addEventListener(eventType, applyFilters);
          }
        });

        // Inicializa estado do gráfico
        window.chartTipoViolenciaType = 'pie';

        // Configura botão de toggle
        const btnToggle = document.getElementById('btnToggleChartType');
        if (btnToggle) {
          btnToggle.addEventListener('click', function () {
            const isPie = window.chartTipoViolenciaType === 'pie';

            // Alterna estado
            window.chartTipoViolenciaType = isPie ? 'bar' : 'pie';

            // Atualiza texto do botão
            this.textContent = isPie ? 'Mudar para Pizza' : 'Mudar para Barras';

            // Re-renderiza gráficos se houver dados
            if (window.filteredData) {
              renderCharts(window.filteredData);
            }
          });
        }

        // Inicializa estado do gráfico Institucional
        window.chartViolenciaInstitucionalType = 'pie';

        // Configura botão de toggle Institucional
        const btnToggleInst = document.getElementById('btnToggleChartInstType');
        if (btnToggleInst) {
          btnToggleInst.addEventListener('click', function () {
            const isPie = window.chartViolenciaInstitucionalType === 'pie';

            // Alterna estado
            window.chartViolenciaInstitucionalType = isPie ? 'bar' : 'pie';

            // Atualiza texto do botão
            this.textContent = isPie ? 'Mudar para Pizza' : 'Mudar para Barras';

            // Re-renderiza gráficos se houver dados
            if (window.filteredData) {
              renderCharts(window.filteredData);
            }
          });
        }

        // ===============================================
        // ORQUESTRAÇÃO DE EXPORTAÇÃO PDF DUPLA (PIZZA E BARRAS)
        // ===============================================
        window.handleExportPDF = async function () {
          try {
            if (!window.filteredData || window.filteredData.length === 0) {
              alert('Não há dados filtrados para exportar.');
              return;
            }

            console.log('🚀 Iniciando exportação inteligente de PDF...');

            // Guarda estado original dos tipos de gráfico
            const originalTipoType = window.chartTipoViolenciaType;
            const originalInstType = window.chartViolenciaInstitucionalType;

            // Objeto para acumular todas as imagens
            const allImages = {};

            // 1. Captura gráficos "padrão" (aqueles que não mudam de tipo)
            // Renderiza estado atual para garantir
            renderCharts(window.filteredData);
            await new Promise(r => setTimeout(r, 800)); // Aguarda animação
            let standardImages = capturarGraficosComoImagens();
            Object.assign(allImages, standardImages);

            // 2. Captura "Tipos de Violência" - Versão PIZZA
            window.chartTipoViolenciaType = 'pie';
            renderCharts(window.filteredData);
            await new Promise(r => setTimeout(r, 600)); // Aguarda render
            const pieCanvas = document.getElementById('chartTipoViolencia');
            if (pieCanvas && pieCanvas.width > 0) {
              allImages['chartTipoViolencia_pie'] = pieCanvas.toDataURL('image/png');
            }

            // 3. Captura "Tipos de Violência" - Versão BARRAS
            window.chartTipoViolenciaType = 'bar';
            renderCharts(window.filteredData);
            await new Promise(r => setTimeout(r, 600)); // Aguarda render
            const barCanvas = document.getElementById('chartTipoViolencia');
            if (barCanvas && barCanvas.width > 0) {
              allImages['chartTipoViolencia_bar'] = barCanvas.toDataURL('image/png');
            }

            // 4. Captura "Violência Institucional" - Versão PIZZA (se visível/relevante)
            const instContainer = document.getElementById('containerChartViolenciaInstitucional');
            if (instContainer && !instContainer.classList.contains('hidden')) {
              window.chartViolenciaInstitucionalType = 'pie';
              renderCharts(window.filteredData);
              await new Promise(r => setTimeout(r, 600)); // Aguarda render
              const instPieCanvas = document.getElementById('chartTipoViolenciaInstitucional');
              if (instPieCanvas && instPieCanvas.width > 0) {
                allImages['chartTipoViolenciaInstitucional_pie'] = instPieCanvas.toDataURL('image/png');
              }

              // 5. Captura "Violência Institucional" - Versão BARRAS
              window.chartViolenciaInstitucionalType = 'bar';
              renderCharts(window.filteredData);
              await new Promise(r => setTimeout(r, 600)); // Aguarda render
              const instBarCanvas = document.getElementById('chartTipoViolenciaInstitucional');
              if (instBarCanvas && instBarCanvas.width > 0) {
                // Tenta capturar. Se não tiver dados, o renderCharts pode ter destruído o chart, 
                // mas a verificação de container visível acima deve prever isso.
                allImages['chartTipoViolenciaInstitucional_bar'] = instBarCanvas.toDataURL('image/png');
              }
            }

            // 6. Restaura estado original e re-renderiza para o usuário não perceber a "bagunça"
            window.chartTipoViolenciaType = originalTipoType;
            window.chartViolenciaInstitucionalType = originalInstType;
            renderCharts(window.filteredData);

            // 7. Chama a função de exportação real passando as imagens customizadas
            console.log('📦 Imagens preparadas para PDF:', Object.keys(allImages));
            exportarPDF(allImages);

          } catch (error) {
            console.error('Erro na orquestração do PDF:', error);
            alert('Ocorreu um erro ao preparar o PDF. Tente novamente.');
            // Tenta restaurar estado em caso de erro
            if (typeof window.chartTipoViolenciaType !== 'undefined') {
              renderCharts(window.filteredData);
            }
          }
        };



        // ===============================================
        // VINCULAÇÃO ROBUSTA DO BOTÃO DE EXPORTAÇÃO
        // ===============================================
        (function bindExportBtn() {
          const btn = document.getElementById('btnExportarPDF');
          if (btn) {
            console.log('✅ Botão Exportar PDF encontrado. Vinculando...');
            // Usa capture: true para garantir que pegamos o evento primeiro
            btn.addEventListener('click', (e) => {
              e.preventDefault();
              e.stopImmediatePropagation();
              window.handleExportPDF();
            }, { capture: true });
          } else {
            // Tenta novamente se o botão ainda não existir (ex: carregamento dinâmico)
            setTimeout(bindExportBtn, 500);
          }
        })();

        function syncConditionalOcorreuEscola() {
          const violenciaInformadaEl = document.getElementById('filterViolenciaInformada');
          const ocorreuContainer = document.getElementById('filterOcorreuEscolaContainer');
          const ocorreuSelect = document.getElementById('filterOcorreuEscola');
          if (!violenciaInformadaEl || !ocorreuContainer || !ocorreuSelect) return;

          const shouldShow = String(violenciaInformadaEl.value || '') === 'S';

          const isHidden = ocorreuContainer.classList.contains('hidden');
          const isAnimating = ocorreuContainer.classList.contains('is-animating');

          const animateIn = () => {
            if (isAnimating) return;
            ocorreuContainer.classList.add('is-animating');
            ocorreuContainer.classList.remove('hidden');

            // Estado inicial: "de dentro" (contraído e levemente acima)
            ocorreuContainer.style.height = '0px';
            ocorreuContainer.style.opacity = '0';
            ocorreuContainer.style.transform = 'translateY(-8px) scaleY(0.98)';

            // Força layout
            void ocorreuContainer.offsetHeight;

            const target = ocorreuContainer.scrollHeight;
            ocorreuContainer.style.transition = 'height 260ms cubic-bezier(0.16, 1, 0.3, 1), opacity 200ms ease, transform 260ms cubic-bezier(0.16, 1, 0.3, 1)';

            requestAnimationFrame(() => {
              ocorreuContainer.style.height = `${target}px`;
              ocorreuContainer.style.opacity = '1';
              ocorreuContainer.style.transform = 'translateY(0) scaleY(1)';
            });

            const onEnd = (ev) => {
              if (ev && ev.target !== ocorreuContainer) return;
              ocorreuContainer.removeEventListener('transitionend', onEnd);
              ocorreuContainer.style.transition = '';
              ocorreuContainer.style.height = '';
              ocorreuContainer.style.opacity = '';
              ocorreuContainer.style.transform = '';
              ocorreuContainer.classList.remove('is-animating');
              ocorreuContainer.style.overflow = '';
            };
            ocorreuContainer.addEventListener('transitionend', onEnd);
            setTimeout(() => onEnd({ target: ocorreuContainer }), 320);
          };

          const animateOut = () => {
            if (isAnimating) return;
            ocorreuContainer.classList.add('is-animating');

            const start = ocorreuContainer.getBoundingClientRect().height;
            ocorreuContainer.style.height = `${Math.max(0, start)}px`;
            ocorreuContainer.style.opacity = '1';
            ocorreuContainer.style.transform = 'translateY(0) scaleY(1)';

            // Força layout
            void ocorreuContainer.offsetHeight;

            ocorreuContainer.style.transition = 'height 220ms ease, opacity 160ms ease, transform 220ms ease';
            requestAnimationFrame(() => {
              ocorreuContainer.style.height = '0px';
              ocorreuContainer.style.opacity = '0';
              ocorreuContainer.style.transform = 'translateY(-8px) scaleY(0.98)';
            });

            const onEnd = (ev) => {
              if (ev && ev.target !== ocorreuContainer) return;
              ocorreuContainer.removeEventListener('transitionend', onEnd);
              ocorreuContainer.style.transition = '';
              ocorreuContainer.style.height = '';
              ocorreuContainer.style.opacity = '';
              ocorreuContainer.style.transform = '';
              ocorreuContainer.classList.remove('is-animating');
              ocorreuContainer.style.overflow = '';
              ocorreuContainer.classList.add('hidden');
            };
            ocorreuContainer.addEventListener('transitionend', onEnd);
            setTimeout(() => onEnd({ target: ocorreuContainer }), 280);
          };

          if (shouldShow) {
            ocorreuSelect.disabled = false;
            if (isHidden) animateIn();
          } else {
            ocorreuSelect.disabled = true;
            if (ocorreuSelect.value) {
              ocorreuSelect.value = '';
              ocorreuSelect.dispatchEvent(new Event('change', { bubbles: true }));
            }
            if (!isHidden) animateOut();
          }
        }

        const violenciaInformadaEl = document.getElementById('filterViolenciaInformada');
        if (violenciaInformadaEl) {
          violenciaInformadaEl.addEventListener('change', syncConditionalOcorreuEscola);
        }
        syncConditionalOcorreuEscola();

        // Listener para filterPCD → toggleTipoDeficienciaSection
        const filterPCDElement = document.getElementById('filterPCD');
        if (filterPCDElement) {
          filterPCDElement.addEventListener('change', () => {
            toggleTipoDeficienciaSection();
            applyFilters();
          });
        }
        toggleTipoDeficienciaSection(); // Estado inicial

        // Event listener específico para o filtro TI com atualização de badge
        const filterTIElement = document.getElementById('filterTI');
        if (filterTIElement) {
          filterTIElement.addEventListener('change', function () {
            updateBadgeTI();
            applyFilters();
          });
        }

        document.getElementById('btnLimparFiltros').addEventListener('click', clearFilters);
        // Event listeners de exportação já estão configurados no window.addEventListener('load')
      }

      function populateSelect(selectId, options) {
        const select = document.getElementById(selectId);
        const firstOption = select.options[0] || null;
        select.innerHTML = '';
        if (firstOption) {
          select.appendChild(firstOption);
        }
        options.forEach(opt => {
          const option = document.createElement('option');
          option.value = opt;
          option.textContent = opt;
          select.appendChild(option);
        });
      }

      // S/N
      function checkSN(value, filterValue) {
        if (!filterValue) return true;
        const val = String(value || '').toUpperCase().trim();
        if (!val) return false;
        const f = filterValue.toUpperCase();
        if (f === 'S') {
          return val === 'S' || val === 'SIM';
        }
        if (f === 'N') {
          return val === 'N' || val === 'NAO' || val === 'NÃO';
        }
        return false;
      }

      // ============================================
      // CONDICIONAL: filterPCD → section-tipoDeficiencia
      // ============================================
      function toggleTipoDeficienciaSection() {
        const filterPCD = document.getElementById('filterPCD');
        const sectionTipoDeficiencia = document.getElementById('section-tipoDeficiencia');

        if (!filterPCD || !sectionTipoDeficiencia) return;

        if (filterPCD.value === 'S') {
          sectionTipoDeficiencia.classList.remove('hidden');
        } else {
          sectionTipoDeficiencia.classList.add('hidden');
        }
      }

      function applyFilters() {
        const filters = {
          regioes: getCheckedValues('regiao'),
          tipos: getCheckedValues('tipoViolencia'),
          tiposInstituicao: getCheckedValues('tipoInstituicao'),
          escolas: getCheckedValues('escola'),
          encaminhamentos: gatherSelectedEncaminhamentos(),
          racas: getCheckedValues('raca'),
          generos: getCheckedValues('genero'),

          // NOVO FILTRO: Tipos de deficiência/transtorno selecionados
          tiposDeficiencia: getCheckedValues('tipoDeficiencia'),

          // NOVOS FILTROS
          orientacoes: getCheckedValues('orientacao'),
          violenciasInstitucionais: gatherSelectedViolenciasInstitucionais(),

          pcd: document.getElementById('filterPCD').value,
          ocorreu: document.getElementById('filterOcorreuEscola').value,
          fonteInformada: document.getElementById('filterFonteInformada').value,
          violenciaEscolaOcorreu: document.getElementById('filterViolenciaEscolaOcorreu').value,
          profissionalAutor: document.getElementById('filterProfissionalAutor').value,
          estudanteAutor: document.getElementById('filterEstudanteAutor').value,
          violenciaNaoEscola: document.getElementById('filterViolenciaNaoEscola').value,
          violenciaInformada: document.getElementById('filterViolenciaInformada').value,

          estudoCaso: document.getElementById('filterEstudoCaso').value,

          // NOVO FILTRO: Foi um membro familiar?
          membroFamiliar: document.getElementById('filterMembroFamiliar').value,

          idadeMin: document.getElementById('filterIdadeMin').value,
          idadeMax: document.getElementById('filterIdadeMax').value,

          nome: document.getElementById('filterNome').value.toLowerCase(),

          dataInicio: document.getElementById('filterDataInicio').value,
          dataFim: document.getElementById('filterDataFim').value
        };

        const dataInicioDate = filters.dataInicio ? new Date(filters.dataInicio + 'T00:00:00') : null;
        const dataFimDate = filters.dataFim ? new Date(filters.dataFim + 'T23:59:59') : null;

        filteredData = originalData.filter(row => {

          // FILTRO: Foi um membro familiar?
          // Opções: '' (Todos), 'Sim', 'Não', 'naoinformado'
          if (filters.membroFamiliar && columnNames.foiMembroFamiliar) {
            const valor = String(row[columnNames.foiMembroFamiliar] || '').trim().toUpperCase();
            console.log('[Filtro Membro Familiar] Valor na linha:', valor, '| Filtro selecionado:', filters.membroFamiliar);
            if (filters.membroFamiliar === 'Sim' && valor !== 'S') return false;
            if (filters.membroFamiliar === 'Não' && valor !== 'N') return false;
            if (filters.membroFamiliar === 'naoinformado' && valor !== '') return false;
          }
          // Multi (OU) - com suporte a campos multi-valor separados por vírgula
          if (filters.regioes.length && columnNames.regiao) {
            const rowVals = String(row[columnNames.regiao] || '').split(',').map(v => v.trim());
            const rowNorms = rowVals.map(v => normalizeText(v)).filter(v => v);
            const filterNorms = filters.regioes.map(v => normalizeText(v));
            const ok = rowNorms.some(rn => filterNorms.includes(rn));
            if (!ok) return false;
          }
          if (filters.tipos.length && columnNames.tipo) {
            // Filtro de Tipo de Violência: NÃO separa por barra (/)
            // "Financeira/Econômica" é tratada como uma categoria única
            const rowVals = String(row[columnNames.tipo] || '')
              .split(',')
              .map(v => v.trim())
              .filter(v => v);

            const rowNorms = rowVals.map(v => normalizeText(v)).filter(v => v);
            const filterNorms = filters.tipos.map(v => normalizeText(v));
            const ok = rowNorms.some(rn => filterNorms.includes(rn));
            if (!ok) return false;
          }
          // Filtro por tipo de instituição (CMEI/EMEF/Não Encontrada)
          if (filters.tiposInstituicao.length && columnNames.escola) {
            const tipoEscola = getTipoInstituicao(row[columnNames.escola]);
            const tipoParaFiltro = tipoEscola || (row[columnNames.escola] ? 'Não Encontrada' : null);

            if (!tipoParaFiltro || !filters.tiposInstituicao.includes(tipoParaFiltro)) {
              return false;
            }
          }
          if (filters.escolas.length && columnNames.escola) {
            const rowVals = String(row[columnNames.escola] || '').split(',').map(v => v.trim());
            const rowNorms = rowVals.map(v => normalizeText(v)).filter(v => v);
            const filterNorms = filters.escolas.map(v => normalizeText(v));
            const ok = rowNorms.some(rn => filterNorms.includes(rn));
            if (!ok) return false;
          }

          // FILTRO: Tempo Integral (corrigido para usar sigla → nome completo)
          const selectTI = document.getElementById('filterTI');
          const filtroTI = selectTI ? selectTI.value : '';

          if (filtroTI && columnNames.escola) {
            const escola = row[columnNames.escola]; // Sigla da escola (ex.: "ABS", "AA")

            if (filtroTI === 'TI') {
              // Só mantém registros de escolas de tempo integral
              if (!isTempoIntegral(escola)) {
                return false;
              }
            } else if (filtroTI === 'Regular') {
              // Só mantém registros de escolas que NÃO são TI
              if (isTempoIntegral(escola)) {
                return false;
              }
            }
            // Se filtroTI === '' → não filtra por tempo integral
          }

          if (filters.encaminhamentos.length && columnNames.encaminhamento) {
            if (!matchEncaminhamentoCell(row[columnNames.encaminhamento], filters.encaminhamentos)) {
              return false;
            }
          }
          if (filters.racas.length && columnNames.raca) {
            const rowVals = String(row[columnNames.raca] || '').split(',').map(v => v.trim());
            const rowNorms = rowVals.map(v => normalizeText(v)).filter(v => v);
            const filterNorms = filters.racas.map(v => normalizeText(v));
            const ok = rowNorms.some(rn => filterNorms.includes(rn));
            if (!ok) return false;
          }
          if (filters.generos.length && columnNames.genero) {
            // Para gênero (coluna D), verifica se é M ou F
            const rowValue = String(row[columnNames.genero] || '').trim().toUpperCase();
            const ok = filters.generos.some(v => v.toUpperCase() === rowValue);
            if (!ok) return false;
          }

          // NOVO FILTRO: Tipo de deficiência/transtorno
          // Este filtro trabalha em conjunto com o filtro de PCD
          // APLICA NORMALIZAÇÃO para que "TDAH", "TDH", "tdah" sejam considerados iguais
          if (filters.tiposDeficiencia.length && columnNames.detalhePCD) {
            // Se o usuário selecionou tipos de deficiência, o registro deve:
            // 1) Ser PCD (ter "S" ou "SIM" na coluna PCD)
            // 2) Ter um detalhamento que bata com as opções selecionadas

            // Verifica se é PCD
            const isPCD = checkSN(row[columnNames.pcd], 'S');
            if (!isPCD) return false; // Se não é PCD, não passa no filtro

            // Verifica se o detalhamento bate com alguma opção selecionada
            // Separa por vírgula E por barra (/) para considerar múltiplos transtornos
            const rowVals = String(row[columnNames.detalhePCD] || '')
              .split(',')
              .flatMap(v => v.split('/'))
              .map(v => v.trim())
              .filter(v => v);

            // APLICA NORMALIZAÇÃO aos valores do registro E aos filtros selecionados
            const rowNormalizados = rowVals.map(v => normalizarTranstorno(v));
            const filterNormalizados = filters.tiposDeficiencia; // Já vem normalizado do checkbox

            // Compara usando normalizeText para remover acentos e maiúsculas
            const rowNorms = rowNormalizados.map(v => normalizeText(v));
            const filterNorms = filterNormalizados.map(v => normalizeText(v));

            const ok = rowNorms.some(rn => filterNorms.includes(rn));
            if (!ok) return false;
          }

          // NOVO FILTRO: Orientação Sexual (OU)
          if (filters.orientacoes.length && columnNames.orientacaoSexual) {
            const rowVals = String(row[columnNames.orientacaoSexual] || '')
              .split(',')
              .flatMap(v => v.split('/'))
              .map(v => v.trim())
              .filter(v => v);

            const rowNorms = rowVals.map(v => normalizeText(v)).filter(v => v);
            const filterNorms = filters.orientacoes.map(v => normalizeText(v));
            const ok = rowNorms.some(rn => filterNorms.includes(rn));
            if (!ok) return false;
          }

          // FILTRO: Violências Institucionais
          // Aplica se o registro tem "Institucional" em tipoViolencia
          if (filters.violenciasInstitucionais && filters.violenciasInstitucionais.length > 0) {
            const tipoViolencia = String(row[columnNames.tipo] || '').toLowerCase();
            const temInstitucional = tipoViolencia.includes('institucional');

            if (!temInstitucional) {
              // Se não tem "Institucional" em tipoViolencia, não passa no filtro
              return false;
            }

            // Se tem "Institucional" em tipoViolencia, verifica o campo tipoViolenciaInstitucional
            if (columnNames.tipoViolenciaInstitucional) {
              const violenciaInstitucional = row[columnNames.tipoViolenciaInstitucional];

              // Se o campo está vazio, considera como "Não informado" e passa no filtro
              // (todos os registros com "Institucional" devem aparecer, mesmo sem detalhamento)
              if (!violenciaInstitucional || String(violenciaInstitucional).trim() === '') {
                // Campo vazio = "Não informado", passa no filtro
                // (todos os registros com violência institucional aparecem, independente do detalhamento)
              } else {
                // Se tem valor, verifica se corresponde aos filtros selecionados
                if (!matchViolenciaInstitucionalCell(violenciaInstitucional, filters.violenciasInstitucionais)) {
                  return false;
                }
              }
            }
          }

          // S/N
          if (filters.pcd && columnNames.pcd && !checkSN(row[columnNames.pcd], filters.pcd)) return false;

          // FILTRO: Ocorreu na escola - Combina colunas U (ocorreu) e Q (violenciaEscolaOcorreu)
          // Se o usuário filtrar "Sim", mostra registros onde U OU Q = Sim
          // Se o usuário filtrar "Não", mostra registros onde U E Q = Não
          // FILTRO: Ocorreu na Escola? - Combina colunas U e Q
          if (filters.ocorreu && filters.ocorreu !== '') {
            const ocorreuU = columnNames.ocorreu ? checkSN(row[columnNames.ocorreu], 'S') : false;
            const ocorreuQ = columnNames.violenciaEscolaOcorreu ? checkSN(row[columnNames.violenciaEscolaOcorreu], 'S') : false;
            const ocorreuNaEscola = ocorreuU || ocorreuQ;

            // Se filtro é 'S', precisa ter ocorrido na escola (U ou Q = 'S')
            if (filters.ocorreu === 'S' && !ocorreuNaEscola) return false;

            // Se filtro é 'N', precisa NÃO ter ocorrido na escola
            // Verifica se ambas colunas são 'N' ou vazias
            if (filters.ocorreu === 'N') {
              const naoOcorreuU = columnNames.ocorreu ? checkSN(row[columnNames.ocorreu], 'N') : true;
              const naoOcorreuQ = columnNames.violenciaEscolaOcorreu ? checkSN(row[columnNames.violenciaEscolaOcorreu], 'N') : true;
              // Se ocorreu na escola OU se nenhuma das colunas é 'N', não passa no filtro
              if (ocorreuNaEscola || (!naoOcorreuU && !naoOcorreuQ)) return false;
            }
          }

          if (filters.fonteInformada && columnNames.fonteInformada && !checkSN(row[columnNames.fonteInformada], filters.fonteInformada)) return false;

          // FILTRO: Violência identificada pela escola ocorrida na escola - Usa APENAS coluna Q
          if (filters.violenciaEscolaOcorreu && columnNames.violenciaEscolaOcorreu &&
            !checkSN(row[columnNames.violenciaEscolaOcorreu], filters.violenciaEscolaOcorreu)) return false;

          // FILTRO: Autor da Violência (colunas R e S)
          // Lógica: Se profissionalAutor = 'S', mostra apenas casos onde R = 'S' (independente de S)
          // Se estudanteAutor = 'S', mostra apenas casos onde S = 'S' (independente de R)
          // Se ambos = 'N', mostra apenas casos onde R = 'N' E S = 'N'
          if (filters.profissionalAutor && filters.profissionalAutor !== '') {
            if (columnNames.profissionalAutor) {
              const profissionalS = checkSN(row[columnNames.profissionalAutor], 'S');
              const profissionalN = checkSN(row[columnNames.profissionalAutor], 'N');

              if (filters.profissionalAutor === 'S' && !profissionalS) return false;
              if (filters.profissionalAutor === 'N' && !profissionalN) return false;
            }
          }

          if (filters.estudanteAutor && filters.estudanteAutor !== '') {
            if (columnNames.estudanteAutor) {
              const estudanteS = checkSN(row[columnNames.estudanteAutor], 'S');
              const estudanteN = checkSN(row[columnNames.estudanteAutor], 'N');

              if (filters.estudanteAutor === 'S' && !estudanteS) return false;
              if (filters.estudanteAutor === 'N' && !estudanteN) return false;
            }
          }

          // Caso especial: Se ambos estão definidos como 'N', significa "Outro Agente"
          // Ambos devem ser 'N' para passar no filtro
          if (filters.profissionalAutor === 'N' && filters.estudanteAutor === 'N') {
            if (columnNames.profissionalAutor && columnNames.estudanteAutor) {
              const profissionalN = checkSN(row[columnNames.profissionalAutor], 'N');
              const estudanteN = checkSN(row[columnNames.estudanteAutor], 'N');
              if (!profissionalN || !estudanteN) return false;
            }
          }
          if (filters.violenciaNaoEscola && columnNames.violenciaNaoEscola &&
            !checkSN(row[columnNames.violenciaNaoEscola], filters.violenciaNaoEscola)) return false;
          if (filters.violenciaInformada && columnNames.violenciaInformada &&
            !checkSN(row[columnNames.violenciaInformada], filters.violenciaInformada)) return false;
          if (filters.estudoCaso && columnNames.estudoCaso &&
            !checkSN(row[columnNames.estudoCaso], filters.estudoCaso)) return false;

          // Idade
          if (columnNames.idade) {
            const idade = parseInt(row[columnNames.idade], 10);
            if (filters.idadeMin && !isNaN(idade) && idade < parseInt(filters.idadeMin, 10)) return false;
            if (filters.idadeMax && !isNaN(idade) && idade > parseInt(filters.idadeMax, 10)) return false;
          }

          // Nome (contains)
          if (filters.nome && columnNames.crianca) {
            const nome = String(row[columnNames.crianca] || '').toLowerCase();
            if (!nome.includes(filters.nome)) return false;
          }

          // Data - usa coluna dataNT (Data da NT) ou data
          const dataColumn = columnNames.dataNT || columnNames.data;
          if ((dataInicioDate || dataFimDate) && dataColumn !== undefined) {
            const rowDate = parseDateCell(row[dataColumn]);
            // Se houver filtro de data mas o registro não tem data válida, exclui o registro
            if (!rowDate) {
              return false;
            }

            // Normaliza as datas para comparação (apenas dia/mês/ano, sem horas)
            const rowDateOnly = new Date(rowDate.getFullYear(), rowDate.getMonth(), rowDate.getDate());
            const dataInicioOnly = dataInicioDate ? new Date(dataInicioDate.getFullYear(), dataInicioDate.getMonth(), dataInicioDate.getDate()) : null;
            const dataFimDateOnly = dataFimDate ? new Date(dataFimDate.getFullYear(), dataFimDate.getMonth(), dataFimDate.getDate()) : null;

            if (dataInicioOnly && rowDateOnly < dataInicioOnly) return false;
            if (dataFimDateOnly && rowDateOnly > dataFimDateOnly) return false;
          }

          return true;
        });

        // Atualiza variável global para dashboard-stats.js
        window.filteredData = filteredData;

        // Resetar para primeira página ao aplicar filtros
        paginaAtual = 1;

        renderStats(filteredData);
        renderCharts(filteredData);
        renderTable(filteredData);

        // Atualiza KPIs após aplicar filtros
        setTimeout(() => {
          if (typeof atualizarKPIs === 'function') {
            atualizarKPIs();
          }
        }, 300);
        updateFilterCardBadges();
      }

      function clearFilters() {
        // Limpar checkboxes dos filtros avançados
        const allCheckboxes = document.querySelectorAll('.custom-checkbox');
        allCheckboxes.forEach(cb => {
          cb.checked = false;
          cb.indeterminate = false;
        });

        // Limpar badges
        const badges = document.querySelectorAll('.badge-count, .group-badge');
        badges.forEach(badge => badge.classList.add('hidden'));

        // Remover estados ativos dos cards
        const cards = document.querySelectorAll('.filter-card');
        cards.forEach(card => card.classList.remove('active'));

        // Esconder todas as seções
        const sections = document.querySelectorAll('.filter-section');
        sections.forEach(section => {
          section.classList.remove('show');
          section.classList.add('hidden');
        });

        // Limpar selects e inputs
        const filterIds = [
          'filterPCD', 'filterOcorreuEscola',
          'filterFonteInformada', 'filterViolenciaEscolaOcorreu', 'filterProfissionalAutor',
          'filterEstudanteAutor', 'filterViolenciaNaoEscola', 'filterViolenciaInformada',
          'filterIdadeMin', 'filterIdadeMax', 'filterNome',
          'filterDataInicio', 'filterDataFim', 'filterTI'
        ];

        filterIds.forEach(id => {
          const el = document.getElementById(id);
          if (!el) return;
          if (el.tagName === 'SELECT') {
            Array.from(el.options).forEach(o => o.selected = false);
          } else {
            el.value = '';
          }
        });

        // Reaplica regra do campo condicional (oculta e garante valor limpo)
        const violenciaInformadaEl = document.getElementById('filterViolenciaInformada');
        const ocorreuContainer = document.getElementById('filterOcorreuEscolaContainer');
        const ocorreuSelect = document.getElementById('filterOcorreuEscola');
        if (violenciaInformadaEl && ocorreuContainer && ocorreuSelect) {
          ocorreuContainer.classList.add('hidden');
          ocorreuSelect.disabled = true;
          ocorreuSelect.value = '';
        }

        // Resetar filtro condicional de tipo deficiência
        toggleTipoDeficienciaSection();

        filteredData = [...originalData];

        // Atualiza variável global para dashboard-stats.js
        window.filteredData = filteredData;

        // Esconde seção de Violências Institucionais ao limpar filtros
        const sectionViolenciaInstitucional = document.getElementById('section-violenciaInstitucional');
        if (sectionViolenciaInstitucional) {
          sectionViolenciaInstitucional.classList.add('hidden');
        }

        // Resetar para primeira página ao limpar filtros
        paginaAtual = 1;

        renderStats(filteredData);
        renderCharts(filteredData);
        renderTable(filteredData);

        // Atualiza KPIs após limpar filtros
        setTimeout(() => {
          if (typeof atualizarKPIs === 'function') {
            atualizarKPIs();
          }
        }, 300);

        ensureFilterCardBadges();
        updateFilterCardBadges();
      }

      // ==============================
      // Estatísticas / Tabela
      // ==============================
      function renderStats(data) {
        const total = originalData.length;
        const filtrados = data.length;

        document.getElementById('statTotal').textContent = total;
        document.getElementById('statFiltrados').textContent = filtrados;

        let countEscola = 0;
        // Considera AMBAS as colunas U (ocorreu na escola 1.1) e Q (violência identificada pela escola ocorrida na escola)
        // Se qualquer uma delas for 'S' ou 'Sim', conta como ocorrido na escola
        if (columnNames.ocorreu || columnNames.violenciaEscolaOcorreu) {
          countEscola = data.reduce((acc, row) => {
            const ocorreuU = columnNames.ocorreu ? checkSN(row[columnNames.ocorreu], 'S') : false;
            const ocorreuQ = columnNames.violenciaEscolaOcorreu ? checkSN(row[columnNames.violenciaEscolaOcorreu], 'S') : false;
            return acc + (ocorreuU || ocorreuQ ? 1 : 0);
          }, 0);
        }
        document.getElementById('statEscola').textContent = countEscola;

        const tiposDiv = document.getElementById('statTipos');
        tiposDiv.innerHTML = '';
        if (columnNames.tipo) {
          const mapa = {};
          data.forEach(row => {
            const tipo = row[columnNames.tipo];
            if (!tipo) return;
            const rotulo = String(tipo).trim();
            mapa[rotulo] = (mapa[rotulo] || 0) + 1;
          });
          const tipos = Object.keys(mapa).sort();
          if (tipos.length === 0) {
            tiposDiv.textContent = 'Nenhum tipo identificado nos registros filtrados.';
          } else {
            tipos.forEach(t => {
              const p = document.createElement('div');
              p.textContent = `${t}: ${mapa[t]}`;
              tiposDiv.appendChild(p);
            });
          }
        } else {
          tiposDiv.textContent = 'Coluna "Tipo de Violência" não encontrada.';
        }
      }

      // ==============================
      // Gráficos
      // ==============================
      function renderCharts(data) {
        // Cores para os gráficos
        const colors = [
          'rgba(59, 130, 246, 0.8)',   // azul
          'rgba(239, 68, 68, 0.8)',    // vermelho
          'rgba(34, 197, 94, 0.8)',    // verde
          'rgba(234, 179, 8, 0.8)',    // amarelo
          'rgba(168, 85, 247, 0.8)',   // roxo
          'rgba(236, 72, 153, 0.8)',   // rosa
          'rgba(20, 184, 166, 0.8)',   // teal
          'rgba(251, 146, 60, 0.8)',   // laranja
          'rgba(148, 163, 184, 0.8)',  // cinza
          'rgba(6, 182, 212, 0.8)'     // cyan
        ];

        // Gráfico: Tipos de Violência (normalizado)
        if (columnNames.tipo) {
          const dados = {};
          const mapaNormalizado = {}; // norm -> label original mais comum

          data.forEach(row => {
            const tipo = row[columnNames.tipo];
            if (tipo) {
              const original = String(tipo).trim();
              const norm = normalizeText(original);
              if (norm) {
                dados[norm] = (dados[norm] || 0) + 1;
                // Guarda o label original mais usado (capitalizado)
                if (!mapaNormalizado[norm] || original.length > mapaNormalizado[norm].length) {
                  mapaNormalizado[norm] = original;
                }
              }
            }
          });

          // Converte de volta para labels originais
          const sorted = Object.entries(dados)
            .map(([norm, count]) => [mapaNormalizado[norm] || norm, count])
            .sort((a, b) => b[1] - a[1]);

          // Verifica tipo de gráfico selecionado (global)
          if (window.chartTipoViolenciaType === 'bar') {
            renderHorizontalBarChart('chartTipoViolencia', sorted, colors);
          } else {
            renderPieChart('chartTipoViolencia', sorted, colors);
          }
        }

        // Gráfico: Tipos de Violência Institucional (normalizado)
        // Só renderiza se "Institucional" estiver selecionado no filtro de tipo de violência
        const containerChartViolenciaInst = document.getElementById('containerChartViolenciaInstitucional');
        const tipoViolenciaCheckboxes = document.querySelectorAll('input[data-filter="tipoViolencia"]:checked');
        const temInstitucional = Array.from(tipoViolenciaCheckboxes).some(cb => {
          const valor = (cb.dataset.value || '').toLowerCase();
          return valor === 'institucional' || valor.includes('institucional');
        });

        if (temInstitucional && columnNames.tipoViolenciaInstitucional) {
          // Mostra o container do gráfico
          if (containerChartViolenciaInst) {
            containerChartViolenciaInst.classList.remove('hidden');
          }

          const dados = {};
          const mapaNormalizado = {};

          // Filtra apenas registros que têm "Institucional" no tipo de violência
          // Usa os dados já filtrados (parâmetro 'data' da função renderCharts)
          const dataInstitucional = data.filter(row => {
            const tipoViolencia = row[columnNames.tipo];
            if (!tipoViolencia) return false;
            const tipoViolenciaStr = String(tipoViolencia).toLowerCase();
            return tipoViolenciaStr.includes('institucional');
          });

          dataInstitucional.forEach(row => {
            const tipoInst = row[columnNames.tipoViolenciaInstitucional];
            if (tipoInst) {
              const original = String(tipoInst).trim();
              const norm = normalizeText(original);
              if (norm) {
                dados[norm] = (dados[norm] || 0) + 1;
                // Guarda o label original mais usado (capitalizado)
                if (!mapaNormalizado[norm] || original.length > mapaNormalizado[norm].length) {
                  mapaNormalizado[norm] = original;
                }
              }
            }
          });

          // Converte de volta para labels originais
          const sorted = Object.entries(dados)
            .map(([norm, count]) => [mapaNormalizado[norm] || norm, count])
            .sort((a, b) => b[1] - a[1]);

          // Se houver dados, renderiza o gráfico
          if (sorted.length > 0) {
            // Verifica tipo de gráfico selecionado (global)
            if (window.chartViolenciaInstitucionalType === 'bar') {
              renderHorizontalBarChart('chartTipoViolenciaInstitucional', sorted, colors);
            } else {
              renderPieChart('chartTipoViolenciaInstitucional', sorted, colors);
            }
          } else {
            // Se não houver dados, mostra mensagem
            const canvas = document.getElementById('chartTipoViolenciaInstitucional');
            if (canvas && canvas.parentElement) {
              // Destroi o gráfico se existir
              if (charts['chartTipoViolenciaInstitucional']) {
                charts['chartTipoViolenciaInstitucional'].destroy();
                delete charts['chartTipoViolenciaInstitucional'];
              }
              canvas.parentElement.innerHTML = '<p class="text-gray-500 text-sm text-center mt-8">Nenhuma violência institucional encontrada nos dados filtrados.</p>';
            }
          }
        } else {
          // Esconde o container do gráfico se "Institucional" não estiver selecionado
          if (containerChartViolenciaInst) {
            containerChartViolenciaInst.classList.add('hidden');
          }
          // Destroi o gráfico se existir
          if (charts['chartTipoViolenciaInstitucional']) {
            charts['chartTipoViolenciaInstitucional'].destroy();
            delete charts['chartTipoViolenciaInstitucional'];
          }
        }

        // Gráfico: Por Região (normalizado)
        if (columnNames.regiao) {
          const dados = {};
          const mapaNormalizado = {};

          data.forEach(row => {
            const regiao = row[columnNames.regiao];
            if (regiao) {
              const original = String(regiao).trim();
              const norm = normalizeText(original);
              if (norm) {
                dados[norm] = (dados[norm] || 0) + 1;
                if (!mapaNormalizado[norm] || original.length > mapaNormalizado[norm].length) {
                  mapaNormalizado[norm] = original;
                }
              }
            }
          });

          const sorted = Object.entries(dados)
            .map(([norm, count]) => [mapaNormalizado[norm] || norm, count])
            .sort((a, b) => b[1] - a[1]);
          renderBarChart('chartRegiao', sorted, colors);
        }

        // Gráfico: Top 10 Escolas (normalizado)
        if (columnNames.escola) {
          const dados = {};
          const mapaNormalizado = {};

          data.forEach(row => {
            const escola = row[columnNames.escola];
            if (escola) {
              const original = String(escola).trim();
              const norm = normalizeText(original);
              if (norm) {
                dados[norm] = (dados[norm] || 0) + 1;
                if (!mapaNormalizado[norm] || original.length > mapaNormalizado[norm].length) {
                  mapaNormalizado[norm] = original;
                }
              }
            }
          });

          const sorted = Object.entries(dados)
            .map(([norm, count]) => [mapaNormalizado[norm] || norm, count])
            .sort((a, b) => b[1] - a[1])
            .slice(0, 10);
          renderBarChart('chartEscola', sorted, colors);
        }

        // Gráfico: Faixa Etária
        if (columnNames.idade) {
          const faixas = {
            '0-5 anos': 0,
            '6-10 anos': 0,
            '11-14 anos': 0,
            '15-17 anos': 0,
            '18+ anos': 0
          };

          data.forEach(row => {
            const idade = parseInt(row[columnNames.idade], 10);
            if (!isNaN(idade)) {
              if (idade <= 5) faixas['0-5 anos']++;
              else if (idade <= 10) faixas['6-10 anos']++;
              else if (idade <= 14) faixas['11-14 anos']++;
              else if (idade <= 17) faixas['15-17 anos']++;
              else faixas['18+ anos']++;
            }
          });

          const sorted = Object.entries(faixas).filter(([k, v]) => v > 0);
          renderBarChart('chartIdade', sorted, colors);
        }

        // Gráfico: Gênero (Coluna D: M ou F)
        if (columnNames.genero) {
          const dados = { 'F': 0, 'M': 0 };
          data.forEach(row => {
            const genero = row[columnNames.genero];
            if (genero) {
              const key = String(genero).trim().toUpperCase();
              if (key === 'F') dados['F']++;
              else if (key === 'M') dados['M']++;
            }
          });

          // Filtra apenas os que têm valores
          const sorted = Object.entries(dados).filter(([k, v]) => v > 0).sort((a, b) => b[1] - a[1]);
          renderPieChart('chartGenero', sorted, colors);
        }

        // Gráfico: Raça/Cor (normalizado)
        if (columnNames.raca) {
          const dados = {};
          const mapaNormalizado = {};

          data.forEach(row => {
            const raca = row[columnNames.raca];
            if (raca) {
              const original = String(raca).trim();
              const norm = normalizeText(original);
              if (norm) {
                dados[norm] = (dados[norm] || 0) + 1;
                if (!mapaNormalizado[norm] || original.length > mapaNormalizado[norm].length) {
                  mapaNormalizado[norm] = original;
                }
              }
            }
          });

          const sorted = Object.entries(dados)
            .map(([norm, count]) => [mapaNormalizado[norm] || norm, count])
            .sort((a, b) => b[1] - a[1]);
          renderPieChart('chartRaca', sorted, colors);
        }

        // Gráfico: Linha do Tempo (sem logs detalhados de datas)
        if (columnNames.data) {
          const porMes = {};
          data.forEach((row) => {
            const rawData = row[columnNames.data];
            const date = parseDateCell(rawData);
            if (date) {
              const mes = date.getMonth();
              const ano = date.getFullYear();
              const key = `${ano}-${String(mes + 1).padStart(2, '0')}`;
              porMes[key] = (porMes[key] || 0) + 1;
            }
          });
          const sorted = Object.entries(porMes).sort((a, b) => a[0].localeCompare(b[0]));
          console.log('Meses ordenados:', sorted);

          const labels = sorted.map(([key]) => {
            const [ano, mes] = key.split('-');
            const meses = ['Jan', 'Fev', 'Mar', 'Abr', 'Mai', 'Jun', 'Jul', 'Ago', 'Set', 'Out', 'Nov', 'Dez'];
            return `${meses[parseInt(mes) - 1]}/${ano}`;
          });
          const valores = sorted.map(([, v]) => v);

          console.log('Labels para gráfico:', labels);
          console.log('Valores para gráfico:', valores);
          console.log('=== FIM DEBUG GRÁFICO TEMPORAL ===');

          renderLineChart('chartTemporal', labels, valores);
        }

        // Gráfico: Encaminhamentos (agrupado por redes)
        if (columnNames.encaminhamento) {
          // Contagem por grupo de rede
          const dadosPorGrupo = {};

          data.forEach(row => {
            const encaminhamento = row[columnNames.encaminhamento];
            if (encaminhamento) {
              // Suporta valores múltiplos separados por vírgula e barra
              const valores = String(encaminhamento)
                .split(',')
                .flatMap(v => v.split('/'))
                .map(v => v.trim())
                .filter(v => v);

              valores.forEach(val => {
                const original = String(val).trim();
                const norm = normalizeText(original);

                if (norm) {
                  // Encontrar grupo
                  let grupoEncontrado = null;
                  for (const groupKey in encaminhamentosAgrupados) {
                    const children = encaminhamentosAgrupados[groupKey];
                    if (children.some(child => normalizeText(child) === norm)) {
                      grupoEncontrado = groupKey;
                      break;
                    }
                  }

                  // Se não encontrou grupo, usar "Outros"
                  if (!grupoEncontrado) {
                    grupoEncontrado = 'outros';
                  }

                  // Contagem por grupo
                  if (!dadosPorGrupo[grupoEncontrado]) {
                    dadosPorGrupo[grupoEncontrado] = 0;
                  }
                  dadosPorGrupo[grupoEncontrado]++;
                }
              });
            }
          });

          // Converter para array e ordenar
          const sorted = Object.entries(dadosPorGrupo)
            .map(([groupId, count]) => {
              const groupName = grupoNomes[groupId] || (groupId === 'outros' ? 'Outros Encaminhamentos' : groupId);
              return [groupName, count, groupId];
            })
            .sort((a, b) => b[1] - a[1]);

          if (sorted.length > 0) {
            // Usar cores diferentes para cada grupo
            const coresPorGrupo = {
              'redeAssistencia': 'rgba(59, 130, 246, 0.8)', // Azul
              'redeSaude': 'rgba(34, 197, 94, 0.8)', // Verde
              'redeEducacao': 'rgba(251, 146, 60, 0.8)', // Laranja
              'conselhoTutelar': 'rgba(168, 85, 247, 0.8)', // Roxo
              'redeSegurancaJustica': 'rgba(239, 68, 68, 0.8)', // Vermelho
              'outros': 'rgba(156, 163, 175, 0.8)' // Cinza
            };

            const cores = sorted.map(([, , groupId]) => coresPorGrupo[groupId] || coresPorGrupo['outros']);
            const dadosGrafico = sorted.map(([name, count]) => [name, count]);

            renderHorizontalBarChartGrouped('chartEncaminhamento', dadosGrafico, cores);
          }
        }

        // Gráfico: Autor da Violência (baseado nas colunas R e S)
        // Coluna R (profissionalAutor): 'S' = Profissional da Escola
        // Coluna S (estudanteAutor): 'S' = Estudante
        // Se ambas = 'N': Outro Agente (Fora da Instituição)
        if (columnNames.profissionalAutor || columnNames.estudanteAutor) {
          const dados = {
            'Profissional da Escola': 0,
            'Estudante': 0,
            'Outro Agente (Fora da Instituição)': 0,
            'Não Informado': 0
          };

          data.forEach(row => {
            const profissionalS = columnNames.profissionalAutor ? checkSN(row[columnNames.profissionalAutor], 'S') : false;
            const profissionalN = columnNames.profissionalAutor ? checkSN(row[columnNames.profissionalAutor], 'N') : false;
            const estudanteS = columnNames.estudanteAutor ? checkSN(row[columnNames.estudanteAutor], 'S') : false;
            const estudanteN = columnNames.estudanteAutor ? checkSN(row[columnNames.estudanteAutor], 'N') : false;

            // Se coluna R = 'S' → Profissional da Escola
            if (profissionalS) {
              dados['Profissional da Escola']++;
            }
            // Se coluna S = 'S' → Estudante
            else if (estudanteS) {
              dados['Estudante']++;
            }
            // Se ambas colunas R e S = 'N' → Outro Agente (Fora da Instituição)
            else if (profissionalN && estudanteN) {
              dados['Outro Agente (Fora da Instituição)']++;
            }
            // Caso contrário → Não Informado
            else {
              dados['Não Informado']++;
            }
          });

          const sorted = Object.entries(dados).filter(([k, v]) => v > 0);
          if (sorted.length > 0) {
            renderPieChart('chartAutor', sorted, colors);
          }
        }

        // Gráfico: Ocorreu na Escola? (Sim/Não)
        if (columnNames.ocorreu || columnNames.violenciaEscolaOcorreu) {
          const dados = {
            'Sim': 0,
            'Não': 0,
            'Não Informado': 0
          };

          data.forEach(row => {
            const ocorreuU = columnNames.ocorreu ? checkSN(row[columnNames.ocorreu], 'S') : false;
            const ocorreuQ = columnNames.violenciaEscolaOcorreu ? checkSN(row[columnNames.violenciaEscolaOcorreu], 'S') : false;
            const ocorreuNaEscola = ocorreuU || ocorreuQ;

            const naoOcorreuU = columnNames.ocorreu ? checkSN(row[columnNames.ocorreu], 'N') : false;
            const naoOcorreuQ = columnNames.violenciaEscolaOcorreu ? checkSN(row[columnNames.violenciaEscolaOcorreu], 'N') : false;
            const naoOcorreuNaEscola = naoOcorreuU && naoOcorreuQ;

            if (ocorreuNaEscola) {
              dados['Sim']++;
            } else if (naoOcorreuNaEscola) {
              dados['Não']++;
            } else {
              dados['Não Informado']++;
            }
          });

          const sorted = Object.entries(dados).filter(([k, v]) => v > 0);
          if (sorted.length > 0) {
            renderPieChart('chartOcorreuEscola', sorted, colors);
          }
        }

        // Gráfico: Correlação Tipo de Violência vs Faixa Etária
        if (columnNames.tipo && columnNames.idade) {
          const faixasEtarias = ['0-5', '6-10', '11-14', '15-17', '18+'];
          const tiposViolencia = {};
          const correlacao = {};

          // Primeiro, identifica todos os tipos de violência
          data.forEach(row => {
            const tipo = row[columnNames.tipo];
            if (tipo) {
              const tipoNorm = normalizeText(String(tipo).trim());
              if (tipoNorm && !tiposViolencia[tipoNorm]) {
                tiposViolencia[tipoNorm] = String(tipo).trim();
              }
            }
          });

          // Cria estrutura de correlação
          Object.keys(tiposViolencia).forEach(tipoNorm => {
            correlacao[tipoNorm] = {};
            faixasEtarias.forEach(faixa => {
              correlacao[tipoNorm][faixa] = 0;
            });
          });

          // Preenche os dados
          data.forEach(row => {
            const tipo = row[columnNames.tipo];
            const idade = row[columnNames.idade];

            if (tipo && idade) {
              const tipoNorm = normalizeText(String(tipo).trim());
              if (!tipoNorm) return;

              const idadeNum = parseInt(String(idade).trim(), 10);
              if (isNaN(idadeNum)) return;

              let faixa = '18+';
              if (idadeNum <= 5) faixa = '0-5';
              else if (idadeNum <= 10) faixa = '6-10';
              else if (idadeNum <= 14) faixa = '11-14';
              else if (idadeNum <= 17) faixa = '15-17';

              if (correlacao[tipoNorm] && correlacao[tipoNorm][faixa] !== undefined) {
                correlacao[tipoNorm][faixa]++;
              }
            }
          });

          // Prepara dados para o gráfico (top 5 tipos mais frequentes)
          const tiposOrdenados = Object.entries(tiposViolencia)
            .map(([norm, original]) => {
              const total = faixasEtarias.reduce((sum, faixa) => sum + (correlacao[norm]?.[faixa] || 0), 0);
              return { norm, original, total };
            })
            .sort((a, b) => b.total - a.total)
            .slice(0, 5);

          if (tiposOrdenados.length > 0) {
            const datasets = faixasEtarias.map((faixa, idx) => {
              return {
                label: faixa + ' anos',
                data: tiposOrdenados.map(({ norm }) => correlacao[norm]?.[faixa] || 0),
                backgroundColor: colors[idx % colors.length],
                borderColor: colors[idx % colors.length].replace('0.8', '1'),
                borderWidth: 2
              };
            });

            const labels = tiposOrdenados.map(({ original }) => original);
            renderGroupedBarChart('chartCorrelacaoTipoIdade', labels, datasets);
          }
        }

        // Gráfico: Comparativo Temporal (Últimos 6 Meses vs Período Anterior)
        if (columnNames.data || columnNames.dataNT) {
          const dataCol = columnNames.data || columnNames.dataNT;
          const agora = new Date();
          const mesAtual = agora.getMonth();
          const anoAtual = agora.getFullYear();

          // Função auxiliar para calcular mês e ano corretamente
          const calcularMesAno = (mesesAtras) => {
            const dataAlvo = new Date(anoAtual, mesAtual - mesesAtras, 1);
            return {
              mes: dataAlvo.getMonth(),
              ano: dataAlvo.getFullYear()
            };
          };

          // Últimos 6 meses (0 a 5 meses atrás)
          const ultimos6Meses = {};
          for (let i = 0; i < 6; i++) {
            const { mes, ano } = calcularMesAno(i);
            const key = `${ano}-${String(mes + 1).padStart(2, '0')}`;
            ultimos6Meses[key] = { mes, ano, count: 0 };
          }

          // Período anterior (6 a 11 meses atrás)
          const periodoAnterior = {};
          for (let i = 6; i < 12; i++) {
            const { mes, ano } = calcularMesAno(i);
            const key = `${ano}-${String(mes + 1).padStart(2, '0')}`;
            periodoAnterior[key] = { mes, ano, count: 0 };
          }

          // Conta os casos - INCLUI TODOS os dados que caem nos períodos
          data.forEach(row => {
            const rawData = row[dataCol];
            if (!rawData) return;

            const date = parseDateCell(rawData);
            if (!date || isNaN(date.getTime())) return;

            const rowMes = date.getMonth();
            const rowAno = date.getFullYear();
            const key = `${rowAno}-${String(rowMes + 1).padStart(2, '0')}`;

            // Verifica se o registro cai em algum dos períodos definidos
            if (ultimos6Meses[key]) {
              ultimos6Meses[key].count++;
            } else if (periodoAnterior[key]) {
              periodoAnterior[key].count++;
            }
          });

          // Prepara dados para o gráfico
          const meses = ['Jan', 'Fev', 'Mar', 'Abr', 'Mai', 'Jun', 'Jul', 'Ago', 'Set', 'Out', 'Nov', 'Dez'];
          const labels = [];
          const dadosUltimos6 = [];
          const dadosAnterior = [];

          // Ordena por data (mais antigo primeiro)
          const sortedUltimos6 = Object.entries(ultimos6Meses)
            .sort((a, b) => a[0].localeCompare(b[0]));
          const sortedAnterior = Object.entries(periodoAnterior)
            .sort((a, b) => a[0].localeCompare(b[0]));

          // Cria um mapa do período anterior usando a chave completa (ano-mês)
          const anteriorPorChave = {};
          sortedAnterior.forEach(([key, { mes, ano, count }]) => {
            anteriorPorChave[key] = count;
          });

          // Alinha os dados: para cada mês dos últimos 6, busca o mês correspondente do período anterior
          // O período anterior é exatamente 6 meses antes, então precisamos mapear corretamente
          sortedUltimos6.forEach(([keyUltimos6, { mes: mesUltimos6, ano: anoUltimos6, count: countUltimos6 }]) => {
            // Calcula o mês correspondente no período anterior (6 meses antes)
            const dataAnterior = new Date(anoUltimos6, mesUltimos6 - 6, 1);
            const mesAnterior = dataAnterior.getMonth();
            const anoAnterior = dataAnterior.getFullYear();
            const keyAnterior = `${anoAnterior}-${String(mesAnterior + 1).padStart(2, '0')}`;

            labels.push(meses[mesUltimos6]);
            dadosUltimos6.push(countUltimos6);
            // Busca o count do período anterior usando a chave calculada
            dadosAnterior.push(anteriorPorChave[keyAnterior] || 0);
          });

          if (labels.length > 0) {
            // Calcula os períodos reais para as legendas dinâmicas
            const primeiroMesUltimos6 = sortedUltimos6[0][1].mes;
            const ultimoMesUltimos6 = sortedUltimos6[sortedUltimos6.length - 1][1].mes;
            const primeiroAnoUltimos6 = sortedUltimos6[0][1].ano;
            const ultimoAnoUltimos6 = sortedUltimos6[sortedUltimos6.length - 1][1].ano;

            const primeiroMesAnterior = sortedAnterior[0][1].mes;
            const ultimoMesAnterior = sortedAnterior[sortedAnterior.length - 1][1].mes;
            const primeiroAnoAnterior = sortedAnterior[0][1].ano;
            const ultimoAnoAnterior = sortedAnterior[sortedAnterior.length - 1][1].ano;

            // Cria labels dinâmicas
            let labelUltimos6 = '';
            let labelAnterior = '';

            // Se os meses estão no mesmo ano
            if (primeiroAnoUltimos6 === ultimoAnoUltimos6) {
              labelUltimos6 = `${meses[primeiroMesUltimos6]}-${meses[ultimoMesUltimos6]} ${ultimoAnoUltimos6}`;
            } else {
              labelUltimos6 = `${meses[primeiroMesUltimos6]} ${primeiroAnoUltimos6} - ${meses[ultimoMesUltimos6]} ${ultimoAnoUltimos6}`;
            }

            if (primeiroAnoAnterior === ultimoAnoAnterior) {
              labelAnterior = `${meses[primeiroMesAnterior]}-${meses[ultimoMesAnterior]} ${ultimoAnoAnterior}`;
            } else {
              labelAnterior = `${meses[primeiroMesAnterior]} ${primeiroAnoAnterior} - ${meses[ultimoMesAnterior]} ${ultimoAnoAnterior}`;
            }

            renderComparativeLineChart('chartComparativoTemporal', labels, dadosUltimos6, dadosAnterior, labelUltimos6, labelAnterior);
          }
        }

        // Gráfico: Tendência Anual (Comparação Ano Atual vs Ano Anterior)
        if (columnNames.data || columnNames.dataNT) {
          const dataCol = columnNames.data || columnNames.dataNT;
          const agora = new Date();
          const anoAtual = agora.getFullYear();
          const anoAnterior = anoAtual - 1;

          const dadosAnoAtual = {};
          const dadosAnoAnterior = {};

          // Inicializa todos os meses
          for (let mes = 0; mes < 12; mes++) {
            dadosAnoAtual[mes] = 0;
            dadosAnoAnterior[mes] = 0;
          }

          // Conta os casos
          data.forEach(row => {
            const rawData = row[dataCol];
            if (!rawData) return;

            const date = parseDateCell(rawData);
            if (!date || isNaN(date.getTime())) return;

            const rowMes = date.getMonth();
            const rowAno = date.getFullYear();

            if (rowAno === anoAtual && dadosAnoAtual[rowMes] !== undefined) {
              dadosAnoAtual[rowMes]++;
            } else if (rowAno === anoAnterior && dadosAnoAnterior[rowMes] !== undefined) {
              dadosAnoAnterior[rowMes]++;
            }
          });

          // Prepara dados para o gráfico
          const meses = ['Jan', 'Fev', 'Mar', 'Abr', 'Mai', 'Jun', 'Jul', 'Ago', 'Set', 'Out', 'Nov', 'Dez'];
          const labels = meses;
          const dadosAtual = Object.values(dadosAnoAtual);
          const dadosAnterior = Object.values(dadosAnoAnterior);

          renderComparativeLineChart('chartTendenciaAnual', labels, dadosAtual, dadosAnterior, `Ano ${anoAtual}`, `Ano ${anoAnterior}`);
        }
      }

      // Função para aplicar filtros baseado no clique do gráfico
      function aplicarFiltroDoGrafico(tipoGrafico, valor) {
        console.log('[aplicarFiltroDoGrafico] Chamado com:', tipoGrafico, valor);

        // Limpa filtros anteriores relacionados
        const filtrosRelacionados = {
          'chartTipoViolencia': ['tipoViolencia'],
          'chartTipoViolenciaInstitucional': ['violenciaInstitucional'],
          'chartRegiao': ['regiao'],
          'chartEscola': ['escola'],
          'chartIdade': ['idade'],
          'chartGenero': ['genero'],
          'chartRaca': ['raca'],
          'chartEncaminhamento': ['encaminhamento'],
          'chartAutor': ['profissionalAutor', 'estudanteAutor'],
          'chartOcorreuEscola': ['ocorreuEscola'],
          'chartTemporal': ['data'],
          'chartComparativoTemporal': ['data'],
          'chartTendenciaAnual': ['data']
        };

        // Limpa checkboxes relacionados
        if (filtrosRelacionados[tipoGrafico]) {
          filtrosRelacionados[tipoGrafico].forEach(filtro => {
            const checkboxes = document.querySelectorAll(`input[data-filter="${filtro}"]`);
            checkboxes.forEach(cb => cb.checked = false);
            // Só atualiza badge se existir
            const badge = document.getElementById(`badge-${filtro}`);
            if (badge) {
              updateBadge(filtro);
            }
          });
        }

        // Limpa filtros de select também
        if (tipoGrafico === 'chartAutor') {
          const filterProf = document.getElementById('filterProfissionalAutor');
          const filterEst = document.getElementById('filterEstudanteAutor');
          if (filterProf) filterProf.value = '';
          if (filterEst) filterEst.value = '';
        }
        if (tipoGrafico === 'chartOcorreuEscola') {
          const filterOcorreu = document.getElementById('filterOcorreuEscola');
          if (filterOcorreu) filterOcorreu.value = '';
        }
        if (tipoGrafico === 'chartIdade') {
          const filterIdadeMin = document.getElementById('filterIdadeMin');
          const filterIdadeMax = document.getElementById('filterIdadeMax');
          if (filterIdadeMin) filterIdadeMin.value = '';
          if (filterIdadeMax) filterIdadeMax.value = '';
        }
        if (tipoGrafico === 'chartTemporal' || tipoGrafico === 'chartComparativoTemporal' || tipoGrafico === 'chartTendenciaAnual') {
          const filterDataInicio = document.getElementById('filterDataInicio');
          const filterDataFim = document.getElementById('filterDataFim');
          if (filterDataInicio) filterDataInicio.value = '';
          if (filterDataFim) filterDataFim.value = '';
        }

        // Normaliza o valor para comparação
        const valorNormalizado = normalizeText(valor);

        // Aplica filtro específico baseado no tipo de gráfico
        switch (tipoGrafico) {
          case 'chartTipoViolencia':
            // Marca checkbox do tipo de violência (usa data-filter e data-value com normalização)
            const tipoCheckboxes = document.querySelectorAll(`input[data-filter="tipoViolencia"]`);
            tipoCheckboxes.forEach(cb => {
              const cbValueNorm = normalizeText(cb.dataset.value || '');
              if (cbValueNorm === valorNormalizado || cb.dataset.value === valor) {
                cb.checked = true;
              }
            });
            updateBadge('tipoViolencia');
            // Verifica se precisa mostrar card de Violências Institucionais
            setTimeout(verificarViolenciaInstitucionalNoFiltro, 100);
            break;

          case 'chartRegiao':
            const regiaoCheckboxes = document.querySelectorAll(`input[data-filter="regiao"]`);
            regiaoCheckboxes.forEach(cb => {
              const cbValueNorm = normalizeText(cb.dataset.value || '');
              if (cbValueNorm === valorNormalizado || cb.dataset.value === valor) {
                cb.checked = true;
              }
            });
            updateBadge('regiao');
            break;

          case 'chartEscola':
            const escolaCheckboxes = document.querySelectorAll(`input[data-filter="escola"]`);
            escolaCheckboxes.forEach(cb => {
              const cbValueNorm = normalizeText(cb.dataset.value || '');
              if (cbValueNorm === valorNormalizado || cb.dataset.value === valor) {
                cb.checked = true;
              }
            });
            updateBadge('escola');
            break;

          case 'chartGenero':
            // Para gênero, precisa mapear valores do gráfico para valores dos checkboxes
            let generoValor = valor;
            if (valor === 'Masculino' || valor === 'M') generoValor = 'M';
            if (valor === 'Feminino' || valor === 'F') generoValor = 'F';

            const generoCheckboxes = document.querySelectorAll(`input[data-filter="genero"]`);
            generoCheckboxes.forEach(cb => {
              const cbValue = cb.dataset.value || '';
              if (cbValue.toUpperCase() === generoValor.toUpperCase() || cbValue === valor) {
                cb.checked = true;
              }
            });
            updateBadge('genero');
            break;

          case 'chartRaca':
            const racaCheckboxes = document.querySelectorAll(`input[data-filter="raca"]`);
            racaCheckboxes.forEach(cb => {
              const cbValueNorm = normalizeText(cb.dataset.value || '');
              if (cbValueNorm === valorNormalizado || cb.dataset.value === valor) {
                cb.checked = true;
              }
            });
            updateBadge('raca');
            break;

          case 'chartTipoViolenciaInstitucional':
            // Primeiro, garante que "Institucional" está selecionado no tipo de violência
            const tipoViolenciaCheckboxes = document.querySelectorAll(`input[data-filter="tipoViolencia"]`);
            let temInstitucional = false;
            tipoViolenciaCheckboxes.forEach(cb => {
              const cbValue = (cb.dataset.value || '').toLowerCase();
              if (cbValue === 'institucional' || cbValue.includes('institucional')) {
                cb.checked = true;
                temInstitucional = true;
              }
            });
            if (temInstitucional) {
              updateBadge('tipoViolencia');
              // Verifica e mostra o card de Violências Institucionais se necessário
              setTimeout(verificarViolenciaInstitucionalNoFiltro, 100);
            }

            // Marca o checkbox de violência institucional específico
            const violenciaInstCheckboxes = document.querySelectorAll(`input[data-filter="violenciaInstitucional"]:not(#checkbox-violencia-institucional-geral)`);
            violenciaInstCheckboxes.forEach(cb => {
              const cbValueNorm = normalizeText(cb.dataset.value || '');
              if (cbValueNorm === valorNormalizado || cb.dataset.value === valor) {
                cb.checked = true;
              }
            });

            // Atualiza o checkbox geral se todos estiverem marcados
            const allViolenciaInstCheckboxes = document.querySelectorAll(`input[data-filter="violenciaInstitucional"]:not(#checkbox-violencia-institucional-geral)`);
            const checkedCount = Array.from(allViolenciaInstCheckboxes).filter(cb => cb.checked).length;
            const grupoGeral = document.getElementById('checkbox-violencia-institucional-geral');
            if (grupoGeral) {
              grupoGeral.checked = checkedCount === allViolenciaInstCheckboxes.length;
              grupoGeral.indeterminate = checkedCount > 0 && checkedCount < allViolenciaInstCheckboxes.length;
            }

            updateBadgeViolenciaInstitucionalTotal();
            break;

          case 'chartEncaminhamento':
            // Encaminhamento usa data-group e data-value nos checkboxes individuais
            // O gráfico mostra valores originais (mapaNormalizado), mas precisa encontrar checkboxes
            // Primeiro desmarca todos os checkboxes de encaminhamento
            const allEncCheckboxes = document.querySelectorAll('#filterEncaminhamentoContainer input[data-group]');
            allEncCheckboxes.forEach(cb => cb.checked = false);

            // Normaliza o valor clicado para comparação
            const valorNorm = normalizeText(valor);
            const valorLower = valor.toLowerCase().trim();

            // Procura checkboxes que correspondem EXATAMENTE ao valor clicado
            // O valor do gráfico é o valor original (ex: "CT", "CRAS", etc.)
            // Prioriza correspondência exata para evitar falsos positivos
            let encontrado = false;

            // Primeira passagem: busca exata (mais precisa)
            allEncCheckboxes.forEach(cb => {
              const cbValue = (cb.dataset.value || '').trim();
              if (!cbValue) return;

              const cbValueNorm = normalizeText(cbValue);
              const cbValueLower = cbValue.toLowerCase().trim();

              // Compara valores exatos primeiro (mais preciso)
              if (cbValue === valor ||
                cbValueNorm === valorNorm ||
                cbValueLower === valorLower) {
                cb.checked = true;
                encontrado = true;
              }
            });

            // Segunda passagem: busca parcial apenas se não encontrou exato
            // Mas apenas se o valor é uma substring completa (não apenas parte de uma palavra)
            if (!encontrado) {
              allEncCheckboxes.forEach(cb => {
                const cbValue = (cb.dataset.value || '').trim();
                if (!cbValue) return;

                const cbValueNorm = normalizeText(cbValue);

                // Busca parcial: verifica se o valor normalizado corresponde exatamente
                // ou se um é substring completa do outro (evita falsos positivos)
                // Só marca se for correspondência exata ou substring no início/fim com espaço ou barra
                const valorIsSubstring = cbValueNorm === valorNorm ||
                  (cbValueNorm.includes(valorNorm) &&
                    (cbValueNorm.startsWith(valorNorm + ' ') ||
                      cbValueNorm.endsWith(' ' + valorNorm) ||
                      cbValueNorm.startsWith(valorNorm + '/') ||
                      cbValueNorm.endsWith('/' + valorNorm) ||
                      cbValueNorm.startsWith(valorNorm + ',') ||
                      cbValueNorm.endsWith(',' + valorNorm)));
                const cbIsSubstring = valorNorm === cbValueNorm ||
                  (valorNorm.includes(cbValueNorm) &&
                    (valorNorm.startsWith(cbValueNorm + ' ') ||
                      valorNorm.endsWith(' ' + cbValueNorm) ||
                      valorNorm.startsWith(cbValueNorm + '/') ||
                      valorNorm.endsWith('/' + cbValueNorm) ||
                      valorNorm.startsWith(cbValueNorm + ',') ||
                      valorNorm.endsWith(',' + cbValueNorm)));

                if (valorIsSubstring || cbIsSubstring) {
                  cb.checked = true;
                  encontrado = true;
                }
              });
            }

            // Log para debug se não encontrou
            if (!encontrado) {
              console.warn('[Filtro Encaminhamento] Não encontrou checkbox para:', valor);
              const valoresDisponiveis = Array.from(allEncCheckboxes).slice(0, 10).map(cb => cb.dataset.value);
              console.log('[Filtro Encaminhamento] Primeiros 10 checkboxes disponíveis:', valoresDisponiveis);
            }

            // Atualiza badge e grupos
            const encSelected = document.querySelectorAll('#filterEncaminhamentoContainer input[data-group]:checked');
            const encBadge = document.getElementById('badge-encaminhamento-total');
            if (encBadge) {
              if (encSelected.length > 0) {
                encBadge.textContent = encSelected.length;
                encBadge.classList.remove('hidden');
              } else {
                encBadge.classList.add('hidden');
              }
            }

            // Atualiza grupos que têm checkboxes marcados
            const grupos = new Set();
            encSelected.forEach(cb => {
              const groupId = cb.closest('.encaminhamento-group')?.dataset.group;
              if (groupId) grupos.add(groupId);
            });
            grupos.forEach(groupId => {
              const groupCheckbox = document.getElementById(`group-${groupId}`);
              if (groupCheckbox) {
                const groupCheckboxes = document.querySelectorAll(`.encaminhamento-group[data-group="${groupId}"] input[data-group]`);
                const groupChecked = document.querySelectorAll(`.encaminhamento-group[data-group="${groupId}"] input[data-group]:checked`);
                groupCheckbox.checked = groupChecked.length > 0;
                groupCheckbox.indeterminate = groupChecked.length > 0 && groupChecked.length < groupCheckboxes.length;
              }
            });
            break;

          case 'chartAutor':
            console.log('[Filtro Autor] Aplicando filtro para:', valor);
            const filterProf = document.getElementById('filterProfissionalAutor');
            const filterEst = document.getElementById('filterEstudanteAutor');
            // Limpa ambos primeiro
            if (filterProf) filterProf.value = '';
            if (filterEst) filterEst.value = '';
            // Depois define conforme o valor clicado
            if (valor === 'Profissional da Escola' && filterProf) {
              filterProf.value = 'S';
              console.log('[Filtro Autor] Definido: profissionalAutor = S');
            } else if (valor === 'Estudante' && filterEst) {
              filterEst.value = 'S';
              console.log('[Filtro Autor] Definido: estudanteAutor = S');
            } else if (valor === 'Outro Agente (Fora da Instituição)') {
              if (filterProf) filterProf.value = 'N';
              if (filterEst) filterEst.value = 'N';
              console.log('[Filtro Autor] Definido: profissionalAutor = N, estudanteAutor = N');
            } else {
              console.warn('[Filtro Autor] Valor não reconhecido:', valor);
            }
            break;

          case 'chartOcorreuEscola':
            console.log('[Filtro OcorreuEscola] Aplicando filtro para:', valor);
            const filterOcorreu = document.getElementById('filterOcorreuEscola');
            if (filterOcorreu) {
              // Limpa primeiro
              filterOcorreu.value = '';
              // Depois define conforme o valor clicado
              if (valor === 'Sim') {
                filterOcorreu.value = 'S';
                console.log('[Filtro OcorreuEscola] Definido: ocorreu = S');
              } else if (valor === 'Não') {
                filterOcorreu.value = 'N';
                console.log('[Filtro OcorreuEscola] Definido: ocorreu = N');
              } else {
                console.warn('[Filtro OcorreuEscola] Valor não reconhecido:', valor);
              }
            } else {
              console.error('[Filtro OcorreuEscola] Elemento filterOcorreuEscola não encontrado');
            }
            break;

          case 'chartIdade':
            // Para idade, precisa extrair a faixa etária (formato: "0-5 anos", "6-10 anos", "18+ anos")
            const idadeMatch = valor.match(/(\d+)-(\d+)/);
            if (idadeMatch) {
              const filterIdadeMin = document.getElementById('filterIdadeMin');
              const filterIdadeMax = document.getElementById('filterIdadeMax');
              if (filterIdadeMin) filterIdadeMin.value = idadeMatch[1];
              if (filterIdadeMax) filterIdadeMax.value = idadeMatch[2];
            } else if (valor.includes('18+')) {
              // Para 18+ anos, define mínimo como 18 e máximo vazio
              const filterIdadeMin = document.getElementById('filterIdadeMin');
              const filterIdadeMax = document.getElementById('filterIdadeMax');
              if (filterIdadeMin) filterIdadeMin.value = '18';
              if (filterIdadeMax) filterIdadeMax.value = '';
            }
            break;

          case 'chartTemporal':
          case 'chartComparativoTemporal':
          case 'chartTendenciaAnual':
            // Para gráficos temporais, filtra por mês (formato: "Jan", "Fev", etc.)
            const meses = ['Jan', 'Fev', 'Mar', 'Abr', 'Mai', 'Jun', 'Jul', 'Ago', 'Set', 'Out', 'Nov', 'Dez'];
            const mesNome = valor.trim();
            const mesNum = meses.indexOf(mesNome) + 1;

            if (mesNum > 0) {
              const agora = new Date();
              const anoAtual = agora.getFullYear();

              // Para gráficos comparativos, filtra pelo mês no ano atual
              // Define data de início como primeiro dia do mês
              const dataInicio = `${anoAtual}-${String(mesNum).padStart(2, '0')}-01`;
              // Define data de fim como último dia do mês
              const ultimoDia = new Date(anoAtual, mesNum, 0).getDate();
              const dataFim = `${anoAtual}-${String(mesNum).padStart(2, '0')}-${String(ultimoDia).padStart(2, '0')}`;

              const filterDataInicio = document.getElementById('filterDataInicio');
              const filterDataFim = document.getElementById('filterDataFim');
              if (filterDataInicio) filterDataInicio.value = dataInicio;
              if (filterDataFim) filterDataFim.value = dataFim;
              console.log(`[Filtro ${tipoGrafico}] Aplicando filtro para mês ${mesNome}:`, dataInicio, 'até', dataFim);
            } else {
              console.error(`[Filtro ${tipoGrafico}] Mês não encontrado:`, mesNome);
            }
            break;
        }

        // Aplica filtros e rola até a tabela
        console.log('[aplicarFiltroDoGrafico] Aplicando filtros após configurar:', tipoGrafico, 'valor:', valor);

        // Se for gráfico de Tipo Violência ou Violência Institucional, verifica se precisa mostrar card de Violências Institucionais
        if (tipoGrafico === 'chartTipoViolencia' || tipoGrafico === 'chartTipoViolenciaInstitucional') {
          setTimeout(verificarViolenciaInstitucionalNoFiltro, 100);
        }

        applyFilters();

        // Aguarda um pouco para garantir que os filtros foram aplicados e a tabela foi atualizada
        setTimeout(() => {
          const tableContainer = document.getElementById('tableContainer');
          if (tableContainer) {
            tableContainer.scrollIntoView({ behavior: 'smooth', block: 'start' });
          }
          const count = filteredData ? filteredData.length : 0;
          console.log('[aplicarFiltroDoGrafico] ✅ Filtros aplicados! Registros filtrados:', count);
          if (count === 0) {
            console.warn('[aplicarFiltroDoGrafico] ⚠️ Nenhum registro encontrado após filtrar por:', valor);
          }
        }, 150);
      }

      function renderPieChart(canvasId, data, colors) {
        const canvas = document.getElementById(canvasId);
        if (!canvas) return;

        // Destroi gráfico anterior se existir
        if (charts[canvasId]) {
          charts[canvasId].destroy();
        }

        const labels = data.map(([k]) => k);
        const valores = data.map(([, v]) => v);

        charts[canvasId] = new Chart(canvas, {
          type: 'pie',
          data: {
            labels: labels,
            datasets: [{
              data: valores,
              backgroundColor: colors,
              borderWidth: 2,
              borderColor: '#fff'
            }]
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            onClick: (event, elements) => {
              console.log('[Gráfico Pizza] Clique detectado no gráfico:', canvasId);
              console.log('[Gráfico Pizza] Elements recebidos:', elements);
              if (elements && elements.length > 0) {
                const index = elements[0].index;
                const label = labels[index];
                console.log('[Gráfico Pizza] Label clicado:', label, 'Index:', index);
                aplicarFiltroDoGrafico(canvasId, label);
              } else {
                console.warn('[Gráfico Pizza] Nenhum elemento encontrado no clique. Tentando método alternativo...');
                // Método alternativo: tenta detectar clique usando getElementsAtEventForMode
                const chart = charts[canvasId];
                if (chart) {
                  const points = chart.getElementsAtEventForMode(event, 'nearest', { intersect: true }, true);
                  if (points && points.length > 0) {
                    const point = points[0];
                    const label = labels[point.index];
                    console.log('[Gráfico Pizza] Label encontrado via método alternativo:', label);
                    aplicarFiltroDoGrafico(canvasId, label);
                  } else {
                    console.error('[Gráfico Pizza] Não foi possível detectar o elemento clicado');
                  }
                }
              }
            },
            onHover: (event, elements) => {
              // Muda cursor para pointer quando hover
              if (event.native && event.native.target) {
                event.native.target.style.cursor = elements && elements.length > 0 ? 'pointer' : 'default';
              }
            },
            plugins: {
              datalabels: {
                color: '#fff',
                font: {
                  weight: 'bold',
                  size: 12
                },
                formatter: (value, ctx) => {
                  return value;
                },
                display: 'auto'
              },
              legend: {
                position: 'bottom',
                labels: {
                  padding: 10,
                  font: { size: 11 }
                }
              },
              tooltip: {
                backgroundColor: 'rgba(0, 0, 0, 0.8)',
                padding: 12,
                titleFont: { size: 13, weight: 'bold' },
                bodyFont: { size: 12 },
                callbacks: {
                  label: function (context) {
                    const label = context.label || '';
                    const value = context.parsed || 0;
                    const total = context.dataset.data.reduce((a, b) => a + b, 0);
                    const percentage = ((value / total) * 100).toFixed(1);
                    return `${label}: ${value} caso${value !== 1 ? 's' : ''} (${percentage}%)`;
                  },
                  footer: function (context) {
                    const total = context.reduce((sum, item) => sum + (item.parsed || 0), 0);
                    return 'Total: ' + total + ' caso' + (total !== 1 ? 's' : '');
                  }
                }
              }
            }
          }
        });
      }

      function renderBarChart(canvasId, data, colors) {
        const canvas = document.getElementById(canvasId);
        if (!canvas) return;

        // Destroi gráfico anterior se existir
        if (charts[canvasId]) {
          charts[canvasId].destroy();
        }

        const labels = data.map(([k]) => k);
        const valores = data.map(([, v]) => v);

        charts[canvasId] = new Chart(canvas, {
          type: 'bar',
          data: {
            labels: labels,
            datasets: [{
              label: 'Quantidade',
              data: valores,
              backgroundColor: colors[0],
              borderColor: colors[0].replace('0.8', '1'),
              borderWidth: 1
            }]
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            onClick: (event, elements) => {
              if (elements.length > 0) {
                const index = elements[0].index;
                const label = labels[index];
                aplicarFiltroDoGrafico(canvasId, label);
              }
            },
            plugins: {
              legend: { display: false },
              tooltip: {
                backgroundColor: 'rgba(0, 0, 0, 0.8)',
                padding: 10,
                titleFont: { size: 13, weight: 'bold' },
                bodyFont: { size: 12 },
                callbacks: {
                  title: function (context) {
                    return context[0].label;
                  },
                  label: function (context) {
                    const valor = context.parsed.y;
                    return `${valor} caso${valor !== 1 ? 's' : ''}`;
                  }
                }
              }
            },
            scales: {
              y: {
                beginAtZero: true,
                ticks: { stepSize: 1 }
              }
            }
          }
        });
      }

      function renderHorizontalBarChartGrouped(canvasId, data, colors) {
        const canvas = document.getElementById(canvasId);
        if (!canvas) return;

        // Destroi gráfico anterior se existir
        if (charts[canvasId]) {
          charts[canvasId].destroy();
        }

        const labels = data.map(([k]) => k);
        const valores = data.map(([, v]) => v);

        charts[canvasId] = new Chart(canvas, {
          type: 'bar',
          data: {
            labels: labels,
            datasets: [{
              label: 'Casos',
              data: valores,
              backgroundColor: colors,
              borderColor: colors.map(c => c.replace('0.8', '1')),
              borderWidth: 2,
              borderRadius: 8,
              borderSkipped: false,
            }]
          },
          options: {
            indexAxis: 'y',
            responsive: true,
            maintainAspectRatio: false,
            animation: {
              duration: 1000,
              easing: 'easeOutQuart'
            },
            onClick: (event, elements) => {
              console.log('[Gráfico Encaminhamento] Clique detectado no gráfico:', canvasId);
              console.log('[Gráfico Encaminhamento] Elements recebidos:', elements);
              if (elements && elements.length > 0) {
                const index = elements[0].index;
                const label = labels[index];
                console.log('[Gráfico Encaminhamento] Label clicado:', label, 'Index:', index);
                aplicarFiltroDoGrafico(canvasId, label);
              } else {
                console.warn('[Gráfico Encaminhamento] Nenhum elemento encontrado no clique');
              }
            },
            onHover: (event, elements) => {
              if (event.native && event.native.target) {
                event.native.target.style.cursor = elements && elements.length > 0 ? 'pointer' : 'default';
              }
            },
            plugins: {
              legend: { display: false },
              tooltip: {
                backgroundColor: 'rgba(0, 0, 0, 0.8)',
                padding: 12,
                titleFont: { size: 13, weight: 'bold' },
                bodyFont: { size: 12 },
                borderColor: 'rgba(255, 255, 255, 0.1)',
                borderWidth: 1,
                cornerRadius: 8,
                displayColors: true,
                callbacks: {
                  title: function (context) {
                    return context[0].label;
                  },
                  label: function (context) {
                    const valor = context.parsed.x;
                    return `${valor} caso${valor !== 1 ? 's' : ''}`;
                  }
                }
              }
            },
            scales: {
              x: {
                beginAtZero: true,
                ticks: {
                  stepSize: 1,
                  font: { size: 11 }
                },
                grid: {
                  color: 'rgba(0, 0, 0, 0.05)',
                  drawBorder: false
                }
              },
              y: {
                ticks: {
                  font: { size: 11 },
                  padding: 8
                },
                grid: {
                  display: false
                }
              }
            }
          }
        });
      }

      function renderHorizontalBarChart(canvasId, data, colors) {
        const canvas = document.getElementById(canvasId);
        if (!canvas) return;

        // Destroi gráfico anterior se existir
        if (charts[canvasId]) {
          charts[canvasId].destroy();
        }

        const labels = data.map(([k]) => k);
        const valores = data.map(([, v]) => v);

        // Cores alternadas para melhor visualização
        const backgroundColors = valores.map((_, index) => {
          return colors[index % colors.length];
        });

        charts[canvasId] = new Chart(canvas, {
          type: 'bar',
          data: {
            labels: labels,
            datasets: [{
              label: 'Quantidade',
              data: valores,
              backgroundColor: backgroundColors,
              borderColor: backgroundColors.map(c => c.replace('0.8', '1')),
              borderWidth: 1
            }]
          },
          options: {
            indexAxis: 'y', // Barras horizontais
            responsive: true,
            maintainAspectRatio: false,
            onClick: (event, elements) => {
              if (elements.length > 0) {
                const index = elements[0].index;
                const label = labels[index];
                aplicarFiltroDoGrafico(canvasId, label);
              }
            },
            plugins: {
              legend: { display: false },
              tooltip: {
                callbacks: {
                  label: function (context) {
                    return `Casos: ${context.parsed.x}`;
                  }
                }
              }
            },
            scales: {
              x: {
                beginAtZero: true,
                ticks: { stepSize: 1 }
              }
            }
          }
        });
      }

      // Renderiza gráfico de barras agrupadas (para correlações)
      function renderGroupedBarChart(canvasId, labels, datasets) {
        const canvas = document.getElementById(canvasId);
        if (!canvas) return;

        // Destroi gráfico anterior se existir
        if (charts[canvasId]) {
          charts[canvasId].destroy();
          delete charts[canvasId];
        }

        const ctx = canvas.getContext('2d');
        charts[canvasId] = new Chart(ctx, {
          type: 'bar',
          data: {
            labels: labels,
            datasets: datasets
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
              legend: {
                position: 'top',
                labels: {
                  padding: 15,
                  font: { size: 12, weight: 'bold' }
                }
              },
              tooltip: {
                mode: 'index',
                intersect: false,
                callbacks: {
                  label: function (context) {
                    return context.dataset.label + ': ' + context.parsed.y + ' casos';
                  }
                }
              }
            },
            scales: {
              x: {
                stacked: false,
                ticks: {
                  font: { size: 11 },
                  maxRotation: 45,
                  minRotation: 45
                },
                grid: {
                  display: false
                }
              },
              y: {
                stacked: false,
                beginAtZero: true,
                ticks: {
                  stepSize: 1,
                  font: { size: 11 }
                },
                title: {
                  display: true,
                  text: 'Quantidade de Casos',
                  font: { size: 12, weight: 'bold' }
                }
              }
            },
            onClick: (event, elements) => {
              if (elements.length > 0) {
                const element = elements[0];
                const datasetIndex = element.datasetIndex;
                const index = element.index;
                const label = labels[index];
                const datasetLabel = datasets[datasetIndex].label;
                aplicarFiltroDoGrafico('chartCorrelacaoTipoIdade', `${label} - ${datasetLabel}`);
              }
            }
          }
        });
      }

      // Renderiza gráfico comparativo de linhas (para análises temporais)
      function renderComparativeLineChart(canvasId, labels, data1, data2, label1 = 'Período 1', label2 = 'Período 2') {
        const canvas = document.getElementById(canvasId);
        if (!canvas) return;

        // Destroi gráfico anterior se existir
        if (charts[canvasId]) {
          charts[canvasId].destroy();
          delete charts[canvasId];
        }

        const ctx = canvas.getContext('2d');
        charts[canvasId] = new Chart(ctx, {
          type: 'line',
          data: {
            labels: labels,
            datasets: [
              {
                label: label1,
                data: data1,
                borderColor: 'rgba(59, 130, 246, 1)',
                backgroundColor: 'rgba(59, 130, 246, 0.1)',
                borderWidth: 3,
                fill: true,
                tension: 0.4,
                pointRadius: 5,
                pointHoverRadius: 7,
                pointBackgroundColor: 'rgba(59, 130, 246, 1)',
                pointBorderColor: '#fff',
                pointBorderWidth: 2
              },
              {
                label: label2,
                data: data2,
                borderColor: 'rgba(239, 68, 68, 1)',
                backgroundColor: 'rgba(239, 68, 68, 0.1)',
                borderWidth: 3,
                fill: true,
                tension: 0.4,
                pointRadius: 5,
                pointHoverRadius: 7,
                pointBackgroundColor: 'rgba(239, 68, 68, 1)',
                pointBorderColor: '#fff',
                pointBorderWidth: 2
              }
            ]
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            interaction: {
              mode: 'index',
              intersect: false
            },
            plugins: {
              legend: {
                position: 'top',
                labels: {
                  padding: 15,
                  font: { size: 13, weight: 'bold' },
                  usePointStyle: true,
                  pointStyle: 'circle',
                  boxWidth: 12,
                  boxHeight: 12
                },
                onClick: (e, legendItem, legend) => {
                  // Permite clicar na legenda para mostrar/ocultar datasets
                  const index = legendItem.datasetIndex;
                  const chart = legend.chart;
                  const meta = chart.getDatasetMeta(index);
                  meta.hidden = meta.hidden === null ? !chart.data.datasets[index].hidden : null;
                  chart.update();
                }
              },
              tooltip: {
                mode: 'index',
                intersect: false,
                backgroundColor: 'rgba(0, 0, 0, 0.8)',
                padding: 12,
                titleFont: { size: 13, weight: 'bold' },
                bodyFont: { size: 12 },
                callbacks: {
                  title: function (context) {
                    return 'Mês: ' + context[0].label;
                  },
                  label: function (context) {
                    return context.dataset.label + ': ' + context.parsed.y + ' caso' + (context.parsed.y !== 1 ? 's' : '');
                  },
                  footer: function (context) {
                    const total = context.reduce((sum, item) => sum + item.parsed.y, 0);
                    return 'Total: ' + total + ' caso' + (total !== 1 ? 's' : '');
                  }
                }
              }
            },
            scales: {
              x: {
                ticks: {
                  font: { size: 11 },
                  maxRotation: 45,
                  minRotation: 45
                },
                grid: {
                  display: false
                }
              },
              y: {
                beginAtZero: true,
                ticks: {
                  stepSize: 1,
                  font: { size: 11 }
                },
                title: {
                  display: true,
                  text: 'Quantidade de Casos',
                  font: { size: 12, weight: 'bold' }
                }
              }
            },
            onClick: (event, elements) => {
              console.log('[Gráfico Comparativo] Clique detectado no gráfico:', canvasId);
              console.log('[Gráfico Comparativo] Elements recebidos:', elements);

              if (elements && elements.length > 0) {
                const element = elements[0];
                const index = element.index;
                const label = labels[index];
                console.log('[Gráfico Comparativo] Label clicado:', label, 'Index:', index);
                aplicarFiltroDoGrafico(canvasId, label);
              } else {
                console.warn('[Gráfico Comparativo] Nenhum elemento encontrado no clique. Tentando método alternativo...');
                // Método alternativo para gráfico de linha comparativo
                const chart = charts[canvasId];
                if (chart) {
                  const points = chart.getElementsAtEventForMode(event, 'nearest', { intersect: true }, true);
                  if (points && points.length > 0) {
                    const point = points[0];
                    const label = labels[point.index];
                    console.log('[Gráfico Comparativo] Label encontrado via método alternativo:', label);
                    aplicarFiltroDoGrafico(canvasId, label);
                  } else {
                    console.error('[Gráfico Comparativo] Não foi possível detectar o elemento clicado');
                  }
                }
              }
            },
            onHover: (event, elements) => {
              // Muda cursor para pointer quando hover sobre pontos
              if (event.native && event.native.target) {
                const chart = charts[canvasId];
                if (chart) {
                  const points = chart.getElementsAtEventForMode(event, 'nearest', { intersect: true }, true);
                  event.native.target.style.cursor = points && points.length > 0 ? 'pointer' : 'default';
                }
              }
            }
          }
        });
      }

      function renderLineChart(canvasId, labels, valores) {
        const canvas = document.getElementById(canvasId);
        if (!canvas) return;

        // Destroi gráfico anterior se existir
        if (charts[canvasId]) {
          charts[canvasId].destroy();
        }

        charts[canvasId] = new Chart(canvas, {
          type: 'line',
          data: {
            labels: labels,
            datasets: [{
              label: 'Casos por Mês',
              data: valores,
              borderColor: 'rgba(59, 130, 246, 1)',
              backgroundColor: 'rgba(59, 130, 246, 0.1)',
              borderWidth: 2,
              fill: true,
              tension: 0.4
            }]
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            onClick: (event, elements) => {
              console.log('[Gráfico Linha] Clique detectado no gráfico:', canvasId);
              console.log('[Gráfico Linha] Elements recebidos:', elements);
              if (elements && elements.length > 0) {
                const index = elements[0].index;
                const label = labels[index];
                console.log('[Gráfico Linha] Label clicado:', label, 'Index:', index);
                aplicarFiltroDoGrafico(canvasId, label);
              } else {
                console.warn('[Gráfico Linha] Nenhum elemento encontrado no clique. Tentando método alternativo...');
                // Método alternativo para gráfico de linha
                const chart = charts[canvasId];
                if (chart) {
                  const points = chart.getElementsAtEventForMode(event, 'nearest', { intersect: true }, true);
                  if (points && points.length > 0) {
                    const point = points[0];
                    const label = labels[point.index];
                    console.log('[Gráfico Linha] Label encontrado via método alternativo:', label);
                    aplicarFiltroDoGrafico(canvasId, label);
                  } else {
                    console.error('[Gráfico Linha] Não foi possível detectar o elemento clicado');
                  }
                }
              }
            },
            onHover: (event, elements) => {
              // Muda cursor para pointer quando hover
              if (event.native && event.native.target) {
                event.native.target.style.cursor = elements && elements.length > 0 ? 'pointer' : 'default';
              }
            },
            plugins: {
              legend: {
                display: true,
                labels: {
                  font: { size: 12, weight: 'bold' },
                  usePointStyle: true
                }
              },
              tooltip: {
                backgroundColor: 'rgba(0, 0, 0, 0.8)',
                padding: 10,
                titleFont: { size: 13, weight: 'bold' },
                bodyFont: { size: 12 },
                callbacks: {
                  title: function (context) {
                    return 'Mês: ' + context[0].label;
                  },
                  label: function (context) {
                    const valor = context.parsed.y;
                    return `${context.dataset.label}: ${valor} caso${valor !== 1 ? 's' : ''}`;
                  }
                }
              }
            },
            scales: {
              y: {
                beginAtZero: true,
                ticks: { stepSize: 1 }
              }
            }
          }
        });
      }

      function renderTable(data) {
        const tbody = document.getElementById('tableBody');
        const recordCount = document.getElementById('recordCount');
        const noResults = document.getElementById('noResultsMessage');

        tbody.innerHTML = '';
        recordCount.textContent = data.length;

        if (data.length === 0) {
          noResults.classList.remove('hidden');
          document.getElementById('paginacao').style.display = 'none';
          return;
        } else {
          noResults.classList.add('hidden');
          document.getElementById('paginacao').style.display = 'flex';
        }

        // Calcular total de páginas
        totalPaginas = Math.ceil(data.length / registrosPorPagina);

        // Garantir que a página atual seja válida
        if (paginaAtual > totalPaginas) {
          paginaAtual = totalPaginas;
        }
        if (paginaAtual < 1) {
          paginaAtual = 1;
        }

        // Calcular índices para slice
        const inicio = (paginaAtual - 1) * registrosPorPagina;
        const fim = inicio + registrosPorPagina;

        // Pegar apenas os registros da página atual
        const registrosPagina = data.slice(inicio, fim);

        registrosPagina.forEach((row, index) => {
          const tr = document.createElement('tr');
          // Adicionar classes para zebra stripes e hover effect modernos
          const zebraClass = (index % 2 === 0) ? 'bg-white' : 'bg-gray-50/50';
          tr.className = 'record-row ' + zebraClass;

          const nome = columnNames.crianca ? (row[columnNames.crianca] || 'Não informado') : 'Não informado';
          const idade = columnNames.idade ? (row[columnNames.idade] || 'Não informado') : 'Não informado';
          const dataViol = columnNames.data ? formatDate(row[columnNames.data]) : 'Não informado';
          const tipo = columnNames.tipo ? (row[columnNames.tipo] || 'Não informado') : 'Não informado';
          const escolaOriginal = columnNames.escola ? (row[columnNames.escola] || '') : '';
          const escola = escolaOriginal ? getDisplayName(escolaOriginal) : 'Não informado';
          const regiao = columnNames.regiao ? (row[columnNames.regiao] || 'Não informado') : 'Não informado';
          const encaminhamento = columnNames.encaminhamento ? (row[columnNames.encaminhamento] || 'Não informado') : 'Não informado';

          // Combinar colunas U (ocorreu na escola 1.1) e Q (violência identificada pela escola ocorrida na escola)
          let ocorreuNaEscola = '';
          const ocorreuU = columnNames.ocorreu ? (row[columnNames.ocorreu] || '') : '';
          const ocorreuQ = columnNames.violenciaEscolaOcorreu ? (row[columnNames.violenciaEscolaOcorreu] || '') : '';

          if (checkSN(ocorreuU, 'S') || checkSN(ocorreuQ, 'S')) {
            ocorreuNaEscola = 'Sim';
          } else if (checkSN(ocorreuU, 'N') || checkSN(ocorreuQ, 'N')) {
            ocorreuNaEscola = 'Não';
          } else if (ocorreuU || ocorreuQ) {
            ocorreuNaEscola = ocorreuU || ocorreuQ;
          } else {
            ocorreuNaEscola = 'Não informado';
          }

          const campos = [nome, idade, dataViol, tipo, escola, regiao, encaminhamento, ocorreuNaEscola];

          campos.forEach(valor => {
            const td = document.createElement('td');
            td.className = 'px-4 py-3.5 align-top text-gray-700 text-sm font-medium';

            // Estilizar "Não informado" com cor diferente e itálico
            if (valor === 'Não informado') {
              td.className = 'px-4 py-3.5 align-top text-gray-400 text-sm italic';
            }

            td.textContent = valor;
            tr.appendChild(td);
          });

          // Adicionar coluna de ação com botão de ver detalhes
          const tdAcao = document.createElement('td');
          tdAcao.className = 'px-4 py-3.5 align-middle';
          const btnDetalhes = document.createElement('button');
          btnDetalhes.className = 'btn-ver-detalhes';
          btnDetalhes.title = 'Ver detalhes completos';
          btnDetalhes.setAttribute('data-record-index', index);
          btnDetalhes.innerHTML = `
          <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"></path>
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z"></path>
          </svg>
        `;
          btnDetalhes.addEventListener('click', function (e) {
            e.stopPropagation();
            abrirModalDetalhes(row);
          });
          tdAcao.appendChild(btnDetalhes);
          tr.appendChild(tdAcao);

          tbody.appendChild(tr);
        });

        // Atualizar controles de paginação
        updatePaginationControls();
      }

      // ==============================
      // MODAL DE DETALHES
      // ==============================
      function abrirModalDetalhes(record) {
        const modal = document.getElementById('modal-detalhes');
        const modalBody = document.getElementById('modal-detalhes-body');
        const modalTitulo = document.getElementById('modal-detalhes-titulo');
        const modalSubtitulo = document.getElementById('modal-detalhes-subtitulo');

        const nomeCrianca = record[columnNames.crianca] || record.Crianca || record.Criança || 'Registro';
        const idNotificacao = record.idNotificacao || record.ID || record.Id || record['ID Notificação'] || '';
        const dataNTValue = record[columnNames.data] || '';
        const dataNT = dataNTValue ? (formatDate(dataNTValue) || dataNTValue) : '';

        modalTitulo.textContent = nomeCrianca;
        modalSubtitulo.textContent = idNotificacao ? `ID: #${idNotificacao} • ${dataNT}` : (dataNT || 'Detalhes do Registro');

        const normalizeText = (v) => String(v || '').trim();
        const isEmptyValue = (v) => v === undefined || v === null || String(v).trim() === '' || String(v).trim() === 'Não informado';
        const toDisplay = (v) => isEmptyValue(v) ? 'Não informado' : String(v).trim();

        const toYesNoUnknown = (raw) => {
          const s = String(raw ?? '').trim();
          if (!s) return '';
          const up = s.toLowerCase();
          if (up === 's') return 'Sim';
          if (up === 'n') return 'Não';
          if (up === 'sim') return 'Sim';
          if (up === 'não' || up === 'nao') return 'Não';
          return s;
        };

        const toYesNoUnknownText = (raw) => {
          const yn = toYesNoUnknown(raw);
          if (yn === 'Sim') return 'Sim';
          if (yn === 'Não') return 'Não';
          return 'Não informado';
        };

        const renderChips = (raw, emptyText = 'Nenhum item informado') => {
          if (isEmptyValue(raw)) {
            return `<span class="text-sm text-gray-500 italic">${emptyText}</span>`;
          }
          const parts = String(raw)
            .split(',')
            .map(s => s.trim())
            .filter(Boolean);
          if (parts.length === 0) {
            return `<span class="text-sm text-gray-500 italic">${emptyText}</span>`;
          }
          return `
          <div class="flex flex-wrap gap-2">
            ${parts.map(p => `<span class="inline-flex items-center px-3 py-1 rounded-full text-sm font-medium bg-blue-100 text-blue-700 border border-blue-200">${p}</span>`).join('')}
          </div>
        `;
        };

        const renderYesNoPill = (raw) => {
          const yn = toYesNoUnknown(raw);
          if (yn === 'Sim') {
            return `<span class="inline-flex items-center gap-2 px-3 py-1 rounded-full text-sm font-semibold bg-green-100 text-green-700 border border-green-200">✓ Sim</span>`;
          }
          if (yn === 'Não') {
            return `<span class="inline-flex items-center gap-2 px-3 py-1 rounded-full text-sm font-semibold bg-red-100 text-red-700 border border-red-200">✗ Não</span>`;
          }
          return `<span class="inline-flex items-center gap-2 px-3 py-1 rounded-full text-sm font-semibold bg-gray-100 text-gray-600 border border-gray-200">⊘ Não informado</span>`;
        };

        const renderAnswerPill = (raw) => {
          const yn = toYesNoUnknown(raw);
          if (yn === 'Sim') {
            return `<span class="inline-flex items-center gap-2 px-3 py-1 rounded-full text-sm font-semibold bg-blue-50 text-blue-700 border border-blue-200">Sim</span>`;
          }
          if (yn === 'Não') {
            return `<span class="inline-flex items-center gap-2 px-3 py-1 rounded-full text-sm font-semibold bg-blue-50 text-blue-700 border border-blue-200">Não</span>`;
          }
          return `<span class="inline-flex items-center gap-2 px-3 py-1 rounded-full text-sm font-semibold bg-gray-50 text-gray-600 border border-gray-200">Não informado</span>`;
        };

        const renderReadOnlyValue = (text) => {
          const value = String(text ?? '').trim();
          const display = value ? value : 'Não informado';
          return `<span class="inline-flex items-center px-3 py-1.5 rounded-lg bg-indigo-50 text-indigo-900 border border-indigo-200 font-semibold text-sm tracking-tight">${display}</span>`;
        };

        const renderField = (label, valueHtml) => {
          return `
          <div>
            <div class="text-xs sm:text-sm font-semibold text-gray-700 mb-2">${label}</div>
            <div class="text-gray-900">
              ${valueHtml}
            </div>
          </div>
        `;
        };

        const findKeyByContains = (needleParts) => {
          const keys = Object.keys(record || {});
          const normalizedNeedles = (needleParts || []).map(p => String(p).toLowerCase().normalize('NFD').replace(/[\u0300-\u036f]/g, ''));
          for (const k of keys) {
            const nk = String(k).toLowerCase().normalize('NFD').replace(/[\u0300-\u036f]/g, '');
            if (normalizedNeedles.every(p => nk.includes(p))) return k;
          }
          return null;
        };

        const getTipoInstituicao = (nomeEscola) => {
          const v = normalizeText(nomeEscola);
          if (!v) return '';
          if (v.toUpperCase().startsWith('CMEI')) return 'CMEI - Centro Municipal de Educação Infantil';
          if (v.toUpperCase().startsWith('EMEF')) return 'EMEF - Escola Municipal de Ensino Fundamental';
          return '';
        };

        const escolaValue = record[columnNames.escola] || '';
        const tipoInstituicaoValue = getTipoInstituicao(escolaValue);

        const colaboradoresKey = findKeyByContains(['colaborador']);
        const colaboradoresValue = colaboradoresKey ? record[colaboradoresKey] : '';

        const htmlContent = `
        <div class="bg-gradient-to-br from-blue-50/30 via-indigo-50/20 to-purple-50/30">
          <div class="bg-white/80 backdrop-blur-sm p-4 sm:p-6 md:p-8 lg:p-10 space-y-6 sm:space-y-8">

            <section>
              <div class="bg-gradient-to-r from-slate-50 to-blue-50/30 rounded-xl sm:rounded-2xl border border-gray-200 shadow-sm p-4 sm:p-5 md:p-6">
                <div class="flex items-start gap-3 sm:gap-4 mb-4 sm:mb-6">
                  <div class="h-10 w-10 sm:h-12 sm:w-12 flex items-center justify-center rounded-lg sm:rounded-xl bg-blue-100 text-blue-600 text-xl sm:text-2xl flex-shrink-0 shadow-sm">👤</div>
                  <div class="flex-1">
                    <h2 class="text-lg sm:text-xl md:text-2xl font-bold text-gray-800 mb-1">Dados da Criança/Estudante</h2>
                    <p class="text-xs sm:text-sm text-gray-600">Preencha as informações básicas da criança ou estudante envolvido no caso</p>
                  </div>
                </div>
                <div class="grid grid-cols-1 md:grid-cols-2 gap-4 sm:gap-6">
                  <div class="md:col-span-2">${renderField('Nome da Criança/Estudante *', renderReadOnlyValue(toDisplay(record[columnNames.crianca] || '')))}</div>
                  ${renderField('Data da Notificação (NT) *', renderReadOnlyValue(toDisplay(dataNT || '')))}
                  ${renderField('Idade *', renderReadOnlyValue(toDisplay(record[columnNames.idade] || '')))}
                  ${renderField('Identidade de Gênero *', renderReadOnlyValue(toDisplay(record[columnNames.genero] || '')))}
                  ${renderField('É PCD/tem Transtorno?', renderReadOnlyValue(toDisplay(record[columnNames.pcd] || '')))}
                  ${renderField('Raça/Cor', renderReadOnlyValue(toDisplay(record[columnNames.raca] || '')))}
                  ${renderField('Orientação Sexual', renderReadOnlyValue(toDisplay(record[columnNames.orientacaoSexual] || '')))}
                </div>
              </div>
            </section>

            <section>
              <div class="bg-gradient-to-r from-slate-50 to-amber-50/30 rounded-xl sm:rounded-2xl border border-gray-200 shadow-sm p-4 sm:p-5 md:p-6">
                <div class="flex items-start gap-3 sm:gap-4 mb-4 sm:mb-6">
                  <div class="h-10 w-10 sm:h-12 sm:w-12 flex items-center justify-center rounded-lg sm:rounded-xl bg-amber-100 text-amber-700 text-xl sm:text-2xl flex-shrink-0 shadow-sm">⚠️</div>
                  <div class="flex-1">
                    <h2 class="text-lg sm:text-xl md:text-2xl font-bold text-gray-800 mb-1">Situação da Violência</h2>
                    <p class="text-xs sm:text-sm text-gray-600">Descreva o tipo de violência ocorrida e os encaminhamentos realizados</p>
                  </div>
                </div>
                <div class="grid grid-cols-1 md:grid-cols-2 gap-4 sm:gap-6">
                  <div class="md:col-span-2">${renderField('Tipo de Violência *', renderChips(record[columnNames.tipo] || '', 'Nenhum tipo informado'))}</div>
                  <div class="md:col-span-2">${renderField('Encaminhamento', renderChips(record[columnNames.encaminhamento] || '', 'Nenhum encaminhamento informado'))}</div>
                </div>
              </div>
            </section>

            <section>
              <div class="bg-gradient-to-r from-slate-50 to-emerald-50/30 rounded-xl sm:rounded-2xl border border-gray-200 shadow-sm p-4 sm:p-5 md:p-6">
                <div class="flex items-start gap-3 sm:gap-4 mb-4 sm:mb-6">
                  <div class="h-10 w-10 sm:h-12 sm:w-12 flex items-center justify-center rounded-lg sm:rounded-xl bg-emerald-100 text-emerald-700 text-xl sm:text-2xl flex-shrink-0 shadow-sm">🏫</div>
                  <div class="flex-1">
                    <h2 class="text-lg sm:text-xl md:text-2xl font-bold text-gray-800 mb-1">Dados da Instituição</h2>
                    <p class="text-xs sm:text-sm text-gray-600">Preencha informações sobre a escola e região onde ocorreu o caso</p>
                  </div>
                </div>
                <div class="grid grid-cols-1 md:grid-cols-2 gap-4 sm:gap-6">
                  ${renderField('Qual o tipo da instituição de ensino? *', renderReadOnlyValue(toDisplay(tipoInstituicaoValue || '')))}
                  ${renderField('Região *', renderReadOnlyValue(toDisplay(record[columnNames.regiao] || '')))}
                  <div class="md:col-span-2">${renderField('Instituição de Ensino *', renderReadOnlyValue(toDisplay(escolaValue || '')))}</div>
                  <div class="md:col-span-2">${renderField('Responsável pelo Registro *', renderReadOnlyValue(toDisplay(record[columnNames.responsavel] || '')))}</div>
                  <div class="md:col-span-2">${renderField('Colaboradores (opcional)', renderChips(colaboradoresValue || '', 'Nenhum colaborador adicionado'))}</div>
                </div>
              </div>
            </section>

            <section>
              <div class="bg-gradient-to-r from-slate-50 to-purple-50/30 rounded-xl sm:rounded-2xl border border-gray-200 shadow-sm p-4 sm:p-5 md:p-6">
                <div class="flex items-start gap-3 sm:gap-4 mb-4 sm:mb-6">
                  <div class="h-10 w-10 sm:h-12 sm:w-12 flex items-center justify-center rounded-lg sm:rounded-xl bg-purple-100 text-purple-700 text-xl sm:text-2xl flex-shrink-0 shadow-sm">❓</div>
                  <div class="flex-1">
                    <h2 class="text-lg sm:text-xl md:text-2xl font-bold text-gray-800 mb-1">Informações Complementares</h2>
                    <p class="text-xs sm:text-sm text-gray-600">Responda às questões adicionais sobre o contexto da violência</p>
                  </div>
                </div>
                ${(() => {
            const foiMembroFamiliarValue = record[columnNames.foiMembroFamiliar] || '';
            const fonteEscolaValue = record[columnNames.fonteInformada] || '';
            const violenciaEscolaOcorreuValue = record[columnNames.violenciaEscolaOcorreu] || '';
            const profissionalAutorValue = record[columnNames.profissionalAutor] || '';
            const estudanteAutorValue = record[columnNames.estudanteAutor] || '';
            const violenciaNaoEscolaValue = record[columnNames.violenciaNaoEscola] || '';
            const violenciaInformadaValue = record[columnNames.violenciaInformada] || '';
            const ocorreuValue = record[columnNames.ocorreu] || '';
            const estudoCasoValue = record[columnNames.estudoCaso] || '';

            const renderTooltip = (tooltipTitle, tooltipBody) => {
              return `
                      <span class="relative inline-flex align-middle ml-1 tooltip-trigger" tabindex="0" role="button" aria-label="Ajuda">
                        <span class="inline-flex items-center justify-center w-4 h-4 rounded-full bg-indigo-50 text-indigo-800 border border-indigo-300 text-[10px] leading-none select-none">ⓘ</span>
                        <span class="tooltip-popover absolute left-1/2 -translate-x-1/2 bottom-full mb-2">
                          <span class="absolute inset-[-10px] rounded-2xl bg-white/30 backdrop-blur-[2px]"></span>
                          <span class="relative block w-80 max-w-[90vw] rounded-xl border border-indigo-300 bg-white/95 shadow-2xl shadow-indigo-900/20 p-4 text-xs text-gray-900">
                            <div class="text-[11px] font-extrabold text-indigo-900 mb-2 tracking-wide">${tooltipTitle}</div>
                            <div class="leading-relaxed text-gray-800">${tooltipBody}</div>
                          </span>
                        </span>
                      </span>
                    `;
            };

            const renderQ = (questionText, answerRaw, tooltipTitle, tooltipBody) => {
              return `
                      <div class="space-y-1">
                        <div class="text-sm font-medium text-gray-800">
                          ${questionText}
                          ${renderTooltip(tooltipTitle, tooltipBody)}
                        </div>
                        <div>${renderReadOnlyValue(toYesNoUnknownText(answerRaw))}</div>
                      </div>
                    `;
            };

            const shouldShowOcorreu = toYesNoUnknown(violenciaInformadaValue) === 'Sim';

            return `
                    <div class="space-y-4">
                      ${renderQ(
              'O autor era membro da família?',
              foiMembroFamiliarValue,
              'Membro da família',
              'Use esta informação para entender se o caso tem indício de violência intrafamiliar. Considere como familiar: pais ou responsáveis legais, avós, irmãos, tios, primos e outros parentes consanguíneos ou por afinidade. Quando marcado como “Sim”, costuma indicar necessidade de atenção para contexto doméstico e rede de proteção.'
            )}

                      ${renderQ(
              'O relato foi feito pela escola?',
              fonteEscolaValue,
              'Fonte do relato',
              'Mostra quem iniciou o relato/notificação do caso. “Sim” significa que a própria escola identificou e registrou o caso (direção, coordenação, professores ou equipe). “Não” indica que o caso chegou à escola por outra fonte (ex.: família, estudante, serviços, instituições externas). Isso ajuda a interpretar como a escola tomou conhecimento do ocorrido.'
            )}

                      ${renderQ(
              'A escola identificou que a violência ocorreu na escola?',
              violenciaEscolaOcorreuValue,
              'Local confirmado (na escola)',
              'Indica se, após apuração/verificação, foi confirmado que o fato ocorreu dentro do ambiente escolar (ex.: sala, pátio, banheiro, quadra). Este campo descreve o local do ocorrido — não a autoria — e ajuda a diferenciar situações internas da escola de situações externas acompanhadas pela escola.'
            )}

                      ${renderQ(
              'Algum profissional/funcionário da escola foi autor da violência?',
              profissionalAutorValue,
              'Autoria (profissional)',
              'Indica se a autoria do caso foi atribuída a profissional/funcionário da escola. Considere professores, coordenação, direção, auxiliares, terceirizados (limpeza, segurança, portaria, merenda) e demais colaboradores. Esse campo é importante porque muda a interpretação do caso e os encaminhamentos administrativos.'
            )}

                      ${renderQ(
              'Algum estudante foi autor da violência?',
              estudanteAutorValue,
              'Autoria (estudante)',
              'Indica se a autoria foi atribuída a estudante (da mesma escola ou de outra unidade). Em geral, é usado para casos como agressões entre estudantes, bullying/cyberbullying e outras violências no contexto escolar entre pares.'
            )}

                      ${renderQ(
              'A escola identificou que a violência NÃO ocorreu na escola?',
              violenciaNaoEscolaValue,
              'Local confirmado (fora da escola)',
              'Indica se, após verificação, foi confirmado que o fato ocorreu fora do ambiente escolar (ex.: residência, via pública, transporte, outros locais externos). Mesmo quando a escola acompanha ou identifica o caso, este campo ajuda a registrar que o local do ocorrido não foi na escola.'
            )}

                      ${renderQ(
              'A violência foi comunicada à escola por algum agente externo?',
              violenciaInformadaValue,
              'Comunicação por terceiros',
              'Indica se a escola tomou conhecimento do caso por comunicação de terceiros (agentes externos), e não por identificação direta da equipe escolar. Exemplos: família, o próprio estudante, vizinhos, Conselho Tutelar, Polícia, UBS, CRAS, entre outros. Esse campo é útil para interpretar a origem da informação e o fluxo de notificação.'
            )}

                      ${shouldShowOcorreu ? renderQ(
              '➜ A violência ocorreu na escola?',
              ocorreuValue,
              'Confirmação do local',
              'Este campo aparece quando o caso foi comunicado por agente externo. Ele registra a conclusão (após apuração) sobre onde o fato ocorreu: dentro ou fora da escola. Serve para evitar interpretações ambíguas quando a informação chegou por terceiros, mas o local do ocorrido ainda precisa ser confirmado.'
            ) : ''}

                      ${renderQ(
              'Foi realizado estudo de caso pela equipe?',
              estudoCasoValue,
              'Estudo de caso',
              'Indica se a equipe realizou estudo de caso (análise estruturada do registro), geralmente com reuniões, avaliação multidisciplinar (pedagógica/psicossocial/direção), definição de plano de intervenção e documentação interna. Ajuda a entender o nível de consolidação do acompanhamento do caso.'
            )}
                    </div>
                  `;
          })()}
              </div>
            </section>

            ${(() => {
            // ABA DE ANEXOS - VISIVEL APENAS PARA ADMIN/SUPERUSER
            const userRole = sessionStorage.getItem('userRole');
            if (userRole !== 'admin' && userRole !== 'superuser') {
              return '';
            }

            // Funcao para obter icone baseado no tipo de arquivo
            const getFileIcon = (filename) => {
              const ext = (filename || '').split('.').pop().toLowerCase();
              const icons = {
                pdf: '📄', doc: '📝', docx: '📝',
                xls: '📊', xlsx: '📊',
                jpg: '🖼️', jpeg: '🖼️', png: '🖼️', gif: '🖼️',
                mp4: '🎥', mp3: '🎵',
                zip: '📦', rar: '📦'
              };
              return icons[ext] || '📎';
            };

            // Busca anexos do registro (se disponivel no record)
            const anexos = record.anexos || record.Anexos || [];
            const hasAnexos = Array.isArray(anexos) && anexos.length > 0;

            // Renderiza lista de anexos ou mensagem vazia
            const renderAnexosList = () => {
              if (!hasAnexos) {
                return '<div class="text-center py-8 text-gray-500"><span class="text-4xl block mb-3">📂</span><p class="font-medium">Nenhum anexo disponivel</p><p class="text-sm">Este registro nao possui arquivos anexados.</p></div>';
              }
              return anexos.map((anexo, index) => {
                const nome = anexo.nome || anexo.filename || 'Arquivo_' + (index + 1);
                const url = anexo.url || anexo.link || '#';
                const enviadoPor = anexo.enviadoPor || anexo.usuario || 'Usuario';
                const dataEnvio = anexo.dataEnvio || anexo.data || '';
                const icon = getFileIcon(nome);
                const dataStr = dataEnvio ? ' - ' + dataEnvio : '';
                return '<div class="flex items-center justify-between p-3 sm:p-4 bg-white rounded-xl border border-gray-200 hover:border-indigo-300 hover:shadow-sm transition-all"><div class="flex items-center gap-3 flex-1 min-w-0"><span class="text-2xl flex-shrink-0">' + icon + '</span><div class="min-w-0 flex-1"><p class="font-medium text-gray-800 truncate">' + nome + '</p><p class="text-xs text-gray-500">Enviado por: ' + enviadoPor + dataStr + '</p></div></div><a href="' + url + '" target="_blank" rel="noopener noreferrer" class="flex-shrink-0 ml-3 px-4 py-2 bg-indigo-500 text-white text-sm font-semibold rounded-lg hover:bg-indigo-600 transition-colors flex items-center gap-2"><span>⬇️</span><span class="hidden sm:inline">Download</span></a></div>';
              }).join('');
            };

            const totalText = hasAnexos ? '<p class="mt-4 text-sm text-gray-500 text-center">Total: ' + anexos.length + ' anexo(s)</p>' : '';

            return '<section><div class="bg-gradient-to-r from-slate-50 to-indigo-50/30 rounded-xl sm:rounded-2xl border border-gray-200 shadow-sm p-4 sm:p-5 md:p-6"><div class="flex items-start gap-3 sm:gap-4 mb-4 sm:mb-6"><div class="h-10 w-10 sm:h-12 sm:w-12 flex items-center justify-center rounded-lg sm:rounded-xl bg-indigo-100 text-indigo-700 text-xl sm:text-2xl flex-shrink-0 shadow-sm">📎</div><div class="flex-1"><h2 class="text-lg sm:text-xl md:text-2xl font-bold text-gray-800 mb-1">Anexos do Caso</h2><p class="text-xs sm:text-sm text-gray-600">Documentos e arquivos relacionados a este registro (visivel apenas para administradores)</p></div></div><div class="space-y-3">' + renderAnexosList() + '</div>' + totalText + '</div></section>';
          })()}
          </div>
        </div>
      `;

        modalBody.innerHTML = htmlContent || '<p class="text-gray-500 text-center py-8">Nenhuma informação disponível</p>';

        // Capturar posição atual do scroll
        const scrollY = window.scrollY || window.pageYOffset;

        // Salvar posição do scroll para restaurar depois
        modal.dataset.scrollY = scrollY;

        // Bloquear scroll do body e manter posição visual
        document.body.style.position = 'fixed';
        document.body.style.top = `-${scrollY}px`;
        document.body.style.width = '100%';
        document.body.classList.add('modal-open');

        // Abrir modal começando na posição atual do scroll
        modal.style.top = `${scrollY}px`;
        modal.style.height = `${window.innerHeight}px`;
        modal.classList.add('visible');

        // Scrollar o modal para mostrar o conteúdo no topo
        setTimeout(() => {
          modal.scrollTop = 0;
        }, 10);
      }

      function fecharModalDetalhes() {
        const modal = document.getElementById('modal-detalhes');
        const scrollY = modal.dataset.scrollY || '0';

        // Remover bloqueio de scroll
        document.body.style.position = '';
        document.body.style.top = '';
        document.body.style.width = '';
        document.body.classList.remove('modal-open');

        // Fechar modal
        modal.classList.remove('visible');
        modal.style.top = '';
        modal.style.height = '';

        // Restaurar posição do scroll
        window.scrollTo(0, parseInt(scrollY));
      }

      // ==============================
      // Funções de Paginação
      // ==============================
      function updatePaginationControls() {
        const info = document.getElementById('paginacaoInfo');
        const btnPrimeira = document.getElementById('btnPrimeiraPagina');
        const btnAnterior = document.getElementById('btnPaginaAnterior');
        const btnProxima = document.getElementById('btnProximaPagina');
        const btnUltima = document.getElementById('btnUltimaPagina');

        info.textContent = paginaAtual + ' de ' + totalPaginas;

        // Desabilitar botões conforme necessário
        btnPrimeira.disabled = (paginaAtual === 1);
        btnAnterior.disabled = (paginaAtual === 1);
        btnProxima.disabled = (paginaAtual === totalPaginas);
        btnUltima.disabled = (paginaAtual === totalPaginas);
      }

      function irParaPagina(novaPagina) {
        if (novaPagina >= 1 && novaPagina <= totalPaginas) {
          paginaAtual = novaPagina;
          renderTable(filteredData);
          // Scroll suave para a seção de resultados
          document.getElementById('resultsSection').scrollIntoView({ behavior: 'smooth', block: 'start' });
        }
      }

      function alterarRegistrosPorPagina() {
        const select = document.getElementById('registrosPorPaginaSelect');
        registrosPorPagina = parseInt(select.value, 10);
        paginaAtual = 1; // Voltar para primeira página
        renderTable(filteredData);
      }

      // ========================================
      // VERIFICAR AUTENTICAÇÃO
      // ========================================
      function verificarAutenticacao() {
        const userRole = sessionStorage.getItem('userRole');
        const userEmail = sessionStorage.getItem('userEmail');

        // Se não estiver autenticado, redireciona para login
        if (!userRole || !userEmail) {
          alert('Acesso negado! Faça login para acessar o sistema.');
          window.location.href = 'index.html';
          return;
        }

        // Ajusta visibilidade do menu para visualizador (somente painel)
        ajustarMenuPorRole(userRole);
        configurarLogoutVisualizador(userRole);
      }

      // ========================================
      // MENU MOBILE TOGGLE
      // ========================================
      function toggleMobileMenu() {
        const mobileMenu = document.getElementById('mobileMenuNav');
        const menuIcon = document.getElementById('menuIcon');
        mobileMenu.classList.toggle('show');
        menuIcon.style.transform = mobileMenu.classList.contains('show') ? 'rotate(90deg)' : 'rotate(0deg)';
      }

      // Fecha o menu ao redimensionar para desktop
      window.addEventListener('resize', function () {
        if (window.innerWidth > 768) {
          const mobileMenu = document.getElementById('mobileMenuNav');
          const menuIcon = document.getElementById('menuIcon');
          if (mobileMenu && mobileMenu.classList.contains('show')) {
            mobileMenu.classList.remove('show');
            menuIcon.style.transform = 'rotate(0deg)';
          }
        }
      });

      // ========================================
      // VERIFICAR E MOSTRAR MENU (DINAMICO)
      // Usa o sistema de navegacao por perfil
      // ========================================
      function verificarMenuAdmin() {
        // Usa o novo sistema de navegacao por perfil
        if (window.NAVMNavigation) {
          window.NAVMNavigation.renderMenus();
          console.log('[Menu] Menus renderizados via NAVMNavigation');
        } else {
          console.warn('[Menu] NAVMNavigation nao disponivel');
        }
      }

      // Funcao legada - agora o ajuste e feito automaticamente pelo navigation.js
      function ajustarMenuPorRole(role) {
        // O novo sistema de navegacao ja renderiza apenas os itens permitidos
        console.log('[Menu] ajustarMenuPorRole chamado para role:', role);
      }

      // Funcao legada - agora o botao sair e sempre visivel pelo navigation.js
      function configurarLogoutVisualizador(role) {
        // O botao sair agora e sempre renderizado pelo navigation.js
        console.log('[Menu] configurarLogoutVisualizador chamado para role:', role);
      }

      // ========================================
      // FECHAR MENU MOBILE AO CLICAR EM LINK
      // ========================================
      document.addEventListener('DOMContentLoaded', function () {
        const mobileMenuLinks = document.querySelectorAll('#mobileMenuNav a');
        mobileMenuLinks.forEach(link => {
          link.addEventListener('click', function () {
            const mobileMenu = document.getElementById('mobileMenuNav');
            const menuIcon = document.getElementById('menuIcon');
            if (mobileMenu && menuIcon) {
              mobileMenu.classList.remove('show');
              menuIcon.style.transform = 'rotate(0deg)';
            }
          });
        });

        verificarMenuAdmin();

        // Carregar contador de notificações
        carregarContadorNotificacoes();

        // ✨ SINCRONIZAÇÃO ENTRE PÁGINAS: Listener para invalidação de cache
        window.addEventListener('storage', (event) => {
          if (event.key === 'naam_cache_invalidation' && event.newValue) {
            try {
              const invalidationEvent = JSON.parse(event.newValue);
              if (invalidationEvent.type === 'cache_invalidation' && invalidationEvent.cacheKey === 'gerenciar_casos') {
                console.log('[Sincronização] 📡 Evento de invalidação recebido da página:', invalidationEvent.source);

                // Limpa cache local
                if (window.DataCache) {
                  window.DataCache.clear('gerenciar_casos');
                  window.DataCache.clearAll();
                  console.log('[Sincronização] ✅ Cache local invalidado');
                }

                // Recarrega dados automaticamente se estiver na página de painel
                if (typeof carregarDadosPlanilha === 'function') {
                  console.log('[Sincronização] 🔄 Recarregando dados da planilha...');
                  // Aguarda 500ms para evitar conflito com a página que iniciou
                  setTimeout(() => {
                    carregarDadosPlanilha();
                  }, 500);
                }
              }
            } catch (e) {
              console.warn('[Sincronização] ⚠️ Erro ao processar evento de invalidação:', e);
            }
          }
        });
      });

      // ========================================
      // SISTEMA DE MÁQUINA DE ESTADOS PARA NOTIFICAÇÕES
      // Garante: Toast SEMPRE aparece antes do Alerta (nunca simultâneo)
      // ========================================

      const NOTIF_STATES = {
        IDLE: 'idle',                           // Nenhuma notificação visível
        TOAST_SHOWING: 'toast_showing',         // Toast está visível/animando
        TOAST_EXITING: 'toast_exiting',         // Toast saindo (bloqueio ao alerta)
        ALERT_SHOWING: 'alert_showing',         // Alerta está visível
        ALERT_EXITING: 'alert_exiting'          // Alerta saindo
      };

      // Flag global: indica que o usuário iniciou uma atualização manual
      // a partir do popup azul de nova notificação.
      // Esta flag é usada pelo ChangeDetector e pelos gerenciadores de alerta/toast
      // para suprimir qualquer alerta visual redundante nesse ciclo.
      window.atualizacaoDisparadaPeloUsuario = window.atualizacaoDisparadaPeloUsuario || false;
      // Alias compatível com a nomenclatura sugerida na documentação
      window.atualizacaoIniciadaViaPopup = window.atualizacaoDisparadaPeloUsuario;

      // ========================================
      // SISTEMA DE SINCRONIZAÇÃO ENTRE PÁGINAS
      // ========================================
      // Rastreia estado do popup azul e sincroniza entre painel-casos.html e gerenciar-casos.html
      const SYNC_STATE_KEY = 'naam_popup_azul_sync_state';
      const SYNC_LAST_NOTIF_ID_KEY = 'naam_last_synced_notif_id';

      /**
       * Salva estado de sincronização no localStorage
       * @param {Object} state - Estado a ser salvo
       */
      function salvarEstadoSincronizacao(state) {
        try {
          const syncState = {
            ...state,
            timestamp: Date.now(),
            pagina: window.location.pathname.includes('painel-casos') ? 'painel' : 'gerenciar'
          };
          localStorage.setItem(SYNC_STATE_KEY, JSON.stringify(syncState));
          console.log('[Sync] 💾 Estado salvo:', syncState);
        } catch (e) {
          console.warn('[Sync] ⚠️ Erro ao salvar estado:', e);
        }
      }

      /**
       * Lê estado de sincronização do localStorage
       * @returns {Object|null} Estado ou null se não existir
       */
      function lerEstadoSincronizacao() {
        try {
          const stored = localStorage.getItem(SYNC_STATE_KEY);
          if (stored) {
            return JSON.parse(stored);
          }
        } catch (e) {
          console.warn('[Sync] ⚠️ Erro ao ler estado:', e);
        }
        return null;
      }

      /**
       * Limpa estado de sincronização
       */
      function limparEstadoSincronizacao() {
        try {
          localStorage.removeItem(SYNC_STATE_KEY);
          console.log('[Sync] 🧹 Estado limpo');
        } catch (e) {
          console.warn('[Sync] ⚠️ Erro ao limpar estado:', e);
        }
      }

      /**
       * Marca que popup azul foi criado (ativo)
       * @param {number} notifId - ID da notificação que gerou o popup
       */
      function marcarPopupAzulAtivo(notifId) {
        salvarEstadoSincronizacao({
          popupAtivo: true,
          popupFechadoSemAtualizar: false,
          popupAtualizado: false,
          notifId: notifId
        });
      }

      /**
       * Marca que popup azul foi fechado sem atualizar
       * @param {number} notifId - ID da notificação
       */
      function marcarPopupAzulFechadoSemAtualizar(notifId) {
        salvarEstadoSincronizacao({
          popupAtivo: false,
          popupFechadoSemAtualizar: true,
          popupAtualizado: false,
          notifId: notifId
        });
      }

      /**
       * Marca que popup azul foi atualizado (usuário clicou em Atualizar)
       * @param {number} notifId - ID da notificação
       */
      function marcarPopupAzulAtualizado(notifId) {
        salvarEstadoSincronizacao({
          popupAtivo: false,
          popupFechadoSemAtualizar: false,
          popupAtualizado: true,
          notifId: notifId
        });
        // Salva último ID sincronizado
        try {
          localStorage.setItem(SYNC_LAST_NOTIF_ID_KEY, String(notifId));
        } catch (e) {
          console.warn('[Sync] ⚠️ Erro ao salvar último ID sincronizado:', e);
        }
      }

      /**
       * Verifica estado sincronizado na inicialização da página
       * Se popup foi fechado sem atualizar em outra página, mostra alerta vermelho
       */
      function verificarEstadoSincronizadoNaInicializacao() {
        const estado = lerEstadoSincronizacao();
        if (!estado) return;

        console.log('[Sync] 🔍 Verificando estado sincronizado:', estado);

        // Se popup foi fechado sem atualizar E não foi atualizado depois
        if (estado.popupFechadoSemAtualizar && !estado.popupAtualizado) {
          // Verifica se o ID da notificação ainda é relevante (não foi atualizado em outra página)
          const ultimoIdSincronizado = localStorage.getItem(SYNC_LAST_NOTIF_ID_KEY);
          const ultimoIdSalvo = localStorage.getItem('naam_ultimo_id_notificacao');

          console.log('[Sync] 📊 Comparação de IDs:', {
            ultimoIdSincronizado,
            ultimoIdSalvo,
            estadoNotifId: estado.notifId
          });

          // Se não há ID sincronizado, significa que nunca houve atualização via popup
          // Nesse caso, sempre mostra o alerta se o popup foi fechado sem atualizar
          if (!ultimoIdSincronizado) {
            console.log('[Sync] 🔔 Popup foi fechado sem atualizar (nunca houve atualização). Mostrando alerta vermelho...');

            // Força mostrar alerta vermelho e animação
            window.popupAzulFechadoPeloUsuario = true;
            setTimeout(() => {
              if (typeof showAlertaNovasNotificacoes === 'function') {
                showAlertaNovasNotificacoes();
              }
            }, 500);
            return;
          }

          // Se há ID sincronizado, verifica se o ID atual é diferente (ainda há notificação pendente)
          // OU se o ID do estado é diferente do sincronizado (a notificação que gerou o popup ainda não foi processada)
          if (ultimoIdSalvo && ultimoIdSalvo !== ultimoIdSincronizado) {
            console.log('[Sync] 🔔 Popup foi fechado sem atualizar e há notificação pendente. Mostrando alerta vermelho...');

            // Força mostrar alerta vermelho e animação
            window.popupAzulFechadoPeloUsuario = true;
            setTimeout(() => {
              if (typeof showAlertaNovasNotificacoes === 'function') {
                showAlertaNovasNotificacoes();
              }
            }, 500);
            return;
          }

          // Se o ID do estado é diferente do sincronizado, também mostra (notificação específica não foi processada)
          if (estado.notifId && String(estado.notifId) !== ultimoIdSincronizado) {
            console.log('[Sync] 🔔 Popup foi fechado sem atualizar e a notificação específica não foi processada. Mostrando alerta vermelho...');

            // Força mostrar alerta vermelho e animação
            window.popupAzulFechadoPeloUsuario = true;
            setTimeout(() => {
              if (typeof showAlertaNovasNotificacoes === 'function') {
                showAlertaNovasNotificacoes();
              }
            }, 500);
            return;
          }

          // Se chegou aqui e o popup foi fechado sem atualizar, mostra o alerta de qualquer forma
          // (pode ser que o ID ainda não tenha sido atualizado, mas o popup foi fechado)
          console.log('[Sync] 🔔 Popup foi fechado sem atualizar. Mostrando alerta vermelho (fallback)...');

          // Força mostrar alerta vermelho e animação
          window.popupAzulFechadoPeloUsuario = true;
          setTimeout(() => {
            if (typeof showAlertaNovasNotificacoes === 'function') {
              showAlertaNovasNotificacoes();
            }
          }, 500);
        }
      }

      /**
       * Detecta navegação entre páginas e marca popup como fechado se estava ativo
       */
      function configurarDetecaoNavegacao() {
        // Detecta quando usuário está saindo da página
        window.addEventListener('beforeunload', () => {
          const estado = lerEstadoSincronizacao();
          const popupAtivo = document.getElementById('notificacao-nova-notificacao');

          console.log('[Sync] 🚪 beforeunload disparado. Estado:', estado, 'Popup ativo:', !!popupAtivo);

          // Se há popup azul ativo e usuário está navegando sem atualizar
          if (estado && estado.popupAtivo && popupAtivo) {
            console.log('[Sync] 🚪 Usuário navegando com popup azul ativo. Marcando como fechado sem atualizar...');
            const ultimoIdSalvo = localStorage.getItem('naam_ultimo_id_notificacao');
            const notifId = ultimoIdSalvo ? parseInt(ultimoIdSalvo, 10) : (estado.notifId || null);
            marcarPopupAzulFechadoSemAtualizar(notifId);
          } else if (popupAtivo) {
            // Se há popup ativo mas não há estado salvo, cria o estado
            console.log('[Sync] 🚪 Popup ativo mas sem estado. Criando estado e marcando como fechado...');
            const ultimoIdSalvo = localStorage.getItem('naam_ultimo_id_notificacao');
            const notifId = ultimoIdSalvo ? parseInt(ultimoIdSalvo, 10) : null;
            marcarPopupAzulFechadoSemAtualizar(notifId);
          }
        });

        // Também detecta quando a página fica oculta (mudança de aba)
        document.addEventListener('visibilitychange', () => {
          if (document.hidden) {
            const estado = lerEstadoSincronizacao();
            const popupAtivo = document.getElementById('notificacao-nova-notificacao');

            console.log('[Sync] 👁️ Página ocultada. Estado:', estado, 'Popup ativo:', !!popupAtivo);

            // Se há popup azul ativo e página foi ocultada
            if (estado && estado.popupAtivo && popupAtivo) {
              console.log('[Sync] 👁️ Página ocultada com popup azul ativo. Marcando como fechado sem atualizar...');
              const ultimoIdSalvo = localStorage.getItem('naam_ultimo_id_notificacao');
              const notifId = ultimoIdSalvo ? parseInt(ultimoIdSalvo, 10) : (estado.notifId || null);
              marcarPopupAzulFechadoSemAtualizar(notifId);
            } else if (popupAtivo) {
              // Se há popup ativo mas não há estado salvo, cria o estado
              console.log('[Sync] 👁️ Popup ativo mas sem estado. Criando estado e marcando como fechado...');
              const ultimoIdSalvo = localStorage.getItem('naam_ultimo_id_notificacao');
              const notifId = ultimoIdSalvo ? parseInt(ultimoIdSalvo, 10) : null;
              marcarPopupAzulFechadoSemAtualizar(notifId);
            }
          }
        });
      }

      // Configura detecção de navegação ao carregar
      configurarDetecaoNavegacao();

      const NotificationManager = {
        state: NOTIF_STATES.IDLE,
        hasStoredNotif: false,
        timeoutMap: {},

        // ===== ESTADO MÁQUINA =====
        setState(newState) {
          if (newState === this.state) return;
          console.log(`[NotifState] ${this.state} → ${newState}`);
          this.state = newState;
        },

        // ===== VERIFICAÇÕES DE SEGURANÇA =====
        canShowToast() {
          return this.state === NOTIF_STATES.IDLE;
        },

        canShowAlert() {
          // Alerta SÓ pode aparecer se:
          // 1. Estado é IDLE (nenhuma notificação ativa)
          // 2. Toast NÃO está visível
          return this.state === NOTIF_STATES.IDLE &&
            !this.isToastVisible();
        },

        isToastVisible() {
          const toast = document.getElementById('notificacao-nova-notificacao');
          if (!toast) return false;
          return toast.style.display !== 'none' &&
            !toast.classList.contains('notificacao-exit');
        },

        // ===== MOSTRAR TOAST =====
        showToast() {
          // Rejeita se não está em IDLE
          if (!this.canShowToast()) {
            console.warn('[NotifManager] ❌ Toast rejeitado: estado não é IDLE');
            return false;
          }

          this.setState(NOTIF_STATES.TOAST_SHOWING);
          this.hasStoredNotif = true;

          // Bloqueia o alerta (se existir)
          const alerta = document.getElementById('alerta-novas-notificacoes');
          if (alerta) {
            alerta.classList.add('toast-blocking');
          }

          // Salva flag no localStorage (para recargas)
          try {
            localStorage.setItem('naam_new_notif_flag', '1');
          } catch (e) {
            console.warn('[NotifManager] Erro ao salvar flag:', e);
          }

          console.log('[NotifManager] ✅ Toast: MOSTRANDO');
          return true;
        },

        // ===== INICIAR SAÍDA DO TOAST =====
        startToastExit() {
          if (this.state !== NOTIF_STATES.TOAST_SHOWING) {
            console.warn('[NotifManager] ❌ Toast exit rejeitado: estado não é TOAST_SHOWING');
            return;
          }

          this.setState(NOTIF_STATES.TOAST_EXITING);
          console.log('[NotifManager] ⏹️ Toast: SAINDO (alerta BLOQUEADO)');

          // Libera o alerta após a animação (400ms)
          this.clearTimeout('toastExit');
          this.timeoutMap['toastExit'] = setTimeout(() => {
            this.completeToastExit();
          }, 400);
        },

        // ===== COMPLETAR SAÍDA DO TOAST =====
        completeToastExit() {
          this.setState(NOTIF_STATES.IDLE);
          console.log('[NotifManager] ✅ Toast: REMOVIDO - liberando Alerta');

          // Desbloqueia o alerta
          const alerta = document.getElementById('alerta-novas-notificacoes');
          if (alerta) {
            alerta.classList.remove('toast-blocking');
          }

          // Agora sim, mostra o alerta se foi marcado
          if (this.hasStoredNotif) {
            setTimeout(() => this.showAlert(), 50);
          }
        },

        // ===== MOSTRAR ALERTA =====
        showAlert() {
          // SEGURANÇA: Rejeita se toast ainda está visível
          if (!this.canShowAlert()) {
            console.warn('[NotifManager] ❌ Alerta rejeitado: Toast ainda está ativo ou estado inválido');
            return false;
          }
          // Bloqueio global: se atualização foi iniciada via popup azul,
          // não exibir alerta e remover qualquer instância existente do DOM
          if (window.atualizacaoDisparadaPeloUsuario || window.atualizacaoIniciadaViaPopup) {
            console.warn('[NotifManager] 🚫 Alerta bloqueado: atualização iniciada via popup');
            const alertaBloquear = document.getElementById('alerta-novas-notificacoes');
            if (alertaBloquear) alertaBloquear.remove();
            return false;
          }

          const alerta = document.getElementById('alerta-novas-notificacoes');
          if (!alerta) return false;

          this.setState(NOTIF_STATES.ALERT_SHOWING);

          // Animar entrada do alerta
          alerta.style.display = 'flex';
          void alerta.offsetWidth; // Força reflow
          alerta.classList.remove('hide');
          alerta.classList.add('show');

          // ✨ Ativa animação de pulsar no botão de atualizar
          ativarPulseBotao('btnAtualizar');

          console.log('[NotifManager] ✅ Alerta: MOSTRANDO');
          return true;
        },

        // ===== INICIAR SAÍDA DO ALERTA =====
        startAlertExit() {
          if (this.state !== NOTIF_STATES.ALERT_SHOWING) {
            console.warn('[NotifManager] ⚠️ Alert exit: estado não é ALERT_SHOWING, ignorando');
            return;
          }

          this.setState(NOTIF_STATES.ALERT_EXITING);
          console.log('[NotifManager] ⏹️ Alerta: SAINDO');

          const alerta = document.getElementById('alerta-novas-notificacoes');
          if (alerta) {
            alerta.classList.remove('show');
            alerta.classList.add('hide');
          }

          // Completa saída após animação
          this.clearTimeout('alertExit');
          this.timeoutMap['alertExit'] = setTimeout(() => {
            this.completeAlertExit();
          }, 400);
        },

        // ===== COMPLETAR SAÍDA DO ALERTA =====
        completeAlertExit() {
          this.setState(NOTIF_STATES.IDLE);
          this.hasStoredNotif = false;

          const alerta = document.getElementById('alerta-novas-notificacoes');
          if (alerta) {
            // Se a saída foi disparada em um fluxo iniciado via popup azul,
            // removemos o alerta definitivamente do DOM para não deixar resíduos.
            if (window.atualizacaoDisparadaPeloUsuario || window.atualizacaoIniciadaViaPopup) {
              alerta.remove();
            } else {
              alerta.style.display = 'none';
              alerta.classList.remove('show', 'hide');
            }
          }

          // ✨ Remove animação de pulsar do botão de atualizar
          desativarPulseBotao('btnAtualizar');

          // Limpa localStorage
          try {
            localStorage.removeItem('naam_new_notif_flag');
          } catch (e) {
            console.warn('[NotifManager] Erro ao limpar flag:', e);
          }

          console.log('[NotifManager] ✅ Sistema: IDLE novamente');
        },

        // ===== HELPERS =====
        clearTimeout(key) {
          if (this.timeoutMap[key]) {
            clearTimeout(this.timeoutMap[key]);
            delete this.timeoutMap[key];
          }
        },

        cleanup() {
          Object.keys(this.timeoutMap).forEach(key => this.clearTimeout(key));
          this.state = NOTIF_STATES.IDLE;
        }
      };

      // ===== FUNÇÕES UTILITÁRIAS PARA ANIMAÇÃO DE PULSAR =====
      /**
       * Ativa a animação de pulsar em um botão
       * @param {HTMLElement|string} botao - Elemento do botão ou ID do botão
       */
      function ativarPulseBotao(botao) {
        const elemento = typeof botao === 'string' ? document.getElementById(botao) : botao;
        if (elemento) {
          elemento.classList.add('btn-pulse-active');
        }
      }

      /**
       * Desativa a animação de pulsar em um botão
       * @param {HTMLElement|string} botao - Elemento do botão ou ID do botão
       */
      function desativarPulseBotao(botao) {
        const elemento = typeof botao === 'string' ? document.getElementById(botao) : botao;
        if (elemento) {
          elemento.classList.remove('btn-pulse-active');
        }
      }

      // Restaura estado ao carregar página (se havia notificação pendente)
      (function restoreNotificationState() {
        try {
          const hasFlag = localStorage.getItem('naam_new_notif_flag') === '1';
          if (hasFlag) {
            NotificationManager.hasStoredNotif = true;
            // Mostra alerta após DOM estar pronto
            setTimeout(() => {
              NotificationManager.showAlert();
            }, 100);
          }
        } catch (e) {
          console.warn('[NotifManager] Erro ao restaurar estado:', e);
        }
      })();

      // ===== WRAPPER COMPATÍVEL COM CÓDIGO ANTIGO =====
      function showAlertaNovasNotificacoes(count, deveAguardarToast = false) {
        const badgeDesktop = document.getElementById('badge-notif-desktop');
        const badgeMobile = document.getElementById('badge-notif-mobile');
        let alerta = document.getElementById('alerta-novas-notificacoes');

        // Determina contagem de novas notificações, se fornecida ou salva globalmente
        let totalNovas = null;
        if (typeof count === 'number' && count > 0) {
          totalNovas = count;
        } else if (typeof count === 'string') {
          const parsed = parseInt(count, 10);
          if (!isNaN(parsed) && parsed > 0) {
            totalNovas = parsed;
          }
        }
        // Se não veio via parâmetro, tenta ler do localStorage (contador global)
        if (totalNovas === null) {
          try {
            const stored = localStorage.getItem('naam_new_notif_count');
            if (stored) {
              const parsed = parseInt(stored, 10);
              if (!isNaN(parsed) && parsed > 0) {
                totalNovas = parsed;
              }
            }
          } catch (e) {
            console.warn('[Alerta Painel] ⚠️ Erro ao ler contador global de novas notificações:', e);
          }
        }

        function aplicarTextoEContador() {
          if (!alerta) return;
          const titulo = alerta.querySelector('span.font-semibold');
          const descricao = alerta.querySelector('span.text-sm');

          if (titulo) {
            if (totalNovas === 1) {
              titulo.textContent = 'Existe 1 nova notificação!';
            } else if (typeof totalNovas === 'number' && totalNovas > 1) {
              titulo.textContent = `Existem ${totalNovas} novas notificações!`;
            } else {
              // fallback quando não sabemos o número exato
              titulo.textContent = 'Existem novas notificações!';
            }
          }

          if (descricao) {
            // Mantém o texto padrão do painel
            descricao.textContent = 'Clique em Atualizar Dados para recarregar.';
          }
        }

        function atualizarBadges() {
          const valorBadge = totalNovas != null ? String(totalNovas) : '!';
          if (badgeDesktop) {
            badgeDesktop.textContent = valorBadge;
            badgeDesktop.classList.remove('hidden');
          }
          if (badgeMobile) {
            badgeMobile.textContent = valorBadge;
            badgeMobile.classList.remove('hidden');
          }
        }

        // Bloqueio global: se atualização foi iniciada via popup azul,
        // não exibir quaisquer alertas/badges e remover o alerta do DOM
        if (window.atualizacaoDisparadaPeloUsuario || window.atualizacaoIniciadaViaPopup) {
          if (alerta) alerta.remove();
          if (badgeDesktop) badgeDesktop.classList.add('hidden');
          if (badgeMobile) badgeMobile.classList.add('hidden');
          console.log('[Alerta Painel] 🚫 Bloqueado por atualização via popup; alerta removido do DOM');
          return;
        }

        // ✨ SINCRONIZAÇÃO: Se popup foi fechado sem atualizar (em qualquer página),
        // força mostrar alerta vermelho e animação
        const estado = lerEstadoSincronizacao();
        if (estado && estado.popupFechadoSemAtualizar && !estado.popupAtualizado) {
          const ultimoIdSincronizado = localStorage.getItem(SYNC_LAST_NOTIF_ID_KEY);
          const ultimoIdSalvo = localStorage.getItem('naam_ultimo_id_notificacao');

          // Se ainda há notificação pendente
          if (!ultimoIdSincronizado || ultimoIdSalvo !== ultimoIdSincronizado) {
            console.log('[Alerta Painel] ✅ Popup foi fechado sem atualizar. FORÇANDO exibição do alerta vermelho...');

            // Reseta estado da state machine
            if (typeof NotificationManager !== 'undefined') {
              NotificationManager.setState('idle');
              NotificationManager.hasStoredNotif = false;
            }

            // Garante que o elemento do alerta exista
            if (!alerta) {
              console.warn('[Alerta Painel] ⚠️ Elemento #alerta-novas-notificacoes não encontrado. Recriando alerta no DOM...');
              alerta = document.createElement('div');
              alerta.id = 'alerta-novas-notificacoes';
              alerta.className = 'alerta-novas-notificacoes mb-4';
              alerta.innerHTML = `
              <div class="flex items-center gap-3">
                <span class="text-lg">🔔</span>
                <div class="flex flex-col">
                  <span class="font-semibold">Existem novas notificações!</span>
                  <span class="text-sm text-rose-700">Clique em Atualizar Dados para recarregar.</span>
                </div>
              </div>
            `;

              // Insere o alerta logo acima do cabeçalho
              const header = document.querySelector('.bg-white.rounded-2xl.shadow-xl.p-6.mb-6');
              if (header && header.parentElement) {
                header.parentElement.insertBefore(alerta, header);
              } else {
                document.body.insertBefore(alerta, document.body.firstChild);
              }
            }

            // Força mostrar o alerta vermelho
            alerta.style.display = 'flex';
            void alerta.offsetWidth; // Força reflow
            alerta.classList.remove('hide');
            alerta.classList.add('show');
            console.log('[Alerta Painel] ✅ Alerta vermelho FORÇADO a aparecer');

            // Atualiza textos e contador no próprio alerta
            aplicarTextoEContador();

            // Força ativar animação de pulsar no botão
            ativarPulseBotao('btnAtualizar');
            console.log('[Alerta Painel] ✅ Animação de pulsar FORÇADA no botão Atualizar Dados');

            // Atualiza badges (se ainda existirem no DOM)
            atualizarBadges();

            return;
          }
        }

        // Atualiza texto/contador no alerta com base na contagem (quando existir)
        if (alerta) {
          aplicarTextoEContador();
        }

        if (deveAguardarToast) {
          // Marca como pendente, mas NÃO mostra
          NotificationManager.hasStoredNotif = true;
          atualizarBadges();
          return;
        }

        // Tenta mostrar alerta via state machine
        const showed = NotificationManager.showAlert();
        if (showed) {
          atualizarBadges();
        }
      }

      function hideAlertaNovasNotificacoes(clearFlag = true) {
        const badgeDesktop = document.getElementById('badge-notif-desktop');
        const badgeMobile = document.getElementById('badge-notif-mobile');

        NotificationManager.startAlertExit();

        if (badgeDesktop) badgeDesktop.classList.add('hidden');
        if (badgeMobile) badgeMobile.classList.add('hidden');

        if (!clearFlag) {
          NotificationManager.hasStoredNotif = true; // Mantém pendente
        }
      }

      function handleVerNotificacoesCTA() {
        hideAlertaNovasNotificacoes(true);
        window.location.href = 'minhas-notificacoes.html';
      }

      async function carregarContadorNotificacoes() {
        try {
          const email = localStorage.getItem('userEmail');
          if (!email) return;

          const url = window.CONFIG.APPS_SCRIPT_CASOS;
          const dados = {
            action: 'contarNaoLidas',
            emailUsuario: email
          };

          const response = await fetch(url, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/x-www-form-urlencoded'
            },
            body: 'data=' + encodeURIComponent(JSON.stringify(dados))
          });

          const resultado = await response.json();

          if (resultado.success && resultado.count > 0) {
            const badgeDesktop = document.getElementById('badge-notif-desktop');
            const badgeMobile = document.getElementById('badge-notif-mobile');

            if (badgeDesktop) {
              badgeDesktop.textContent = resultado.count;
              badgeDesktop.classList.remove('hidden');
            }

            if (badgeMobile) {
              badgeMobile.textContent = resultado.count;
              badgeMobile.classList.remove('hidden');
            }

            showAlertaNovasNotificacoes(resultado.count);
          } else {
            // Não esconda se existe flag pendente; apenas limpa visuais quando usuário limpar flag
            hideAlertaNovasNotificacoes(false);
          }
        } catch (error) {
          console.error('Erro ao carregar contador de notificações:', error);
        }
      }

      // ========================================
      // FUNÇÃO SAIR
      // ========================================
      function sair() {
        if (confirm('Deseja realmente sair do sistema?')) {
          sessionStorage.clear();
          localStorage.clear();
          window.location.href = 'index.html';
        }
      }

      // Chama verificações ao carregar
      verificarAutenticacao();
      verificarMenuAdmin();

      // ✨ SINCRONIZAÇÃO: Verifica estado sincronizado na inicialização
      // Se popup foi fechado sem atualizar em outra página, mostra alerta vermelho
      setTimeout(() => {
        if (typeof verificarEstadoSincronizadoNaInicializacao === 'function') {
          verificarEstadoSincronizadoNaInicializacao();
        }
      }, 1500);

      // ========================================
      // SISTEMA DE DETECÇÃO AUTOMÁTICA DE MUDANÇAS
      // ========================================
      // Inicializa o sistema de detecção de mudanças após carregar os dados
      // Usa a mesma lógica que funcionou no teste manual
      if (window.ChangeDetector && window.DataCache && window.UpdateNotification) {
        // Aguarda os dados serem carregados primeiro
        setTimeout(() => {
          const url = window.CONFIG.APPS_SCRIPT_CASOS;
          const cacheKey = 'painel_casos';
          const pollingInterval = window.CONFIG ? (window.CONFIG.POLLING_INTERVAL || 45000) : 45000;

          console.log('🔄 [Painel Casos] Iniciando sistema de detecção automática de mudanças...');
          console.log('   • Intervalo: ' + (pollingInterval / 1000) + ' segundos');
          console.log('   • Cache key: ' + cacheKey);
          console.log('   • URL: ' + url);

          // Configura callback para recarregar dados quando usuário clicar em "Atualizar Agora"
          if (window.UpdateNotification) {
            window.UpdateNotification.onUpdate(() => {
              console.log('[Painel Casos] Usuário solicitou atualização - recarregando dados...');
              // Recarrega os dados quando usuário clicar em "Atualizar Agora"
              if (typeof carregarDadosPlanilha === 'function') {
                carregarDadosPlanilha();
              } else {
                location.reload();
              }
            });
          }

          // Inicia verificação periódica usando a mesma lógica do teste manual
          // Chama checkForChanges diretamente com cacheKey e URL
          let pollingActive = true;
          let pollingIntervalId = null;
          let verificationCount = 0;

          // Função para executar uma verificação
          const executeCheck = async () => {
            // Pausa quando a página está oculta
            if (document.hidden || !pollingActive) {
              console.log('[Painel Casos] ⏸️ Verificação pausada (página oculta ou polling inativo)');
              return;
            }

            verificationCount++;
            const checkTime = new Date().toLocaleTimeString();
            console.log(`[Painel Casos] 🔍 Verificação #${verificationCount} iniciada às ${checkTime}`);

            try {
              // Usa a mesma lógica do teste manual que funcionou
              // O checkForChanges já dispara o evento 'dataChanged' se detectar mudanças
              const hasChanges = await window.ChangeDetector.checkForChanges(cacheKey, url);

              if (hasChanges) {
                console.log('[Painel Casos] ✅ Mudanças detectadas na verificação #' + verificationCount);
                showAlertaNovasNotificacoes();
              } else {
                console.log('[Painel Casos] ✓ Nenhuma mudança detectada na verificação #' + verificationCount);
              }
            } catch (error) {
              console.error('[Painel Casos] ❌ Erro na verificação periódica #' + verificationCount + ':', error);
              // Não para o polling mesmo se houver erro
            }
          };

          // Função para iniciar o polling
          const startPolling = () => {
            // Limpa intervalo anterior se existir
            if (pollingIntervalId) {
              clearInterval(pollingIntervalId);
              pollingIntervalId = null;
            }

            console.log('[Painel Casos] 🚀 Iniciando polling contínuo...');

            // Executa primeira verificação imediatamente
            executeCheck();

            // Configura intervalo para verificações periódicas
            pollingIntervalId = setInterval(() => {
              executeCheck();
            }, pollingInterval);

            // Armazena o ID do intervalo para poder parar depois se necessário
            window._painelCasosPollingInterval = pollingIntervalId;

            console.log('[Painel Casos] ✅ Polling iniciado com sucesso!');
            console.log(`   • Intervalo: ${pollingInterval / 1000} segundos`);
            console.log(`   • Próxima verificação em: ${pollingInterval / 1000} segundos`);
          };

          // Inicia o polling
          startPolling();

          // ========================================
          // SISTEMA SIMPLIFICADO DE VERIFICAÇÃO POR ID
          // ========================================
          // Verifica novas notificações comparando apenas IDs numéricos
          let ultimoIdSalvo = null;
          let intervaloVerificacaoId = null;
          const STORAGE_KEY_ULTIMO_ID = 'naam_ultimo_id_notificacao';

          /**
           * Carrega último ID salvo do localStorage
           */
          function carregarUltimoIdSalvo() {
            try {
              const salvo = localStorage.getItem(STORAGE_KEY_ULTIMO_ID);
              if (salvo !== null && salvo !== undefined && salvo !== '') {
                const id = Number(salvo);
                if (!isNaN(id)) {
                  ultimoIdSalvo = id;
                  console.log('[Cache/Notificações] ✅ ID carregado do cache:', ultimoIdSalvo);
                  return id;
                }
              }
            } catch (error) {
              console.warn('[Cache/Notificações] Erro ao carregar ID do cache:', error);
            }
            return null;
          }

          /**
           * Salva último ID no localStorage
           */
          function salvarUltimoId(id) {
            try {
              if (id !== null && id !== undefined) {
                localStorage.setItem(STORAGE_KEY_ULTIMO_ID, String(id));
                ultimoIdSalvo = id;
                console.log('[Cache/Notificações] 💾 ID salvo no cache:', id);
              }
            } catch (error) {
              console.warn('[Cache/Notificações] Erro ao salvar ID no cache:', error);
            }
          }

          /**
           * Limpa último ID salvo do localStorage
           */
          function limparUltimoIdSalvo() {
            try {
              localStorage.removeItem(STORAGE_KEY_ULTIMO_ID);
              ultimoIdSalvo = null;
              console.log('[Cache/Notificações] 🧹 ID removido do cache');
            } catch (error) {
              console.warn('[Cache/Notificações] Erro ao limpar ID do cache:', error);
            }
          }

          /**
           * Função 1: Buscar último ID da planilha
           */
          async function buscarUltimoId() {
            try {
              if (!window.API || !window.CONFIG || !window.CONFIG.APPS_SCRIPT_CASOS) {
                console.warn('[Verificação ID] API não disponível');
                return null;
              }

              const resultado = await window.API.request(window.CONFIG.APPS_SCRIPT_CASOS, {
                action: 'getLastNotificationId'
              });

              if (resultado.success && resultado.lastId !== null && resultado.lastId !== undefined) {
                return Number(resultado.lastId);
              }

              return null;
            } catch (error) {
              console.error('[Verificação ID] Erro ao buscar último ID:', error);
              return null;
            }
          }

          /**
           * Função 2: Verificação contínua de mudanças
           */
          async function verificarMudancasPorId() {
            try {
              // Chama Função 1 para obter último ID da planilha
              const ultimoIdPlanilha = await buscarUltimoId();

              if (ultimoIdPlanilha === null) {
                console.log('[Verificação ID] Não foi possível obter ID da planilha');
                return;
              }

              // Comparação: ultimoIdPlanilha vs ultimoIdSalvo
              if (ultimoIdSalvo === null) {
                // Primeira execução: apenas salva o ID
                salvarUltimoId(ultimoIdPlanilha);
                console.log('[Verificação ID] ID inicial salvo:', ultimoIdSalvo);
                return;
              }

              // Comparação numérica estrita
              if (ultimoIdPlanilha === ultimoIdSalvo) {
                // IDs iguais → não há nova notificação
                console.log('[Verificação ID] Nenhuma mudança detectada (ID:', ultimoIdPlanilha + ')');
                return;
              }

              // IDs diferentes → há nova notificação
              console.log('[Verificação ID] 🔔 NOVA NOTIFICAÇÃO DETECTADA!');
              console.log('  • ID anterior:', ultimoIdSalvo);
              console.log('  • ID atual:', ultimoIdPlanilha);

              // Calcula uma contagem aproximada de novas notificações
              let diff = null;
              if (typeof ultimoIdSalvo === 'number' && !isNaN(ultimoIdSalvo)) {
                diff = ultimoIdPlanilha - ultimoIdSalvo;
              }
              let countNovas = 1;
              if (diff !== null && diff > 0) {
                countNovas = diff;
              }
              console.log('[Verificação ID] 🧮 Contagem estimada de novas notificações:', countNovas);
              try {
                localStorage.setItem('naam_new_notif_count', String(countNovas));
              } catch (e) {
                console.warn('[Verificação ID] ⚠️ Erro ao salvar contador de novas notificações:', e);
              }

              // Notificar sistema (popup azul + alerta, que lerão o contador)
              mostrarNotificacaoNovaNotificacao(countNovas);

              // Atualizar ultimoIdSalvo e salvar no cache
              salvarUltimoId(ultimoIdPlanilha);
              console.log('[Verificação ID] ID atualizado para:', ultimoIdSalvo);

            } catch (error) {
              console.error('[Verificação ID] Erro na verificação:', error);
            }
          }

          /**
           * Atualiza cache de notificações sem recarregar a página
           */
          // Dispara atualização via popup azul com bloqueio de alertas
          function atualizarViaPopupNotificacao() {
            console.log('[Popup Azul Painel] ▶️ Atualização iniciada pelo usuário');
            // Seta flag global para bloquear qualquer alerta/contadores/animações neste ciclo
            window.atualizacaoDisparadaPeloUsuario = true;
            window.atualizacaoIniciadaViaPopup = true;

            // ✨ SINCRONIZAÇÃO: Marca que popup foi atualizado
            const ultimoIdSalvo = localStorage.getItem('naam_ultimo_id_notificacao');
            const notifId = ultimoIdSalvo ? parseInt(ultimoIdSalvo, 10) : null;
            if (typeof marcarPopupAzulAtualizado === 'function') {
              marcarPopupAzulAtualizado(notifId);
            }
            try {
              localStorage.setItem('naam_estado_atualizacao_painel', JSON.stringify({
                state: true,
                timestamp: Date.now(),
                source: 'popup-azul-painel'
              }));
            } catch (e) {
              console.warn('[Popup Azul Painel] ⚠️ Falha ao persistir estado global:', e);
            }

            // Remove imediatamente qualquer alerta persistente do DOM
            const alerta = document.getElementById('alerta-novas-notificacoes');
            if (alerta) alerta.remove();

            // Garante remoção de animação do botão principal de atualizar
            desativarPulseBotao('btnAtualizar');

            // Executa o fluxo padrão de atualização (cache + recarregar)
            if (typeof atualizarCacheNotificacoes === 'function') {
              atualizarCacheNotificacoes();
            } else {
              // Fallback: remove toast e dá reload
              const notificacao = document.getElementById('notificacao-nova-notificacao');
              if (notificacao) notificacao.remove();
              location.reload();
            }
          }

          function atualizarCacheNotificacoes() {
            console.log('[Notificação] 🔄 Atualizando cache de notificações...');

            // Remove a notificação visual com animação de saída
            const notificacao = document.getElementById('notificacao-nova-notificacao');
            if (notificacao) {
              notificacao.classList.remove('notificacao-visible');
              notificacao.classList.add('notificacao-exit');
              setTimeout(() => {
                notificacao.remove();
              }, 400);
            }

            // Limpa cache de registros e atualiza ID
            limparCacheERecarregarNotificacoes();
            hideAlertaNovasNotificacoes(true);

            // Recarrega os dados da planilha sem recarregar a página
            if (typeof carregarDadosPlanilha === 'function') {
              carregarDadosPlanilha();
              console.log('[Notificação] ✅ Cache atualizado e dados recarregados');

              // ✨ SINCRONIZAÇÃO: Após atualização bem-sucedida, atualiza último ID sincronizado
              // Aguarda um pouco para garantir que o ID foi atualizado
              setTimeout(() => {
                const ultimoIdSalvo = localStorage.getItem('naam_ultimo_id_notificacao');
                if (ultimoIdSalvo && typeof marcarPopupAzulAtualizado === 'function') {
                  const notifId = parseInt(ultimoIdSalvo, 10);
                  // Atualiza o último ID sincronizado para refletir que esta notificação foi processada
                  try {
                    localStorage.setItem(SYNC_LAST_NOTIF_ID_KEY, String(notifId));
                    console.log('[Sync] ✅ Último ID sincronizado atualizado após atualização:', notifId);
                  } catch (e) {
                    console.warn('[Sync] ⚠️ Erro ao atualizar último ID sincronizado:', e);
                  }
                }
              }, 2000);
            } else {
              console.warn('[Notificação] ⚠️ Função carregarDadosPlanilha não disponível');
            }
          }

          /**
           * Atualiza o contador no alerta vermelho com animação de shake e incrementa o valor
           * @param {number} countNovas - Quantidade de novas notificações a adicionar
           */
          function atualizarContadorAlertaVermelhoComShake(countNovas) {
            const alerta = document.getElementById('alerta-novas-notificacoes');
            if (!alerta) return;

            // Verifica se o alerta está visível
            const estaVisivel = alerta.classList.contains('show') ||
              alerta.style.display === 'flex' ||
              (alerta.offsetParent !== null && alerta.style.display !== 'none');

            if (!estaVisivel) return;

            const titulo = alerta.querySelector('span.font-semibold');
            if (!titulo) return;

            // Extrai o número atual do texto do título
            let contadorAtual = 0;
            const textoAtual = titulo.textContent;
            const match = textoAtual.match(/(\d+)/);
            if (match) {
              contadorAtual = parseInt(match[1], 10);
            } else if (textoAtual.includes('Existe 1 nova')) {
              contadorAtual = 1;
            } else if (textoAtual.includes('Existem novas')) {
              // Se não tem número, tenta ler do localStorage
              try {
                const stored = localStorage.getItem('naam_new_notif_count');
                if (stored) {
                  contadorAtual = parseInt(stored, 10) || 0;
                }
              } catch (e) {
                console.warn('[Contador] ⚠️ Erro ao ler contador:', e);
              }
            }

            // Incrementa o contador
            const novoTotal = contadorAtual + (countNovas || 1);

            // Atualiza o localStorage global
            try {
              localStorage.setItem('naam_new_notif_count', String(novoTotal));
            } catch (e) {
              console.warn('[Contador] ⚠️ Erro ao salvar contador:', e);
            }

            // Atualiza o texto do título
            if (novoTotal === 1) {
              titulo.textContent = 'Existe 1 nova notificação!';
            } else {
              titulo.textContent = `Existem ${novoTotal} novas notificações!`;
            }

            // Aplica animação de shake no título
            titulo.classList.add('contador-shake');
            setTimeout(() => {
              titulo.classList.remove('contador-shake');
            }, 500);

            // Atualiza badges se existirem
            const badgeDesktop = document.getElementById('badge-notif-desktop');
            const badgeMobile = document.getElementById('badge-notif-mobile');
            if (badgeDesktop) {
              badgeDesktop.textContent = String(novoTotal);
              badgeDesktop.classList.remove('hidden');
            }
            if (badgeMobile) {
              badgeMobile.textContent = String(novoTotal);
              badgeMobile.classList.remove('hidden');
            }

            console.log('[Contador] ✅ Contador atualizado com shake:', contadorAtual, '→', novoTotal);
          }

          /**
           * Mostra notificação visual elegante e compacta de nova notificação
           */
          function mostrarNotificacaoNovaNotificacao(count) {
            // Verifica se o alerta vermelho já está visível
            const alertaVermelho = document.getElementById('alerta-novas-notificacoes');
            const alertaEstaVisivel = alertaVermelho && (
              alertaVermelho.classList.contains('show') ||
              alertaVermelho.style.display === 'flex' ||
              (alertaVermelho.offsetParent !== null && alertaVermelho.style.display !== 'none')
            );

            // Se o alerta vermelho já está visível, apenas atualiza o contador com shake
            if (alertaEstaVisivel) {
              console.log('[Popup Azul] ⚠️ Alerta vermelho já está visível. Atualizando contador com shake em vez de mostrar popup azul.');
              atualizarContadorAlertaVermelhoComShake(count || 1);
              return; // Não cria o popup azul
            }

            // Remove notificação anterior se existir
            const notificacaoAnterior = document.getElementById('notificacao-nova-notificacao');
            if (notificacaoAnterior) {
              notificacaoAnterior.remove();
            }
            // Marca a flag mas não mostra alerta ainda (aguardará saída do toast)
            // Passa a contagem (se fornecida) para o alerta vermelho
            showAlertaNovasNotificacoes(typeof count === 'number' ? count : null, true);

            // ✨ SINCRONIZAÇÃO: Marca que popup azul está ativo
            const ultimoIdSalvo = localStorage.getItem('naam_ultimo_id_notificacao');
            const notifId = ultimoIdSalvo ? parseInt(ultimoIdSalvo, 10) : null;
            if (typeof marcarPopupAzulAtivo === 'function') {
              marcarPopupAzulAtivo(notifId);
            }

            // Cria container principal
            const notificacao = document.createElement('div');
            notificacao.id = 'notificacao-nova-notificacao';
            notificacao.className = 'notificacao-nova-elegante';

            // HTML da notificação harmônica e integrada
            notificacao.innerHTML = `
        <div class="notificacao-conteudo">
          <div class="notificacao-icone-container">
            <svg class="notificacao-icone" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
              <path d="M18 8A6 6 0 0 0 6 8c0 7-3 9-3 9h18s-3-2-3-9" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
              <path d="M13.73 21a2 2 0 0 1-3.46 0" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
            </svg>
          </div>
          <div class="notificacao-texto">
            <div class="notificacao-titulo">
              <span class="notificacao-badge">NOVO</span>
              <span class="notificacao-mensagem-principal">Nova Notificação Recebida</span>
            </div>
            <div class="notificacao-descricao">
              Banco de dados recebeu nova notificação
            </div>
            <div class="notificacao-acoes">
              <button class="notificacao-btn-atualizar" onclick="if (typeof atualizarViaPopupNotificacao === 'function') { atualizarViaPopupNotificacao(); } else { this.closest('.notificacao-nova-elegante').remove(); location.reload(); }">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <path d="M21.5 2v6h-6M2.5 22v-6h6M2 11.5a10 10 0 0 1 18.8-4.3M22 12.5a10 10 0 0 1-18.8 4.2"/>
                </svg>
                Atualizar
              </button>
              <button class="notificacao-btn-fechar" onclick="fecharNotificacaoToast(this)">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <line x1="18" y1="6" x2="6" y2="18"></line>
                  <line x1="6" y1="6" x2="18" y2="18"></line>
                </svg>
              </button>
            </div>
          </div>
        </div>
        <div class="notificacao-progresso"></div>
      `;

            document.body.appendChild(notificacao);

            // Animação de entrada
            setTimeout(() => {
              notificacao.classList.add('notificacao-visible');
            }, 10);

            // Barra de progresso (15 segundos) - apenas visual, não fecha mais sozinha
            const progresso = notificacao.querySelector('.notificacao-progresso');
            if (progresso) {
              progresso.style.animation = 'notificacaoProgresso 15s linear forwards';
            }

            // Removido o fechamento automático em 15s.
            // Este popup azul só sai quando:
            // - Usuário clicar em "Atualizar" (atualiza os dados), ou
            // - Usuário clicar no "X" (fecha e força o alerta vermelho).
          }

          /**
           * Função para fechar a notificação toast manualmente
           */
          function fecharNotificacaoToast(botao) {
            const notificacao = botao.closest('.notificacao-nova-elegante');
            if (notificacao) {
              // ✨ SINCRONIZAÇÃO: Marca que popup foi fechado sem atualizar
              const ultimoIdSalvo = localStorage.getItem('naam_ultimo_id_notificacao');
              const notifId = ultimoIdSalvo ? parseInt(ultimoIdSalvo, 10) : null;
              if (typeof marcarPopupAzulFechadoSemAtualizar === 'function') {
                marcarPopupAzulFechadoSemAtualizar(notifId);
              }

              notificacao.classList.remove('notificacao-visible');
              notificacao.classList.add('notificacao-exit');

              // Remove do DOM após animação
              setTimeout(() => {
                notificacao.remove();
                // Mostra o alerta persistente após fechar o toast
                if (typeof showAlertaNovasNotificacoes === 'function') {
                  showAlertaNovasNotificacoes();
                }
              }, 400);
            }
          }

          // Torna a função acessível globalmente para o onclick inline
          if (typeof window !== 'undefined') {
            window.fecharNotificacaoToast = fecharNotificacaoToast;
          }

          /**
           * Limpa cache e recarrega notificações
           * NOTA: Não limpa o último ID salvo, apenas atualiza para o ID atual da planilha
           */
          function limparCacheERecarregarNotificacoes() {
            console.log('[Cache/Notificações] 🧹 Limpando cache de registros...');

            // Limpa cache de registros (mas mantém o ID de notificação)
            if (window.DataCache) {
              window.DataCache.clear('gerenciar_casos');
              window.DataCache.clearAll(); // Limpa todos os caches para garantir
              console.log('[Cache/Notificações] ✅ Cache limpo');
            }

            // ✨ SINCRONIZAÇÃO ENTRE PÁGINAS: Notifica outras páginas abertas
            try {
              const invalidationEvent = {
                type: 'cache_invalidation',
                timestamp: Date.now(),
                source: 'painel-casos',
                cacheKey: 'gerenciar_casos'
              };
              localStorage.setItem('naam_cache_invalidation', JSON.stringify(invalidationEvent));
              console.log('[Cache/Notificações] 📡 Evento de invalidação enviado para outras páginas');
              console.log('[Painel] ✅ Solicitei atualização da aba "Gerenciar Registros" (cache "gerenciar_casos" invalidado e sincronização disparada)');
            } catch (e) {
              console.warn('[Cache/Notificações] ⚠️ Erro ao enviar evento de invalidação:', e);
            }

            // Atualiza o último ID salvo com o ID atual da planilha (sem resetar)
            if (window.API && window.CONFIG && window.CONFIG.APPS_SCRIPT_CASOS) {
              buscarUltimoId().then(id => {
                if (id !== null) {
                  salvarUltimoId(id);
                  console.log('[Cache/Notificações] ✅ ID atualizado para:', ultimoIdSalvo);

                  // ✨ SINCRONIZAÇÃO: Só atualiza último ID sincronizado se for ação do usuário
                  // (não atualiza se for chamada automaticamente)
                  if (window._carregarDadosPlanilhaIsUserAction) {
                    try {
                      localStorage.setItem(SYNC_LAST_NOTIF_ID_KEY, String(id));
                      console.log('[Sync] ✅ Último ID sincronizado atualizado (ação do usuário):', id);
                    } catch (e) {
                      console.warn('[Sync] ⚠️ Erro ao atualizar último ID sincronizado:', e);
                    }
                  }
                }
              });
            }
          }

          /**
           * Inicia o sistema de verificação contínua
           */
          function iniciarVerificacaoPorId() {
            // Verifica se API e CONFIG estão disponíveis
            if (!window.API || !window.CONFIG || !window.CONFIG.APPS_SCRIPT_CASOS) {
              console.warn('[Verificação ID] ⏳ Aguardando carregamento da API...');
              // Tenta novamente após 1 segundo
              setTimeout(iniciarVerificacaoPorId, 1000);
              return;
            }

            // Limpa intervalo anterior se existir
            if (intervaloVerificacaoId) {
              clearInterval(intervaloVerificacaoId);
            }

            console.log('[Verificação ID] 🚀 Iniciando sistema de verificação por ID...');
            console.log('[Verificação ID] API disponível:', !!window.API);
            console.log('[Verificação ID] CONFIG disponível:', !!window.CONFIG);
            console.log('[Verificação ID] APPS_SCRIPT_CASOS:', window.CONFIG.APPS_SCRIPT_CASOS);

            // Carrega ID salvo do cache primeiro
            const idSalvo = carregarUltimoIdSalvo();

            // Se não há ID salvo, busca da planilha
            if (idSalvo === null) {
              buscarUltimoId().then(id => {
                if (id !== null) {
                  salvarUltimoId(id);
                  console.log('[Verificação ID] ✅ ID inicial obtido e salvo:', ultimoIdSalvo);
                } else {
                  console.warn('[Verificação ID] ⚠️ Não foi possível obter ID inicial, tentando novamente...');
                }
              });
            } else {
              console.log('[Verificação ID] ✅ ID carregado do cache:', ultimoIdSalvo);
            }

            // Intervalo de verificação: 10 segundos (pode ser configurado)
            const intervalo = 10000; // 10 segundos

            // Executa primeira verificação após 5 segundos
            setTimeout(() => {
              verificarMudancasPorId();
            }, 5000);

            // Configura verificação contínua
            intervaloVerificacaoId = setInterval(() => {
              verificarMudancasPorId();
            }, intervalo);

            console.log('[Verificação ID] ✅ Sistema iniciado! Verificando a cada', intervalo / 1000, 'segundos');
          }

          // Aguarda carregamento completo antes de iniciar
          function aguardarEIniciar() {
            // Verifica se tudo está carregado
            if (typeof window !== 'undefined' &&
              typeof window.CONFIG !== 'undefined' &&
              typeof window.API !== 'undefined' &&
              window.CONFIG.APPS_SCRIPT_CASOS) {
              iniciarVerificacaoPorId();
            } else {
              // Tenta novamente após 500ms
              setTimeout(aguardarEIniciar, 500);
            }
          }

          // Inicia verificação quando a página carregar
          if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', () => {
              // Aguarda um pouco mais para garantir que todos os scripts carregaram
              setTimeout(aguardarEIniciar, 1000);
            });
          } else {
            // Página já carregou, aguarda scripts
            setTimeout(aguardarEIniciar, 1000);
          }

          // Pausa quando a página fica oculta e retoma quando fica visível
          document.addEventListener('visibilitychange', () => {
            if (document.hidden) {
              console.log('[Painel Casos] 👁️ Página oculta - pausando verificação');
              pollingActive = false;
            } else {
              console.log('[Painel Casos] 👁️ Página visível - retomando verificação');
              pollingActive = true;
              // Executa uma verificação imediatamente quando a página fica visível
              executeCheck();
            }
          });

          // Monitora se o intervalo ainda está ativo (para debug)
          setInterval(() => {
            if (pollingIntervalId) {
              console.log(`[Painel Casos] 📊 Status: Polling ativo | Verificações realizadas: ${verificationCount} | Próxima em: ${pollingInterval / 1000}s`);
            } else {
              console.warn('[Painel Casos] ⚠️ ATENÇÃO: Polling parado! Reiniciando...');
              startPolling();
            }
          }, 60000); // Log de status a cada 1 minuto

          console.log('✅ [Painel Casos] Sistema de detecção de mudanças iniciado e rodando continuamente');
          console.log('   💡 O sistema ficará monitorando mudanças automaticamente');
          console.log('   💡 Quando detectar uma mudança, mostrará uma notificação no canto da tela');
        }, 3000); // Aguarda 3 segundos para garantir que os dados foram carregados
      } else {
        console.warn('⚠️ [Painel Casos] ChangeDetector, DataCache ou UpdateNotification não disponíveis');
      }

    </script>

    <!-- Script para suprimir erros de extensões do navegador -->
    <script>
      // Suprime erros de extensões do navegador que não são do nosso código
      (function () {
        const originalError = console.error;
        const originalWarn = console.warn;

        // Lista de padrões de erros de extensões para ignorar
        const ignorePatterns = [
          'content.bundle.js',
          'products.json',
          'chrome-extension://',
          'moz-extension://',
          'safari-extension://',
          'edge-extension://',
          'Uncaught SyntaxError: "undefined" is not valid JSON',
          'Unexpected token \'<\''
        ];

        console.error = function (...args) {
          const message = args.join(' ');
          // Ignora erros de extensões
          if (ignorePatterns.some(pattern => message.includes(pattern))) {
            return; // Suprime o erro
          }
          originalError.apply(console, args);
        };

        console.warn = function (...args) {
          const message = args.join(' ');
          // Ignora avisos de extensões
          if (ignorePatterns.some(pattern => message.includes(pattern))) {
            return; // Suprime o aviso
          }
          originalWarn.apply(console, args);
        };

        // Trata erros não capturados de extensões (captura fase de captura)
        window.addEventListener('error', function (e) {
          try {
            const errorMessage = String(e.message || '');
            const errorSource = String(e.filename || e.source || '');
            const errorStack = String(e.error?.stack || '');

            // Ignora erros de extensões
            if (ignorePatterns.some(pattern =>
              errorMessage.includes(pattern) ||
              errorSource.includes(pattern) ||
              errorStack.includes(pattern)
            )) {
              e.preventDefault();
              e.stopPropagation();
              e.stopImmediatePropagation();
              return false;
            }
          } catch (err) {
            // Se houver erro ao processar, deixa passar
          }
        }, true);

        // Trata promessas rejeitadas de extensões
        window.addEventListener('unhandledrejection', function (e) {
          try {
            const reason = String(e.reason || '');
            const reasonStack = String(e.reason?.stack || '');

            // Ignora rejeições de extensões
            if (ignorePatterns.some(pattern =>
              reason.includes(pattern) || reasonStack.includes(pattern)
            )) {
              e.preventDefault();
              e.stopPropagation();
              return false;
            }
          } catch (err) {
            // Se houver erro ao processar, deixa passar
          }
        });
      })();
    </script>

    <!-- ========================================
       MODAL DE DETALHES DO REGISTRO
       ======================================== -->
    <div id="modal-detalhes" class="modal-detalhes">
      <div class="modal-detalhes-conteudo">
        <div
          class="modal-detalhes-header flex items-center justify-between px-4 sm:px-6 md:px-8 py-4 sm:py-5 border-b border-gray-200 bg-gradient-to-r from-white to-blue-50/30">
          <div>
            <h2
              class="modal-detalhes-titulo text-xl sm:text-2xl md:text-3xl font-bold text-gray-800 flex items-center gap-2 sm:gap-3">
              <span class="text-2xl sm:text-3xl">🧾</span>
              <span id="modal-detalhes-titulo">Detalhes do Registro</span>
            </h2>
            <p class="modal-detalhes-subtitulo text-xs sm:text-sm text-gray-600 mt-1" id="modal-detalhes-subtitulo"></p>
          </div>
          <button
            class="modal-detalhes-close text-gray-400 hover:text-gray-600 text-3xl font-light transition-colors w-8 h-8 sm:w-10 sm:h-10 flex items-center justify-center rounded-lg hover:bg-gray-100"
            onclick="fecharModalDetalhes()" aria-label="Fechar">×</button>
        </div>

        <div class="modal-detalhes-body" id="modal-detalhes-body"></div>
      </div>
    </div>

    <!-- Intro.js - Sistema de Onboarding -->
    <script src="https://unpkg.com/intro.js/minified/intro.min.js"></script>
    <script src="assets/js/utils/onboarding.js"></script>
    <script>
      // Inicializar onboarding após carregamento completo da página
      document.addEventListener('DOMContentLoaded', function () {
        // Aguardar dados carregarem antes de iniciar o tour
        setTimeout(function () {
          if (window.NAAMOnboarding) {
            NAAMOnboarding.init('painel-casos');
          }
        }, 2500);
      });
    </script>
</body>

<script>
  (function () {
    const DURATION_OPEN = 360;
    const DURATION_CLOSE = 280;
    const easingOpen = "cubic-bezier(0.16, 1, 0.3, 1)";
    const easingClose = "cubic-bezier(0.4, 0, 0.2, 1)";

    const raf = () => new Promise((r) => requestAnimationFrame(r));

    function initAccordion(details) {
      const summary = details.querySelector("summary");
      const content = details.querySelector(".filter-group-content");
      if (!summary || !content) return;

      // Guarda referência fixa ao conteúdo para o modo painel (o conteúdo será movido no DOM).
      details.__panelContent = content;
      content.__panelOwner = details;

      // Modo painel: não expande inline; clique abre apenas o advancedPanel abaixo.
      if ((details.dataset.mode || '') === 'panel') {
        details.open = false;
        details.dataset.expanded = 'false';
        content.style.overflow = 'hidden';
        content.style.height = '';

        summary.addEventListener('click', (e) => {
          e.preventDefault();
          openFilterPanel(details);
        });
        return;
      }

      // Mantém o conteúdo sempre mensurável para evitar travadas/altura 0.
      const initiallyOpen = details.hasAttribute("open");
      details.open = true;

      details.dataset.expanded = initiallyOpen ? "true" : "false";
      content.style.overflow = initiallyOpen ? "visible" : "hidden";
      content.style.height = initiallyOpen ? "" : "0px";

      let isAnimating = false;
      let animation = null;

      const cancelAnimation = () => {
        if (animation) {
          animation.cancel();
          animation = null;
        }
      };

      const animateHeight = (from, to, duration, easing) => {
        cancelAnimation();
        animation = content.animate(
          [
            { height: `${from}px`, opacity: 0.92 },
            { height: `${to}px`, opacity: 1 },
          ],
          { duration, easing }
        );
        return animation;
      };

      const expand = async () => {
        if (isAnimating) return;
        isAnimating = true;
        details.dataset.expanded = "true";
        content.style.overflow = "hidden";

        // Garantir que estamos com altura 0 antes de medir a altura final.
        content.style.height = content.getBoundingClientRect().height + "px";
        await raf();
        await raf();
        const startHeight = content.getBoundingClientRect().height;
        const endHeight = content.scrollHeight;
        content.style.height = `${startHeight}px`;

        const a = animateHeight(startHeight, endHeight, DURATION_OPEN, easingOpen);
        a.onfinish = () => {
          content.style.height = "";
          content.style.overflow = "visible";
          isAnimating = false;
          animation = null;
        };
        a.oncancel = () => {
          isAnimating = false;
        };
      };

      const collapse = async () => {
        if (isAnimating) return;
        isAnimating = true;
        content.style.overflow = "hidden";

        // Trava a altura atual para animar até zero.
        content.style.height = content.scrollHeight + "px";
        await raf();
        const startHeight = content.getBoundingClientRect().height;
        const endHeight = 0;

        const a = animateHeight(startHeight, endHeight, DURATION_CLOSE, easingClose);
        a.onfinish = () => {
          content.style.height = "0px";
          details.dataset.expanded = "false";
          content.style.overflow = "hidden";
          isAnimating = false;
          animation = null;
        };
        a.oncancel = () => {
          isAnimating = false;
        };
      };

      summary.addEventListener("click", (e) => {
        e.preventDefault();
        const expanded = details.dataset.expanded === "true";
        if (expanded) {
          void collapse();
        } else {
          void expand();
        }
      });
    }

    function boot() {
      document.querySelectorAll("details.filter-group").forEach(initAccordion);
      setupEscolaAutocomplete();
      setupTipoDeficienciaAutocomplete();

      ensureFilterCardBadges();
      updateFilterCardBadges();

      // Atualiza os badges ao interagir com qualquer filtro
      const box = document.getElementById('quickAdvancedFiltersBox');
      if (box) {
        box.addEventListener('input', () => updateFilterCardBadges(), true);
        box.addEventListener('change', () => updateFilterCardBadges(), true);
      }

      // Fallback global: garante atualização mesmo quando o conteúdo é movido para o painel
      document.addEventListener('input', (e) => {
        const t = e.target;
        if (t && t.closest && t.closest('.filter-group-content')) updateFilterCardBadges();
      }, true);
      document.addEventListener('change', (e) => {
        const t = e.target;
        if (t && t.closest && t.closest('.filter-group-content')) updateFilterCardBadges();
      }, true);

      // Deixa o bloco inteiro das opções clicável (marca/desmarca o checkbox interno)
      document.addEventListener('click', (e) => {
        const target = e.target;
        if (!target || !target.closest) return;

        // Não interferir quando o clique já é no próprio input/controle
        if (target.matches('input, select, textarea, option, button, a')) return;

        const item = target.closest('.checkbox-container');
        if (!item) return;

        const cb = item.querySelector('input.custom-checkbox[type="checkbox"], input.custom-checkbox[type="radio"]');
        if (!cb || cb.disabled) return;

        // Evita duplo toggle quando o clique foi no label associado
        if (target.tagName === 'LABEL') return;

        if (cb.type === 'checkbox') {
          cb.checked = !cb.checked;
        } else {
          cb.checked = true;
        }
        cb.dispatchEvent(new Event('change', { bubbles: true }));
      }, true);
    }

    function openFilterPanel(details) {
      const panel = document.getElementById('advancedPanel');
      const host = document.getElementById('advancedPanelContent');
      const content = details.__panelContent || details.querySelector('.filter-group-content');
      if (!panel || !host || !content) return;

      // Lock/fila: evita que cliques durante a animação corrompam o estado.
      if (host.__swapLock) {
        host.__queuedDetails = details;
        return;
      }

      const active = details.classList.contains('is-active');

      // Garante que os botões dos filtros fiquem sempre visíveis
      const ensureFiltersVisible = () => {
        const filtersGrid = document.querySelector('.filters-grid');
        if (!filtersGrid) return;

        // Scrolla suavemente para garantir que os filtros fiquem visíveis no topo
        setTimeout(() => {
          filtersGrid.scrollIntoView({ behavior: 'smooth', block: 'start', inline: 'nearest' });
        }, 50);
      };

      // Scroll para centralizar (usado apenas no fechamento)
      const centerSelectedCard = () => {
        const summary = details.querySelector('summary') || details;
        summary.scrollIntoView({ behavior: 'smooth', block: 'center', inline: 'nearest' });
      };

      // Animação RÁPIDA para troca entre filtros (SEM scroll, só anima)
      const animateSwap = (fn) => {
        host.__swapLock = true;

        // Animação de fade out RÁPIDA (sem aguardar scroll)
        host.classList.remove('is-entering');
        host.classList.remove('is-leaving-slow');
        host.classList.add('is-leaving');

        // Aguarda a animação de saída terminar (RÁPIDA)
        setTimeout(() => {
          fn();
          host.classList.remove('is-leaving');
          host.classList.add('is-entering');

          // Após trocar o conteúdo, garante que os filtros fiquem visíveis
          ensureFiltersVisible();

          requestAnimationFrame(() => {
            requestAnimationFrame(() => {
              host.classList.remove('is-entering');
              host.__swapLock = false;

              // Se houve clique durante a animação, executa o último pedido agora.
              if (host.__queuedDetails) {
                const next = host.__queuedDetails;
                host.__queuedDetails = null;
                setTimeout(() => openFilterPanel(next), 0);
              }
            });
          });
        }, 200); // Duração RÁPIDA da animação de fade out para troca
      };

      // Animação LENTA para fechamento do menu (COM scroll para centralizar)
      const animateClose = (fn) => {
        host.__swapLock = true;

        // PRIMEIRO: Scroll para centralizar (aguarda o scroll terminar)
        setTimeout(() => {
          // DEPOIS: Inicia animação de fade out LENTA
          host.classList.remove('is-entering');
          host.classList.remove('is-leaving');
          host.classList.add('is-leaving-slow');

          // Aguarda a animação de saída terminar (LENTA)
          setTimeout(() => {
            fn();
            host.classList.remove('is-leaving-slow');
            host.__swapLock = false;
          }, 400); // Duração LENTA da animação de fade out para fechamento
        }, 500); // Delay maior para o scroll (mais suave no fechamento)
      };

      const restoreActive = () => {
        const prevContent = host.querySelector('.filter-group-content');
        const prevOwner = prevContent ? prevContent.__panelOwner : null;
        if (prevOwner) {
          prevOwner.classList.remove('is-active');
          prevOwner.dataset.expanded = 'false';
        }
        if (prevContent && prevContent.__panelPlaceholder) {
          prevContent.__panelPlaceholder.replaceWith(prevContent);
          prevContent.__panelPlaceholder = null;
        }
      };

      // Se clicou no mesmo, fecha painel
      if (active) {
        // PRIMEIRO: Centraliza o card (scroll acontece primeiro)
        centerSelectedCard();

        // DEPOIS: Animação de fade out LENTA (fechamento)
        animateClose(() => {
          restoreActive();
          host.innerHTML = '';
          panel.classList.remove('open');
          updateFilterCardBadges();
        });

        return;
      }

      // Troca de filtro: Animação RÁPIDA sem scroll de centralização
      // A página se adapta automaticamente, mantendo os filtros visíveis
      animateSwap(() => {
        restoreActive();
        host.innerHTML = '';
        const placeholder = document.createComment('filter-group-content-placeholder');
        content.parentNode.insertBefore(placeholder, content);
        content.__panelPlaceholder = placeholder;
        host.appendChild(content);

        details.classList.add('is-active');
        details.dataset.expanded = 'true';
        panel.classList.add('open');

        // Revalida o autocomplete caso o conteúdo tenha sido movido
        setupEscolaAutocomplete();
        setupTipoDeficienciaAutocomplete();

        updateFilterCardBadges();
      });
    }

    // Função para fechar o painel de filtros com animação suave LENTA
    function closeFilterPanel() {
      const panel = document.getElementById('advancedPanel');
      const host = document.getElementById('advancedPanelContent');
      if (!panel || !host) return;

      // Verifica se o painel está aberto
      if (!panel.classList.contains('open')) return;

      // Animação de fechamento LENTA
      host.classList.remove('is-entering');
      host.classList.remove('is-leaving');
      host.classList.add('is-leaving-slow');

      setTimeout(() => {
        // Restaura o conteúdo ao filtro original
        const prevContent = host.querySelector('.filter-group-content');
        const prevOwner = prevContent ? prevContent.__panelOwner : null;

        if (prevOwner) {
          prevOwner.classList.remove('is-active');
          prevOwner.dataset.expanded = 'false';
        }

        if (prevContent && prevContent.__panelPlaceholder) {
          prevContent.__panelPlaceholder.replaceWith(prevContent);
          prevContent.__panelPlaceholder = null;
        }

        host.innerHTML = '';
        panel.classList.remove('open');
        host.classList.remove('is-leaving-slow');

        updateFilterCardBadges();
      }, 450); // Duração da animação de fechamento LENTA (450ms)
    }

    // Nota: Comportamento de fechamento automático ao scrollar foi removido
    // O painel permanece aberto durante o scroll para melhor usabilidade

    window.toggleAdvancedFilters = function toggleAdvancedFilters() {
      const box = document.getElementById('quickAdvancedFiltersBox');
      if (!box) return;
      setTimeout(() => {
        box.scrollIntoView({ behavior: 'smooth', block: 'start' });
      }, 50);
    };

    if (document.readyState === "loading") {
      document.addEventListener("DOMContentLoaded", boot);
    } else {
      boot();
    }
  })();
</script>

<script>
  (function () {
    const svgChevron = "<svg xmlns='http://www.w3.org/2000/svg' width='18' height='18' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'><path d='m6 9 6 6 6-6'/></svg>";

    function closeAll(except) {
      document.querySelectorAll('.select-shell[data-open="true"]').forEach((el) => {
        if (except && el === except) return;
        el.dataset.open = 'false';
        const menu = el.__menu;
        const trigger = el.__trigger;
        if (menu) menu.classList.remove('open');
        if (trigger) trigger.setAttribute('aria-expanded', 'false');
        if (el.__followRAF) {
          cancelAnimationFrame(el.__followRAF);
          el.__followRAF = null;
        }
      });
    }

    function getOverlay() {
      const filtersSection = document.getElementById('filtersSection');
      if (!filtersSection) return null;

      let overlay = document.getElementById('selectOverlay');
      if (!overlay) {
        overlay = document.createElement('div');
        overlay.id = 'selectOverlay';
        filtersSection.appendChild(overlay);
      }
      return overlay;
    }

    function positionMenu(shell) {
      const menu = shell.__menu;
      const trigger = shell.__trigger;
      const overlay = shell.__overlay || getOverlay();
      if (!menu || !trigger || !overlay) return;
      shell.__overlay = overlay;

      const rect = trigger.getBoundingClientRect();
      const overlayRect = overlay.getBoundingClientRect();
      const gap = 8;

      const left = rect.left - overlayRect.left;
      const top = rect.bottom - overlayRect.top + gap;

      menu.style.left = `${Math.max(0, left)}px`;
      menu.style.top = `${Math.max(0, top)}px`;
      menu.style.width = `${Math.max(220, rect.width)}px`;
    }

    function startFollowing(shell) {
      if (shell.__followRAF) return;
      const tick = () => {
        if (shell.dataset.open !== 'true') {
          shell.__followRAF = null;
          return;
        }
        positionMenu(shell);
        shell.__followRAF = requestAnimationFrame(tick);
      };
      shell.__followRAF = requestAnimationFrame(tick);
    }

    function buildCustomSelect(select) {
      if (!select || select.dataset.customized === 'true') return;
      select.dataset.customized = 'true';

      const shell = document.createElement('div');
      shell.className = 'select-shell';
      shell.dataset.open = 'false';

      const trigger = document.createElement('button');
      trigger.type = 'button';
      trigger.className = 'select-trigger';
      trigger.setAttribute('aria-haspopup', 'listbox');
      trigger.setAttribute('aria-expanded', 'false');

      const label = document.createElement('span');
      label.style.whiteSpace = 'nowrap';
      label.style.overflow = 'hidden';
      label.style.textOverflow = 'ellipsis';

      const icon = document.createElement('span');
      icon.className = 'select-trigger-icon';
      icon.innerHTML = svgChevron;

      trigger.appendChild(label);
      trigger.appendChild(icon);

      const menu = document.createElement('div');
      menu.className = 'select-menu';
      menu.setAttribute('role', 'listbox');

      // Keep references on shell for portal/positioning.
      shell.__menu = menu;
      shell.__trigger = trigger;

      const updateLabel = () => {
        const opt = select.options[select.selectedIndex];
        label.textContent = opt ? opt.textContent : '';
      };

      const rebuildOptions = () => {
        menu.innerHTML = '';
        Array.from(select.options).forEach((opt) => {
          const item = document.createElement('div');
          item.className = 'select-option';
          item.setAttribute('role', 'option');
          item.dataset.value = opt.value;
          item.textContent = opt.textContent;
          item.setAttribute('aria-selected', opt.selected ? 'true' : 'false');

          item.addEventListener('click', () => {
            select.value = opt.value;
            select.dispatchEvent(new Event('change', { bubbles: true }));
            updateLabel();
            rebuildOptions();
            const closeWithAnimation = () => {
              if (!menu.classList.contains('open')) {
                shell.dataset.open = 'false';
                trigger.setAttribute('aria-expanded', 'false');
                return;
              }

              menu.classList.add('closing');
              menu.classList.remove('open');
              const onEnd = (ev) => {
                if (ev && ev.target !== menu) return;
                menu.removeEventListener('transitionend', onEnd);
                menu.classList.remove('closing');
                shell.dataset.open = 'false';
                trigger.setAttribute('aria-expanded', 'false');
                if (shell.__followRAF) {
                  cancelAnimationFrame(shell.__followRAF);
                  shell.__followRAF = null;
                }
              };
              menu.addEventListener('transitionend', onEnd);
              setTimeout(() => onEnd({ target: menu }), 260);
            };
            closeWithAnimation();
          });

          menu.appendChild(item);
        });
      };

      updateLabel();
      rebuildOptions();

      select.classList.add('select-native');

      const parent = select.parentElement;
      if (!parent) return;
      parent.insertBefore(shell, select);
      shell.appendChild(trigger);
      // Portal menu to overlay inside filtersSection (container pai)
      const overlay = getOverlay();
      if (overlay) {
        shell.__overlay = overlay;
        overlay.appendChild(menu);
      } else {
        // fallback
        document.body.appendChild(menu);
      }
      shell.appendChild(select);

      trigger.addEventListener('click', () => {
        const isOpen = shell.dataset.open === 'true';
        if (isOpen) {
          shell.dataset.open = 'false';
          trigger.setAttribute('aria-expanded', 'false');
          menu.classList.remove('open');
          if (shell.__followRAF) {
            cancelAnimationFrame(shell.__followRAF);
            shell.__followRAF = null;
          }
          return;
        }
        closeAll(shell);
        shell.dataset.open = 'true';
        trigger.setAttribute('aria-expanded', 'true');
        rebuildOptions();
        menu.classList.add('open');
        // Double rAF garante layout estável antes de medir/posicionar
        requestAnimationFrame(() => {
          requestAnimationFrame(() => {
            positionMenu(shell);
            startFollowing(shell);
          });
        });
      });

      select.addEventListener('change', () => {
        updateLabel();
        rebuildOptions();
      });
    }

    function boot() {
      document.querySelectorAll('select.select-elegant').forEach(buildCustomSelect);

      document.addEventListener('click', (e) => {
        const target = e.target;
        const shell = target && target.closest ? target.closest('.select-shell') : null;
        closeAll(shell);
      });

      window.addEventListener('resize', () => {
        document.querySelectorAll('.select-shell[data-open="true"]').forEach((shell) => positionMenu(shell));
      });

      window.addEventListener('scroll', () => {
        document.querySelectorAll('.select-shell[data-open="true"]').forEach((shell) => positionMenu(shell));
      }, { passive: true });
    }

    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', boot);
    } else {
      boot();
    }
  })();
</script>

<!-- Intro.js JS -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/intro.js/7.2.0/intro.min.js"></script>
<!-- Onboarding Module -->
<script src="assets/js/utils/onboarding.js"></script>
<!-- Initialize Onboarding -->
<script>
  document.addEventListener('DOMContentLoaded', function () {
    if (window.NAAMOnboarding) {
      window.NAAMOnboarding.init('painel-casos');
    }
  });
</script>

</html>